/* Generate a visitor class and nodes

 Copyright (c) 2000-2001 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.

                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY

@ProposedRating Red (cxh@eecs.berkeley.edu)
@AcceptedRating Red (cxh@eecs.berkeley.edu)
*/

package ptolemy.lang;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.StringTokenizer;

//////////////////////////////////////////////////////////////////////////
//// GenerateVisitor
/**  Generate a visitor class and a group of node classes.

The following command:
<pre>
cd $PTII/ptolemy/lang/java
javac ptolemy.lang.GenerateVisitor NodeTypes.def JavaVisitor TreeNode nodetypes
</pre>
Will read NodeTypes.def and generate JavaVisitor.java and a
nodetypes directory.


 <p>The syntax of NodeTypes.def is documented in Jeff Tsay's Masters
report at
http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/,
below is a brief summary.
<menu>
<li>
   <li> cheader: common header
   <li> vheader: visitor header
   <li> nheader: nodes
   <li> iheader: interface that contains node IDS.
   <li> NamedNode I ITreeNode m NameNode getName m m void setName
        NameNode name m
	<br>generate interface NamedNode.java, derived from ITreeNode.
	it has method getName, returning NameNode.
	method definition is enclosed by "m" on both sides.
   <li> I means interface.
   <li> A means abstract class.
   <li> C is concrete class.
   <li> S singleton class, used for types, or an absent tag indicating a
	missing field, such as a static initializer not given in a declaration.
   <li> m is method.
   <li> c is constructor.  "c 0 c" passes no arguments to super constructor.
     (always the first n args are passed).
   <li> SN singleton class not generated by the parser. Types like null,
       or {...} for array inits.

</menu>

@author Jeff Tsay
@version $Id$
 */
public class GenerateVisitor {

    public GenerateVisitor(String[] args) throws IOException {

        File inputFile  = new File(args[0]);

        String visitorOutFileName;
        if (args.length < 2) {
            _visitorClassName = "Visitor";
            visitorOutFileName = "Visitor.java";
        } else {
            _visitorClassName = args[1];
            visitorOutFileName = _visitorClassName + ".java";
        }

        if (args.length < 3) {
            _baseNodeName = "TreeNode";
        } else {
            _baseNodeName = args[2];
        }

        if (args.length < 4) {
            _nodePath = ".";
        } else {
            _nodePath = args[3];
        }

        if (_nodePath.charAt(_nodePath.length() - 1) != File.separatorChar) {
            _nodePath = _nodePath + File.separatorChar;
        }

        File visitorOutFile = new File(visitorOutFileName);

        if (!visitorOutFile.createNewFile()) {
            visitorOutFile.delete();
            visitorOutFile = new File(visitorOutFileName);
            visitorOutFile.createNewFile();
        }

        try {
            _visitorOutFileWriter = new FileWriter(visitorOutFile);
        } catch (FileNotFoundException e) {
            System.err.println("Couldn't open destination file.");
            return;
        }

        try {
            _inputFileReader = new LineNumberReader(new FileReader(inputFile));
        } catch (FileNotFoundException e) {
            System.err.println("Couldn't open input file.");
            return;
        }

        // initialize _lastLine
        _lastLine = _inputFileReader.readLine();

        // get common header for nodes and visitor
        String commonHeader = _readBlock("cheader");

        // get header for visitor
        _visitorHeader = commonHeader + _readBlock("vheader");

        // get header for nodes
        _nodeHeader = commonHeader + _readBlock("nheader");

        // get header for classID's
        _classIDHeader = commonHeader + _readBlock("iheader");
    }

    ///////////////////////////////////////////////////////////////////
    ////                         public methods                    ////

    /** Generate the visitor class and the node class files */
    public void generate() throws IOException {

        _visitorOutFileWriter.write(_visitorHeader);
        _visitorOutFileWriter.write("public class "+ _visitorClassName +
                " implements IVisitor {\n" +
                "    public " + _visitorClassName + "() {\n" +
                "        this(TM_CHILDREN_FIRST);\n" +
                "    }\n\n" +
                "    public " + _visitorClassName +
                "(int traversalMethod) {\n" +
                "        if (traversalMethod > TM_CUSTOM) {\n" +
                "           throw new RuntimeException(\"" +
                "Illegal traversal method\");\n" +
                "        }\n" +
                "        _traversalMethod = traversalMethod;\n" +
                "    }\n\n");

        _readPlacement();

        _readClassInfo();

        _inputFileReader.close();

        Iterator iterator = _typeList.iterator();
        Iterator parentIterator = _parentTypeList.iterator();
        Iterator concreteIterator = _isConcreteList.iterator();
        Iterator singletonIterator = _isSingletonList.iterator();
        Iterator inTreeIterator = _isInTreeList.iterator();
        Iterator interfaceIterator = _isInterfaceList.listIterator();
        Iterator methodListIterator = _methodListList.iterator();
        Iterator implListIterator = _implListList.iterator();

        while (iterator.hasNext()) {
            String typeName = (String) iterator.next();
            String parentTypeName = (String) parentIterator.next();
            boolean isConcrete = ((Boolean) concreteIterator.next()).booleanValue();
            boolean isSingleton =
                ((Boolean) singletonIterator.next()).booleanValue();
            boolean isInterface =
                ((Boolean) interfaceIterator.next()).booleanValue();
            boolean isInTree =
                ((Boolean) inTreeIterator.next()).booleanValue();

            LinkedList methodList = (LinkedList) methodListIterator.next();
            LinkedList implList = (LinkedList) implListIterator.next();

            if (isConcrete) {
                if (isInTree) {
                    _visitorOutFileWriter.write(
                            "\n" +
                            "    public Object visit" + typeName + "(" +
                            typeName +
                            " node, LinkedList args) {\n" +
                            "        return _defaultVisit(node, args);\n" +
                            "    }\n");
                }

                _idStringList.add(typeName.toUpperCase() + "_ID");
            }

            _generateNodeFile(typeName, parentTypeName, isConcrete,
                    isSingleton, isInterface, isInTree, methodList, implList);

            _generateClassIDFile();
        }

        _visitorOutFileWriter.write(
                "\n" +
                "    /** Specify the order in visiting the nodes. */\n" +
                "    public final int traversalMethod() { " +
                "return _traversalMethod; }\n" +
                "\n" +
                "    /** The default visit method. */\n" +
                "    protected Object _defaultVisit(" + _baseNodeName +
                " node, LinkedList args) {\n" +
                "        return null;\n" +
                "    }\n" +
                "\n" +
                "    protected final int _traversalMethod;\n" +
                "}\n");

        _visitorOutFileWriter.close();
    }

    public static void main(String[] args) throws IOException {
        if (args.length < 1) {
            System.out.println("Usage : GenerateVisitor TypeNameListFile " +
                    "[VisitorClassName] [BaseNodeName] [node path]");
            return;
        }

        GenerateVisitor genVisitor = new GenerateVisitor(args);

        genVisitor.generate();
    }

    ///////////////////////////////////////////////////////////////////
    ////                         protected methods                 ////

    protected String _readBlock(String marker) throws IOException {
        if (_lastLine != null) {
            _lastLine = _lastLine.trim();
        }

        while ((_lastLine != null) &&
                (_lastLine.equals("") || _lastLine.startsWith("//"))) {
            _lastLine = _inputFileReader.readLine();

            if (_lastLine != null) {
                _lastLine = _lastLine.trim();
            }
        }

        String beginTag = "<" + marker + ">";
        String endTag   = "</" + marker + ">";

        if ((_lastLine == null) || !_lastLine.equals(beginTag)) {
            return "";
        }

        StringBuffer stringBuffer = new StringBuffer();

        boolean endHeader = false;
        do {
            _lastLine = _inputFileReader.readLine();

            endHeader = ((_lastLine == null) || _lastLine.equals(endTag));

            if (!endHeader) {
                stringBuffer.append(_lastLine + "\n");
            }
        } while (!endHeader);

        _lastLine = _inputFileReader.readLine();

        stringBuffer.append('\n');

        return stringBuffer.toString();
    }

    protected void _generateNodeFile(String typeName, String parentTypeName,
            boolean isConcrete, boolean isSingleton, boolean isInterface,
            boolean isInTree, LinkedList methodList, LinkedList implList)
            throws IOException {
        File nodeFile = new File(_nodePath + typeName + ".java");

        if (!nodeFile.createNewFile()) {
            nodeFile.delete();
            nodeFile = new File(_nodePath + typeName + ".java");
            nodeFile.createNewFile();
        }

        FileWriter nodeFileWriter = new FileWriter(nodeFile);

        StringBuffer stringBuffer = new StringBuffer();

        stringBuffer.append(_nodeHeader);

        stringBuffer.append("public ");

        boolean concreteClass = isConcrete && !isInterface;

        if (!isConcrete && !isInterface) {
            stringBuffer.append("abstract ");
        } else if (isSingleton) {
            stringBuffer.append("final ");
        }

        stringBuffer.append(isInterface ? "interface " : "class ");
        stringBuffer.append(typeName);

        if (!parentTypeName.equals("<none>")) {
            stringBuffer.append(" extends ");
            stringBuffer.append(parentTypeName);
        }

        Iterator implIterator = implList.listIterator();

        if (implIterator.hasNext()) {
            stringBuffer.append(" implements ");

            do {
                String interfaceName = (String) implIterator.next();

                stringBuffer.append(interfaceName);

                if (implIterator.hasNext()) {
                    stringBuffer.append(", ");
                }
            } while (implIterator.hasNext());
        }

        stringBuffer.append(" {\n");

        if (concreteClass) {
            String idString = typeName.toUpperCase() + "_ID";

            // add a method to return the class id
            methodList.add(new MethodSignature("public final", "int",
                    "classID", new LinkedList(), new LinkedList(),
                    "return NodeClassID." + idString + ";"));

            if (isInTree) {
                // add a method that accepts a visitor
                LinkedList acceptMethodArgTypes = new LinkedList();
                acceptMethodArgTypes.addLast("IVisitor");
                acceptMethodArgTypes.addLast("LinkedList");

                LinkedList acceptMethodArgNames = new LinkedList();
                acceptMethodArgNames.addLast("visitor");
                acceptMethodArgNames.addLast("args");

                methodList.add(new MethodSignature("protected final",
                        "Object", "_acceptHere",
                        acceptMethodArgTypes, acceptMethodArgNames,
                        "return ((" + _visitorClassName +
                        ") visitor).visit" + typeName + "(this, args);"));

            }
        }

        if (isSingleton) {

            // add the instance of the singleton
            ClassField cf  = new ClassField(typeName, "instance",
                    "public static final", "new " + typeName + "()");
            methodList.addLast(cf);

            // add the constructor of the singleton
            MethodSignature methodSignature = new MethodSignature(typeName);
            methodList.addLast(methodSignature);

            // add a isSingleton() method
            methodList.add(new MethodSignature("public final", "boolean",
                    "isSingleton", new LinkedList(), new LinkedList(),
                    "return true;"));
        }

        // do methods first
        Iterator methodIterator = methodList.listIterator();

        while (methodIterator.hasNext()) {
            Object o = methodIterator.next();

            if (o instanceof MethodSignature) {
                stringBuffer.append(o.toString() + "\n");
            }
        }

        // now do fields
        methodIterator = methodList.listIterator();

        while (methodIterator.hasNext()) {
            Object o = methodIterator.next();

            if (o instanceof ClassField) {
                stringBuffer.append(o.toString() + "\n");
            }
        }

        stringBuffer.append("}\n");

        nodeFileWriter.write(stringBuffer.toString());
        nodeFileWriter.close();
    }

    protected void _generateClassIDFile() throws IOException {
        File nodeClassIDFile = new File(_nodePath + "NodeClassID.java");

        if (!nodeClassIDFile.createNewFile()) {
            nodeClassIDFile.delete();
            nodeClassIDFile = new File(_nodePath + "NodeClassID.java");
            nodeClassIDFile.createNewFile();
        }

        FileWriter nodeClassIDFileWriter = new FileWriter(nodeClassIDFile);

        StringBuffer stringBuffer = new StringBuffer();

        stringBuffer.append(_classIDHeader);

        stringBuffer.append("public interface NodeClassID {\n");

        int count = 0;

        Iterator stringIterator = _idStringList.iterator();

        while (stringIterator.hasNext()) {
            String idString = (String) stringIterator.next();
            ClassField field = new ClassField("int", idString, "public",
                    Integer.toString(count));
            stringBuffer.append(field.toString() + '\n');
            count++;
        }
        stringBuffer.append("}\n");

        nodeClassIDFileWriter.write(stringBuffer.toString());
        nodeClassIDFileWriter.close();
    }

    protected void _readPlacement() throws IOException {
        _lastLine = _inputFileReader.readLine();

        if (_lastLine.startsWith("mplace")) {
            _defaultPlacement = _lastLine.charAt(7);
            _lastLine = _inputFileReader.readLine();
        }
    }

    protected void _readClassInfo() throws IOException {
        StringTokenizer stringTokenizer;
        String className;
        String marker;

        do {
            if ((_lastLine != null) && (_lastLine.length() > 4) &&
                    !(_lastLine.startsWith("//"))) {

                stringTokenizer = new StringTokenizer(_lastLine);

                className = stringTokenizer.nextToken();

                //System.out.println("Reading class info for : "
                //                       + className);

                try {
                    _typeList.addLast(className);
                } catch (NullPointerException e) {
                    System.err.println("Not enough parameters in line : " +
                            _lastLine);
                    return;
                }

                String nextToken = stringTokenizer.nextToken();

                boolean isSingleton;
                boolean isInterface;
                boolean isConcrete;
                try {
                    isSingleton = nextToken.startsWith("S");
                    _isSingletonList.addLast(new Boolean(isSingleton));

                    isConcrete = isSingleton || nextToken.startsWith("C");
                    _isConcreteList.addLast(new Boolean(isConcrete));

                    isInterface = nextToken.startsWith("I");
                    _isInterfaceList.addLast(new Boolean(isInterface));

                    _isInTreeList.addLast(
                            new Boolean(!nextToken.endsWith("N")));

                } catch (NullPointerException e) {
                    System.err.println("Not enough parameters in line : " +
                            _lastLine);
                    return;
                }

                try {
                    nextToken = stringTokenizer.nextToken();
                    _parentTypeList.addLast(nextToken);
                } catch (NullPointerException e) {
                    System.err.println("Not enough parameters in line : " +
                            _lastLine);
                    return;
                }

                LinkedList methodList = new LinkedList();
                LinkedList implList   = new LinkedList();

                while (stringTokenizer.hasMoreTokens()) {
                    marker = stringTokenizer.nextToken();
                    char markChar = marker.charAt(0);
                    switch (markChar) {

                    case 'c':
                    case 'm':
                        {
                            MethodSignature methodSignature =
                                new MethodSignature(markChar, stringTokenizer,
                                        className, _defaultPlacement,
                                        isInterface, isConcrete);
                            methodList.addLast(methodSignature);
                        }
                        break;

                    case 'k':
                        {
                            MethodSignature methodSignature =
                                new MethodSignature(markChar, stringTokenizer,
                                        className, _defaultPlacement,
                                        isInterface, isConcrete);

                            methodList.addLast(methodSignature);
                            methodList.addAll(methodSignature.accessors());
                        }
                        break;

                    case 'i': // add a class name to the implements list
                        {
                            boolean isName;
                            do {
                                nextToken = stringTokenizer.nextToken();

                                isName = ((nextToken != null) &&
                                        !nextToken.equals("i"));
                                if (isName) {
                                    implList.addLast(nextToken);
                                }
                            } while (isName);
                        }
                        break;

                    default:
                        throw new RuntimeException("Unrecognized marker : " +
                                marker);
                    }
                }

                _methodListList.addLast(methodList);
                _implListList.addLast(implList);
            }
            _lastLine = _inputFileReader.readLine();
        } while (_lastLine != null);
    }

    ///////////////////////////////////////////////////////////////////
    ////                         protected variables               ////

    protected char _defaultPlacement = 'l';

    protected FileWriter _visitorOutFileWriter;
    protected LineNumberReader _inputFileReader;

    protected LinkedList _typeList = new LinkedList();
    protected LinkedList _parentTypeList = new LinkedList();
    protected LinkedList _isConcreteList = new LinkedList();
    protected LinkedList _isSingletonList = new LinkedList();
    protected LinkedList _isInterfaceList = new LinkedList();
    protected LinkedList _isInTreeList = new LinkedList();
    protected LinkedList _methodListList = new LinkedList();
    protected LinkedList _implListList = new LinkedList();

    protected LinkedList _idStringList = new LinkedList();

    protected String _visitorClassName;
    protected String _baseNodeName;
    protected String _nodeHeader;
    protected String _visitorHeader;
    protected String _classIDHeader;
    protected String _nodePath;

    protected String _lastLine;

    ///////////////////////////////////////////////////////////////////
    ////                         inner class                       ////

    public static class MethodSignature {
        public MethodSignature() {}

        public MethodSignature(String modifiers, String returnType,
                String name,
                LinkedList paramTypes, LinkedList paramNames,
                String methodBody) {
            _modifiers = modifiers;
            _returnType = returnType;
            _name       = name;
            _paramTypes = paramTypes;
            _paramNames = paramNames;
            _methodBody = methodBody;
        }

        /** a singleton constructor */
        public MethodSignature(String className) {
            _modifiers = "private";
            _name = className;
            _construct = true;
            _isConcrete = true;
        }

        /** a constructor or method */
        public MethodSignature(char signatureType, StringTokenizer stringToken,
                String className, char defaultPlacement, boolean isInterface,
                boolean isConcrete)
                throws IOException {

            _isInterface = isInterface;
            _isConcrete = isConcrete;

            _defConstruct = (signatureType == 'k');
            _construct = (signatureType == 'c') || _defConstruct;

            _modifiers = "public";

            if (_construct) { // constructor
                _name = className;
                _returnType = "";

                _superParameters = Integer.parseInt(stringToken.nextToken());

            } else if (signatureType == 'm') { // method
                _superParameters = 0;

                if (!isInterface) _modifiers += " final";

                _returnType = stringToken.nextToken() + " ";

                _name = stringToken.nextToken();
            } else {
                throw new RuntimeException("Invalid token for " +
                        "MethodSignature : " + signatureType);
            }

            String s = stringToken.nextToken();

            while (!(s.equals("c") || s.equals("m") || s.equals("k"))) {
                if (s.charAt(0) == '{') {
                    // explicit placement, don't check
                    _variablePlacements.addLast(new Character(s.charAt(1)));
                    s = s.substring(3);
                }  else {

                    if ((defaultPlacement == 'l') && _isJavaType(s)) {
                        // make it a member if it's a Java type and we
                        // default to put it in a list
                        _variablePlacements.addLast(new Character('m'));
                    } else {
                        if (defaultPlacement == 'l') {
                            _childListSize++;
                        }

                        _variablePlacements.addLast(
                                new Character(defaultPlacement));
                    }
                }

                if (s.equals("[")) { // super constructor argument
                    StringBuffer stringBuffer = new StringBuffer();
                    boolean isInit;

                    s = stringToken.nextToken();

                    stringBuffer.append(s);

                    do {
                        s = stringToken.nextToken();

                        isInit = !s.equals("]");

                        if (isInit) {
                            stringBuffer.append(' ');
                            stringBuffer.append(s);
                        }
                    } while (isInit);

                    _superArgs.addLast(stringBuffer.toString());

                    _paramTypes.addLast("omitted");
                    _paramNames.addLast("omitted");

                } else {

                    _paramTypes.addLast(s);

                    String paramName = stringToken.nextToken();

                    _paramNames.addLast(paramName);
                    _superArgs.addLast(paramName);
                }

                s = stringToken.nextToken();
            }
        }

        /** A getter or a setter method for a child in the list.
         *  The childIndex parameter is necessary to differentiate
         *  this constructor from the following constructor.
         */
        public MethodSignature(String returnType, String name,
                int childIndex, boolean setter) {
            _modifiers = "public final";

            Character firstLetter =
                new Character(Character.toUpperCase(name.charAt(0)));

            String partName = firstLetter.toString() + name.substring(1);

            if (setter) {
                _returnType = "void";
                _name = "set" + partName;

                _paramTypes.addLast(returnType);
                _paramNames.addLast(name);

                _methodBody = "_childList.set(CHILD_INDEX_" +
                    name.toUpperCase() + ", " + name + ");";

            } else {
                _returnType = returnType;
                _name = "get" + partName;


                _methodBody = "return (" + _returnType +
                    ") _childList.get(CHILD_INDEX_" +
                    name.toUpperCase() + ");";
            }
        }

        /** A getter or a setter method for data not in the list. */
        public MethodSignature(String returnType, String name,
                boolean setter) {
            _modifiers = "public final";

            Character firstLetter =
                new Character(Character.toUpperCase(name.charAt(0)));

            String partName = firstLetter.toString() + name.substring(1);

            if (setter) {
                _returnType = "void";
                _name = "set" + partName;

                _paramTypes.addLast(returnType);
                _paramNames.addLast(name);

                _methodBody = "_" + name + " = " + name + ";";
            } else {
                _returnType = returnType;
                _name = "get" + partName;

                _methodBody = "return _" + name + ";";
            }
        }

        /** A hasX() method that returns true. */
        public MethodSignature(String name, int dummy) {
            _modifiers = "public final";

            Character firstLetter =
                new Character(Character.toUpperCase(name.charAt(0)));

            String partName = firstLetter.toString() + name.substring(1);

            _name = "has" + partName;
            _returnType = "boolean";
            _methodBody = "return true;";
        }

        public String methodBody(String methodName) {

            if (_methodBody != null) {
                return _IDENT + _IDENT + _methodBody;
            }

            if (_construct) {

                StringBuffer stringBuffer = new StringBuffer();

                if (_superParameters > 0) {

                    Iterator argsIterator = _superArgs.listIterator();

                    stringBuffer.append(_IDENT + _IDENT);
                    stringBuffer.append("super(");

                    for (int i = 0; i < _superParameters; i++) {
                        stringBuffer.append((String) argsIterator.next());

                        if (i < (_superParameters - 1)) {
                            stringBuffer.append(", ");
                        }
                    }

                    stringBuffer.append(");\n");
                }

                if (_defConstruct) {

                    Iterator typeIterator = _paramTypes.listIterator();
                    Iterator nameIterator = _paramNames.listIterator();
                    Iterator variablePlaceIterator = _variablePlacements.listIterator();

                    int variableCount = 0;

                    do {
                        String typeStr = (String) typeIterator.next();
                        String nameStr = (String) nameIterator.next();
                        char placement =
                            ((Character) variablePlaceIterator.next()).charValue();

                        if (variableCount >= _superParameters) {

                            stringBuffer.append(_IDENT);
                            stringBuffer.append(_IDENT);

                            switch (placement) {

                            case 'l':
                                stringBuffer.append("_childList.add(" + nameStr + ");");
                                break;

                            case 'm':
                            case 'h':
                                if (methodName.equals("NameNode")) {

                                    // Most compilers keep a unique
                                    // copy of each string in memory,
                                    // because identifiers of
                                    // variables, classes, packages,
                                    // etc. are very likely to appear
                                    // many times in the program. This
                                    // means that several uses of the
                                    // same identifier refer to the
                                    // same string, reducing the
                                    // memory needed to store ASTs. In
                                    // Java, this functionality is
                                    // implemented by method
                                    // "intern()" in class
                                    // Java.lang.String.

                                    stringBuffer.append("_" + nameStr + " = " +
                                            nameStr + ".intern();");
                                } else {
                                    stringBuffer.append("_" + nameStr + " = " +
                                            nameStr + ";");
                                }
                                break;

                            case 'p':
                                stringBuffer.append("setProperty(" + nameStr + ", " +
                                        _wrapPrimitive(typeStr, nameStr) +
                                        ");");
                                break;

                            case 'n':
                                // do nothing
                                break;

                            default:
                                throw new RuntimeException(
                                        "unknown variable placement");
                            }

                            if (typeIterator.hasNext()) {
                                stringBuffer.append('\n');
                            }
                        }

                        variableCount++;
                    } while (typeIterator.hasNext());
                }

                if (_isConcrete) {
                    stringBuffer.append("\n" + _IDENT + _IDENT +
                            "_childList.trimToSize();");
                }

                return stringBuffer.toString();
            } // if _construct

            // this is method

            if (_returnType.equals("void") || _returnType.equals("")) {
                return "";
            }

            if (_returnType.equals("long")) {
                return _IDENT + _IDENT + "return 0L;";
            }

            if (_returnType.equals("int") || _returnType.equals("short") ||
                    _returnType.equals("byte")) {
                return _IDENT + _IDENT + "return 0;";
            }

            if (_returnType.equals("char")) {
                return _IDENT + _IDENT + "return '\\0';";
            }

            if (_returnType.equals("float")) {
                return _IDENT + _IDENT + "return 0.0f;";
            }

            if (_returnType.equals("double")) {
                return _IDENT + _IDENT + "return 0.0d";
            }

            if (_returnType.equals("boolean")) {
                return _IDENT + _IDENT + "return false";
            }

            return _IDENT + _IDENT + "return null;";
        }

        public String toString() {
            StringBuffer stringBuffer = new StringBuffer(_IDENT);

            if (!_modifiers.equals("")) {
                stringBuffer.append(_modifiers + " ");
            }

            if (!_returnType.equals("")) {
                stringBuffer.append(_returnType + " ");
            }

            stringBuffer.append(_name + "(");

            Iterator typeIterator = _paramTypes.listIterator();
            Iterator nameIterator = _paramNames.listIterator();

            int paramCount = 0;
            while (typeIterator.hasNext()) {

                String typeName = (String) typeIterator.next();
                String paramName = (String) nameIterator.next();

                if (!typeName.equals("omitted")) {
                    if (paramCount > 0) {
                        stringBuffer.append(", ");
                    }
                    paramCount++;

                    stringBuffer.append(typeName);
                    stringBuffer.append(' ');
                    stringBuffer.append(paramName);
                }
            }

            stringBuffer.append(')');

            if (_isInterface) {
                stringBuffer.append(";");
            } else {
                stringBuffer.append(" {\n" + methodBody(_name) + "\n" + _IDENT + "}\n");
            }

            return stringBuffer.toString();
        }

        public LinkedList accessors() {
            LinkedList returnValue = new LinkedList();

            int variableCount = 0;
            int childIndex = 0;

            Iterator typeIterator = _paramTypes.listIterator();
            Iterator nameIterator = _paramNames.listIterator();
            Iterator variablePlaceIterator = _variablePlacements.listIterator();

            while (typeIterator.hasNext()) {

                String typeStr = (String) typeIterator.next();
                String nameStr = (String) nameIterator.next();
                char placement = ((Character) variablePlaceIterator.next()).charValue();

                if (variableCount >= _superParameters) {

                    switch (placement) {

                    case 'l':
                        // getter
                        returnValue.addLast(new MethodSignature(typeStr, nameStr,
                                childIndex, false));

                        //setter
                        returnValue.addLast(new MethodSignature(typeStr, nameStr,
                                childIndex, true));

                        // getter index
                        returnValue.addLast(new ClassField("int",
                                "CHILD_INDEX_" + nameStr.toUpperCase(),
                                "public static final",
                                Integer.toString(childIndex)));
                        break;

                    case 'h': // member with hasX()
                        returnValue.addLast(new MethodSignature(nameStr, -1));
                        // no break;

                    case 'm': // member
                        returnValue.addLast(new ClassField(typeStr, nameStr));

                        // getter
                        returnValue.addLast(new MethodSignature(typeStr, nameStr,
                                false));

                        // setter
                        returnValue.addLast(new MethodSignature(typeStr, nameStr,
                                true));
                        break;

                    case 'n':
                        // do nothing
                        break;

                    case 'p': // property
                        // do nothing : data is accessed through
                        // PropertyMap methods
                        break;

                    default:
                        throw new RuntimeException(
                                "unknown variable placement");

                    }
                }

                if (placement == 'l') {
                    childIndex++;
                }

                variableCount++;
            }

            return returnValue;
        }

        protected String _wrapPrimitive(String typeStr, String nameStr) {
            String wrapper = null;

            if (typeStr.startsWith("int")) {
                wrapper = "Integer";
            } else if (typeStr.startsWith("char")) {
                wrapper = "Character";
            } else if (typeStr.startsWith("long")) {
                wrapper = "Long";
            } else if (typeStr.startsWith("byte")) {
                wrapper = "Byte";
            } else if (typeStr.startsWith("float")) {
                wrapper = "Float";
            } else if (typeStr.startsWith("double")) {
                wrapper = "Double";
            } else if (typeStr.startsWith("boolean")) {
                wrapper = "Boolean";
            }

            if (wrapper != null) {
                return "new " + wrapper + "(" + nameStr + ")";
            } else {
                return nameStr;
            }
        }

        protected String _modifiers = "public ";
        protected String _returnType = "";
        protected String _name;

        protected LinkedList _paramTypes = new LinkedList();
        protected LinkedList _paramNames = new LinkedList();
        protected LinkedList _variablePlacements = new LinkedList();
        protected LinkedList _superArgs = new LinkedList();

        protected int _childListSize = 0; // not currently used

        protected int _superParameters = 0;

        protected String _methodBody = null;

        protected boolean _construct = false;
        protected boolean _isInterface = false;
        protected boolean _defConstruct = false;

        /** True if this is a member of a concrete class. */
        protected boolean _isConcrete = false;
    }

    public static class ClassField {
        public ClassField(String type, String name, String modifiers,
                String init) {
            _type = type;
            _name = name;
            _modifiers = modifiers;
            _init = init;
        }

        public ClassField(String type, String name) {
            this(type, name, "protected", null);
        }

        public String toString() {
            StringBuffer stringBuffer = new StringBuffer();
            stringBuffer.append(_IDENT);
            stringBuffer.append(_modifiers);
            stringBuffer.append(' ');
            stringBuffer.append(_type);
            stringBuffer.append(' ');

            if (!_modifiers.startsWith("public")) {
                stringBuffer.append(" _");
            }

            stringBuffer.append(_name);

            if (_init != null) {
                stringBuffer.append(" = " + _init);
            }

            stringBuffer.append(';');
            return stringBuffer.toString();
        }

        String _type;
        String _name;
        String _modifiers;
        String _init;
    }

    ///////////////////////////////////////////////////////////////////
    ////                         private methods                   ////

    private static final boolean _isPrimitiveType(String s) {
        return (s.startsWith("int") || s.startsWith("char") ||
                s.startsWith("long") || s.startsWith("byte") ||
                s.startsWith("float") || s.startsWith("double") ||
                s.startsWith("boolean"));
    }

    private static final boolean _isJavaType(String s) {
        return (_isPrimitiveType(s) || s.startsWith("String"));
    }

    ///////////////////////////////////////////////////////////////////
    ////                         private variables                 ////

    private static final String _IDENT = "    ";
}
