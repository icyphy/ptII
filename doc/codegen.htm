<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Code Generation</title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>
<body>
<html>

<h2>
  <a name="149600"> </a>4  Copernicus
</h2>
</div>
This is an HTML version of a chapter from the
<a href="design/main.htm">Ptolemy II Design Document"</a>
<p><a name="161048"> </a>Authors: Steve Neuendorffer<br>		Christopher Brooks<br>


<a name="166235"> </a>		Ankush Varma<br>


<a name="166236"> </a>		Shuvra S. Bhattacharyya<br>


<h3>
  <a name="161042"> </a>4.1   Introduction
</h3>


<a name="164034"> </a>The copernicus package is an infrastructure for building code generators for Ptolemy II models. The basic design goal was to provide a common interface to different code generators and consolidate some of the basic argument handling and default parameters. Several different code generators of varying complexity have been implemented. There is also quite a bit of testing infrastructure for integrating code generation with the nightly build system.<br>


<p>
  <a name="163738"> </a>The basic infrastructure is implemented in the copernicus.kernel package. The Copernicus class contains a main function suitable for invocation from the command line. The GeneratorAttribute class represents code generation parameters that can be persistently added to a model for unusual configurations of a code generator. The KernelMain class is a base class from which classes for various code generators can be derived. Instances of these subclasses are instantiated and executed in a code generation job. 
</p>


<p>
  <a name="164042"> </a>The Copernicus class itself is invoked to begin code generation from a model. If invoked from the command line, it reads command line arguments to determine various code generation options and an MoML file to load a model from. If invoked via various static methods, code generation options are assumed to be passed in through a GeneratorAttribute. Default code generation options are specified in the Generator.xml file. One of the code generation parameters determines the code generator to execute. The class representing the code generator is loaded through reflection and invoked through the KernelMain base class.
</p>


<p>
  <a name="164047"> </a>The KernelMain base class provides default behavior for most code generators. It performs static analysis, such as type resolution and scheduling by invoking the Manager.preinitalizeAndResolveTypes() method and then passes control to the specific code generator.
</p>


<h4>
  <a name="164113"> </a>4.1.1   Default options
</h4>


<a name="164120"> </a>Most code generators share common options. The following options are defined by default in generator.xml.<br>


<p>
  <a name="164123"> </a>codeGenerator: The code generator to run.
</p>


<p>
  <a name="164127"> </a>
</p>


<p>
  <a name="164128"> </a>codeGeneratorClassName: The class that is instantiated to execute a particular code generator.  This class is expected to be a subclass of ptolemy.copernicus.kernel.KernelMain.
</p>


<p>
  <a name="164134"> </a>
</p>


<p>
  <a name="164135"> </a>compile: If true, compile the generated code.  The default is true.
</p>


<p>
  <a name="164139"> </a>
</p>


<p>
  <a name="164140"> </a>show: If true, then show the generated code.  The default is true.
</p>


<p>
  <a name="164144"> </a>
</p>


<p>
  <a name="164145"> </a>run:  If true, then run the generated code.  The default is true.
</p>


<p>
  <a name="164149"> </a>
</p>


<p>
  <a name="164150"> </a>ptII: The location of the Ptolemy II classes.  The default is the value of the ptolemy.ptII.dir Java system property
</p>


<p>
  <a name="164155"> </a>
</p>


<p>
  <a name="164156"> </a>ptIIUserDirectory: The top level directory to write the code in. The default is the value of the ptII parameter. The code will appear in 'ptIIUserDirectory/targetpath'.
</p>


<p>
  <a name="164162"> </a>
</p>


<p>
  <a name="164163"> </a>targetPackage: The package to generate code in. The default is the model name
</p>


<p>
  <a name="164167"> </a>
</p>


<p>
  <a name="164168"> </a>targetPath: The path relative to the ptIIUserDirectory to generate code in. The default is the "cg" subdirectory of the particular code generator.
</p>


<p>
  <a name="164316"> </a>
</p>


<p>
  <a name="164269"> </a>outputDirectory: The directory that code will be generated in. By default this is the targetPath parameter appended to the ptIIUserDirectory path.
</p>


<p>
  <a name="164274"> </a>
</p>


<p>
  <a name="164275"> </a>modelPath: The path to the model, including the .xml extension. The modelPath parameter is converted to a URL internally before use.
</p>


<p>
  <a name="164299"> </a>
</p>


<p>
  <a name="164300"> </a>compileOptions: User supplied arguments to be passed to the code generator.  Defaults to the empty string.
</p>


<p>
  <a name="164305"> </a>
</p>


<p>
  <a name="164121"> </a>javaClassPath: The Java class path, converted to a string.
</p>


<p>
  <a name="164417"> </a>
</p>


<p>
  <a name="164362"> </a>runCommandTemplateFile: The template file that contains the command to run the generated code.
</p>


<p>
  <a name="164367"> </a>
</p>


<p>
  <a name="164368"> </a>runOptions: User supplied arguments to be passed to the command that will run the generated code. Defaults to the empty string.
</p>


<p>
  <a name="164373"> </a>
</p>


<p>
  <a name="164374"> </a>sootDir: The directory that contains the soot jar files. Defaults to the value of the ptII parameter  + "/lib"
</p>


<p>
  <a name="164379"> </a>
</p>


<p>
  <a name="164380"> </a>sootClasses: The location of sootclasses.jar, jasminclasses.jar and the Java system jar (usually rt.jar).  The necessaryClassPath parameter may end up duplicating some of the elements of this parameter.
</p>


<p>
  <a name="164462"> </a>
</p>


<p>
  <a name="164463"> </a>watchDogTimeout: The number of milliseconds that code generation will run for. Defaults to 720000, which is 12 minutes. The watchdog is used to prevent the code generator and the generated code from hanging the nightly build.
</p>


<p>
  <a name="164400"> </a>
</p>


<p>
  <a name="164401"> </a>output: The filename to redirect the standard output stream of the code generator to.  This is used, for example, in the nightly build to provide easily parseable error messages.  If the value is not set, then the output will not be redirected.
</p>


<p>
  <a name="164360"> </a>
</p>


<h3>
  <a name="164057"> </a>4.2   Java Code Generator
</h3>


<a name="164071"> </a>The Java code generator is implemented by the copernicus.java package. This code generator targets the generation of self-contained Java code optimized for code size, memory usage and execution speed. The Java code generator leverages the Soot compiler framework to parse the bytecode for each atomic actor in the model. The actors are then specialized according to their context in the model [98].<br>


<p>
  <a name="164509"> </a>The Java code generator operates in several phases, and the output of each phase is a partially specialized model. The output from the intermediate phases can be generated by setting the <i>snapshots</i> parameter to be true. The first snapshot consists of self-contained code specialized to the domains in the model. The second snapshot is additionally specialized to the parameter values in the model, while the third is specialized to the structure of the model. The fourth snapshot eliminates all references to Ptolemy named objects in the model, resulting in self-contained code without component interfaces. The final generated code has also been specialized for data types and contains no references to Ptolemy tokens.
</p>


<p>
  <a name="164531"> </a>One of the goals of the Java code generator was to avoid separate specifications for simulation and code generation wherever possible. The Java code generator operates by transforming Java actor specifications (actor classes) and on Java data type specifications (token classes). In most cases, new actor and token classes will be leveraged transparently by the code generator. Unfortunately, domain specifications are not as easily reused and the Java code generator contains "re-implementations" of domains for code generation. This allows for more efficient code to be generated, at the expense of duplicating aspects of existing Director and Receiver code, and making it more difficult for new domains to be implemented in code generation.
</p>


<p>
  <a name="164576"> </a>In order for existing actor code to be leveraged by the code generator, it assumes that the code is written according to the Ptolemy style for writing actors. This style assumes naming conventions for the public fields of an actor class that refer to parameters and ports of the actor. The code generator also assumes that the ports and parameters of an actor are created in the class constructor and not modified later. Some actors do not fit these constraints and cannot be used directly in the code generator. Such actor classes cannot be used directly by the code generator, although in some cases we have been able to have the code generator deal specially with such actors. In other cases, the actor class fits the constraints but cannot be effectively specialized using generic techniques. Such actors can also be dealt with specially by the code generator to more effectively generate code.
</p>


<h4>
  <a name="164584"> </a>4.2.1   Software Architecture
</h4>


<p>
  <a name="164568"> </a>The Java code generator consists of a large number of individual transformation steps, which will not be described here. These transformation steps are implemented by classes extending the SceneTransformer class, or the BodyTransformer class. Two key points of extensibility are provided for generating domain code and for generating actor code to replace unspecializable actor classes.
</p>


<p>
  <a name="164603"> </a>Code generation for specific domains is handled by various implementations of the DomainCodeGenerator interface. An implementation of this interface is responsible for generating domain interaction code for a particular composite actor in the hierarchy, including code to invoke the methods of various actors and domain-specific communication structures. Currently, the following domains are handled:
</p>


<p>
  <a name="164607"> </a>Synchronous Dataflow (SDF): The SDF implementation transforms the SDF schedule into Java code that invokes the actors in a model. Fixed size arrays are generated for communication buffers dedicated to each relation in the model, and communication methods are replaced with circularly indexed addressing into the communication buffers.
</p>


<p>
  <a name="164623"> </a>Hybrid Systems (HS): The hybrid systems director deals with modal models. Currently, only the subset that is useful in modal SDF models is implemented.
</p>


<p>
  <a name="164624"> </a>Giotto: The Giotto implementation interfaces directly with the Java output of the Giotto compiler. It generates classes with static methods used for communication by the Giotto compiler and generates a .giotto file that describes the classes implementing the various Giotto tasks. The Giotto compiler compiles this file into a class that implements the Giotto task scheduling model.
</p>


<p>
  <a name="164627"> </a>Code Generation for actors is handled various implementations of the AtomicActorCreator interface. An implementation of this interface generates a self-contained class for a particular actor. The default implementation of this interface, the GenericAtomicActorCreator class, simply copies the existing actor specification code. Other implementations of the interface deal with generating code for specific actors. Currently the following actors are handled specially:
</p>


<p>
  <a name="164637"> </a>Expression: The standard implementation of this actor builds a parse tree for the expression and traverses the parse tree to evaluate it at run time. This actor is handled specifically by the ExpressionCreator class for two reasons. Primarily, the parse tree is convenient way of representing an arbitrary expression, but much simpler code can be generated for a specific expression. Secondarily, the parse tree complicates other transformations that specialize communication between actors and data types.
</p>


<p>
  <a name="164638"> </a>FSMActor: The standard implementation of this actor builds parse trees for every expression in a model, and suffers from the same drawbacks as the Expression actor. The FSMActor also attempts to deal with run-time modifications of the finite-state machine in an efficient manner, which is not necessary in generated code. This actor is handled specifically by the FSMCreator class.
</p>


<p>
  <a name="164639"> </a>Many actors are not handled specifically, but should be. Here is a short list:
</p>


<p>
  <a name="164640"> </a>MathFunction: This actor creates and deletes its ports based on a parameter value. In generated code will likely not happen (since the parameter value is not likely to change), but the GenericAtomicActorCreator is not smart enough to deal with ports that are not created in the constructor. It is likely easiest to handle this actor by handling it specially and checking that the parameter value does not change using reconfiguration analysis.
</p>


<p>
  <a name="164641"> </a>TypeTest: This actor tests the type system, but has no run-time behavior. It is problematic because it iterates over all of the actors in a model, which is currently not supported by the code generation mechanism. It could probably be checked statically and ignored in generated code.
</p>


<p>
  <a name="164642"> </a>RecordAssembler and RecordDisassembler: These actors iterator over their input and output ports to construct a record. They could either be dealt with specially, or the code generator could be improved to unroll iterators over ports.
</p>


<p>
  <a name="164643"> </a>ExpressionToToken and ExpressionReader: These actors operate in a similar way to the expression actor, except that the expression is received from an input port. Because of this, code generation will not work. It is not clear how to make this actor work nicely with type specialization.
</p>


<h4>
  <a name="164644"> </a>4.2.2   Generated Code
</h4>


<p>
  <a name="164645"> </a>The code generated from the Java code generator is a set of self-contained Java .class files with a command-line interface. A makefile is automatically generated with a large number of rules for manipulating the generated code. The makefile rules are:
</p>


<p>
  <a name="164959"> </a>	runJava: Run the generated code.
</p>


<p>
  <a name="164676"> </a>compareAll: Run a series of comparisons between the simulation model, the generated code, and the obfuscated version of the generated code comparing code size, execution speed, and memory usage.
</p>


<p>
  <a name="164707"> </a>treeShake: Generate a self-contained .jar file containing only code necessary for the generated code. This rule uses reachable method information gained through static analysis in the code generator, if possible. 
</p>


<p>
  <a name="164974"> </a>treeShakeByRunning: Generate a self-contained .jar file containing only code necessary for the generated code. This rule executes the generated code and extracts information from the virtual machine about which classes were loaded at runtime.
</p>


<p>
  <a name="164732"> </a>runTreeShake: Run the generated code from the self-contained .jar file.
</p>


<p>
  <a name="164739"> </a>profileTreeShake: Run the generated code from the self-contained .jar file with profiling options to report runtime memory usage. An average of several runs is reported.
</p>


<p>
  <a name="165000"> </a>treeShakeWithoutCodegen: Generate a self-contained .jar file containing only code necessary for executing the simulation model. This rule executes the generated code and extracts information from the virtual machine about which classes were loaded at runtime.
</p>


<p>
  <a name="164768"> </a>runTreeShakeWithoutCodegen: Run the original simulation model from the self-contained .jar file.
</p>


<p>
  <a name="165017"> </a>profileTreeShakeWithoutCodegen: Run the original simulation model from the self-contained .jar file with profiling options to report runtime memory usage. An average of several runs is reported.
</p>


<p>
  <a name="164862"> </a>obfuscate: Run the Jode obfuscator on the generated code, to minimize the size of the generated .jar file.
</p>


<p>
  <a name="164867"> </a>runObfuscate: Run the obfuscated version of the generated code.
</p>


<p>
  <a name="165066"> </a>profileObfuscate: Run the obfuscated version of the generated code from the self-contained .jar file with profiling options to report runtime memory usage. An average of several runs is reported.
</p>


<p>
  <a name="164909"> </a>gcj: Compile the generated code into a native executable using gcj. Note: this will likely only work for simple models, as the gcj standard Java libraries are far from complete.
</p>


<h3>
  <a name="165980"> </a>4.3   C Code Generator
</h3>


<a name="165981"> </a>The C code generator is implemented by the copernicus.c package. This code generator targets the generation of self-contained C code by post-processing the result of the Java code generator, and performing further code size optimizations. The C code generator leverages the Soot compiler framework to parse the bytecode representation for each class to be compiled.<br>


<p>
  <a name="165982"> </a>Within the Ptolemy II framework, the C code generator takes the class files generated by copernicus.java as input.The C code generator can also be used as a stand-alone Java-to-C compiler to generate C code for arbitrary Java programs.
</p>


<h4>
  <a name="165983"> </a>4.3.1   Code Generation
</h4>


<a name="165984"> </a>The main steps in the code generation algorithm are as follows:<br>


<a name="165985"> </a>1.	 Read in main class file using Soot.<br>


<a name="165986"> </a>2.	 Use CallGraphPruner to compute the set of required methods, classes and fields.<br>


<a name="165987"> </a>3.	 Generate .c and .h files for the main class(es).<br>


<a name="165988"> </a>4.	 Generate a .c file containing code for initialization and setup.<br>


<a name="165989"> </a>5.	 Generate .c and .h files for all required Java library classes in a separate directory (named j2c_lib by default). Note that these only contain code for required methods and fields, to minimize code size. The code for each method is generated by converting the jimple statements for the method's body atomically into the appropriate C constructs.<br>


<a name="165990"> </a>6.	 Generate a makefile for compiling the code into an executable.<br>


<h4>
  <a name="165991"> </a>4.3.2   The Code Pruning Algorithm
</h4>


<p>
  <a name="165992"> </a>The Soot framework is used to create a Call Graph of the application. This is a graph with methods as the nodes, and calls from one method to another as directed edges.
</p>


<p>
  <a name="165993"> </a>At first glance, it seems that the transitive closure of the methods in the main class should represent all methods that can be called. However, this is not so, because the first time the field or method of a class is referenced, its class initialization method is also invoked, and this can reference other methods or fields in turn.
</p>


<p>
  <a name="165994"> </a>The method call graph also contains an edge from a method to every possible target of method calls in it. The number of such targets can be large for polymorphic method calls. A more sophisticated analysis can trim the method call graph by removing some of the edges corresponding to polymorphic invocations.
</p>


<p>
  <a name="165995"> </a>We use Soot's Variable Type Analysis (VTA) to perform this call graph trimming. This analysis computes the possible runtime types of each variable using a reaching type analysis, and uses this information to remove spurious edges.
</p>


<h4>
  <a name="165996"> </a>Computing the Set of Required Entities
</h4>


<p>
  <a name="165997"> </a>
</p>


<p>
  <a name="165998"> </a>From the analysis mentioned above, the set of all possible required classes, methods and fields (collectively grouped as <i>entities</i>) can be statically computed. We use a set of rules to determine which classes are required. 
</p>


<a name="165999"> </a>1.	 A set of compulsory entities is always required. This includes the System.initializeSystemClass() method, all methods and fields of the java.lang.Object class (since it is the global superclass) and the main method of the main class to be compiled.<br>


<a name="166000"> </a>2.	 If a method<i> m</i> is required, the following also become required: the class declaring <i>m</i>, all methods that may possibly be called by <i>m</i>, all fields accessed in the body of <i>m</i>, the classes of all local variables and arguments of m, the classes corresponding to all exceptions that may be caught or thrown by <i>m</i>, and the method corresponding to <i>m</i> in all required subclasses of the class declaring <i>m</i>.<br>


<a name="166001"> </a>3.	 If a field <i>f</i> is required, the following also become required: the class declaring <i>f</i>, the class corresponding to the type of <i>f</i> (if any) and the field corresponding to <i>f</i> in all required subclasses of the class declaring it.<br>


<a name="166002"> </a>4.	 If a class <i>c</i> is required, the following also become required: all superclasses of <i>c</i>, the class initialization method of <i>c</i>, and the instance initialization method of <i>c</i>.<br>


<p>
  <a name="166003"> </a>Interfaces are treated as classes. A worklist-based algorithm can be used to add to the set of required entities until no additional entities can be found by application of these rules. Together, rules 2, 3 and 4 encapsulate all possible dependencies between entities. This makes the set of required entities self-contained.
</p>


<h4>
  <a name="166004"> </a>4.3.3   Limitations
</h4>


<a name="166005"> </a>The restrictions imposed C-based static compilation strategy are:<br>


<a name="166006"> </a>	 Dynamic Loading and Reflection are not supported.<br>


<a name="166007"> </a>	 The generated executable runs as a user process, so applications that rely on a JVM as a buffer between them and the platform for security cannot be guaranteed to run correctly.<br>


<p>
  <a name="166008"> </a>The further limitations of the current implementation are:
</p>


<a name="166009"> </a>	 No support for threads.<br>


<a name="166010"> </a>	 GUI-based functions are currently not implemented.<br>


<a name="166011"> </a>	 Certain java classes are not currently supported, because the native methods for them need to be coded. The list of these is maintained in the OverriddenMethodGenerator class.<br>


<h4>
  <a name="166012"> </a>4.3.4   Options
</h4>


<a name="166013"> </a>There are a number of command-line options available:<br>


<a name="166014"> </a>	 verbose: <i>true/false</i> Turns verbose mode on or off. <br>


<a name="166015"> </a>	 compileMode: <i>singleClass</i> compiles only the given class, <i>full</i> generates all required files. <br>


<a name="166016"> </a>	 pruneLevel: <i>0</i> no code pruning done, <i>1</i> code pruning done by CallGraphPruner. <br>


<a name="166017"> </a>	 vta: <i>true/false</i> Whether or not to perform Variable Type Analysis.<br>


<a name="166018"> </a>	 lib: the path to the directory where library of generated files should be stored. <br>


<a name="166019"> </a>	 gcDir: stores the path to the directory containing the garbage collector. Not using this option turns the collector off. <br>


<a name="166020"> </a>	 target: The target platform. A blank refers to a generic POSIX-like system including Cygwin installations.<i> C6000</i> The TMS320C6xxx series of processors. <br>


<a name="166021"> </a>	 runtimeDir: The path to the runtime directory. <br>


<a name="166022"> </a>	 ptII: The path to the ptII directory. <br>


<a name="166023"> </a>	 compulsoryMethods: A semicolon-separated list of methods for which code must always be generated. If more than one such entity is to be specified, the entire list may be enclosed within double quotes. The complete method subsignature of the form <i>returnType class.method(arg1, arg2, ...)</i> must be specified. <br>


<a name="166024"> </a>	 cFlags: The GCC flags to be used in the makefile. <br>


<a name="166025"> </a>	 reportEntities: <i>true/false</i> whether to output a summary of the number of classes, methods and fields (entities) generated.<br>


<h4>
  <a name="166026"> </a>4.3.5   Directory structure
</h4>


<a name="166027"> </a>The main subdirectories in copernicus.c are:<br>


<a name="166028"> </a>	 runtime: Contains a small amount of C code that provides basic functionality. This is linked in while generating the executables.<br>


<a name="166029"> </a>	 runtime/native_bodies: C code for native methods.<br>


<a name="166030"> </a>	 runtime/over_bodies: C code for methods with custom code.<br>


<a name="166031"> </a>	 test: Various test programs.<br>


<a name="166032"> </a>	 testOutput: Auto-generated C code.<br>


<h4>
  <a name="166033"> </a>4.3.6   Code Flow
</h4>


<a name="166034"> </a>The following UML diagram shows the various classes that populate copernicus.c. This is a relatively complex package, so many implementation details have been abstracted out. Complete descriptions of all classes and their members are available in the API, and we attempt to provide an insight into the higher-level structure of the package here.<br>


<a name="166035"> </a>	 Protected and private methods are not shown, unless they are central to the functionality of the class.<br>


<a name="166036"> </a>	 Unimportant external superclasses are not shown here.<br>


<a name="166037"> </a>	 Public methods that are not central to the operation of the class are omitted.<br>


<a name="166038"> </a>	 CSwitch has a caseXXX method for each kind of Jimple statement XXX. These are shown as a single entry in the figure.<br>


<a name="166039"> </a>	 The methods in ExceptionTracker are omitted. This class tracks the current exceptions and works closely with MethodCodeGenerator. However, the C implementation of Java exceptions is complex and is not discussed here.<br>


<p>
  <a name="166040"> </a>
</p>


<p>
  <a name="166041"> </a>The dashed arrows in the UML diagram represent the coarse-grained code flow in copernicus.c. The entry class is JavaToC when used in stand-alone mode, and Main when copernicus.c is used as a ptolemy code-generation back-end.
</p>


<p>
  <a name="166042"> </a>JavaToC reads in a Java class file and implicitly converts it to the Soot Jimple format. Then it calls RequiredFileGenerator, MakeFileGenerator and MainFileGenerator.
</p>


<p>
  <a name="166043"> </a>RequiredFileGenerator uses CallGraphPruner to compute the set of required classes, methods and fields. Then it calls ClassFileGenerator, HeaderFileGenerator and StubFileGenerator on each required class.
</p>


<p>
  <a name="166044"> </a>ClassFileGenerator creates the .c file containing all the function definitions. Each of these function definitions is created by MethodCodeGenerator. MethodCodeGenerator calls CSwitch on each Jimple statement to find its C equivalent.
</p>


<p>
  <a name="166045"> </a>HeaderFileGenerator creates the .h file corresponding to the class. This consists of a class-specific C structure for the class (created by ClassStructureGenerator), an instance-specific C structure for the class (created by InstanceStructureGenerator) and various function declarations. MethodListGenerator is the class that "understands" inheritance to create the lists of constructors, inherited methods, new methods, private methods, etc.
</p>


<p>
  <a name="166046"> </a>StubFileGenerator creates a small "stub" of prototype declarations useful for breaking circular dependencies between classes.
</p>


<p>
  <a name="166047"> </a>MakeFileGenerator creates a makefile proving rules for compiling the generated C code into an executable.
</p>


<p>
  <a name="166048"> </a>MainFileGenerator creates a file that contains the C "main" method, which performs initialization functions, wraps the command-line arguments into the C equivalent of a Java string array and passes them to the "java" main method.
</p>


<p>
  <a name="166049"> </a>In addition, CNames converts Java names into unique legal C names, InterfaceLookupGenerator takes care of resolving interface method invocations, FileHandler provides file I/O utilities, Options stores configuration information, Context handles useful global information, NativeMethodGenerator handles native methods and OverriddenMethodGenerator allows user-defined code to override the compiler.
</p>



<h4>
  <a name="166050"> </a>4.3.7   HOW TOs
</h4>


<h4>
  <a name="166051"> </a>Generating an executable from a Java ClassFile
</h4>


<a name="166052"> </a><br>


<p>
  <a name="166053"> </a>Put the classfile in c/test
</p>


<p>
  <a name="166054"> </a>cd test
</p>


<p>
  <a name="166055"> </a>java -classpath $classpath ptolemy.copernicus.c.JavaToC $classpath 	 &lt;className&gt;
</p>


<p>
  <a name="166056"> </a>(note that the classpath has to be specified twice)
</p>


<p>
  <a name="166057"> </a>make -s -f &lt;classname&gt;.make
</p>


<h4>
  <a name="166058"> </a>Generating Code from a MoML model
</h4>


<p>
  <a name="166059"> </a>
</p>


<p>
  <a name="166060"> </a>Move the xml model to c/test/simple
</p>


<p>
  <a name="166061"> </a>java ptolemy.copernicus.kernel.Copernicus -codeGenerator c &lt;model&gt;.xml
</p>


<h4>
  <a name="166062"> </a>Writing Code for a Native Method
</h4>


<a name="166063"> </a><br>


<p>
  <a name="166064"> </a>Java requires certain <i>native</i> methods, which are methods implemented in platform-dependent code, typically written in another programming language such as C. The C code generator allows the user to specify C code for the body of any native method. At compile-time, this is integrated with the generated C code, allowing any C native methods to be fully supported. To do this:
</p>


<a name="166065"> </a>1.	 Find the C name of that method (say <i>f00xx_abc</i>).<br>


<a name="166066"> </a>2.	 Create a file by this name (<i>f00xx_abc.c</i>) in runtime/native_bodies, containing the code for that method.<br>


<a name="166067"> </a>3.	 Add this method to the list of native methods in NativeMethodGenerator.<br>


<h4>
  <a name="166068"> </a>Overriding Code for an Existing Method
</h4>


<a name="166069"> </a><br>


<p>
  <a name="166070"> </a>It is also possible to override the C code generator and write custom C code for a given method instead. To do this:
</p>


<a name="166071"> </a>1.	 Find the C name of that method (say <i>f00xx_abc</i>).<br>


<a name="166072"> </a>2.	 Create a file by this name (<i>f00xx_abc.c</i>) in runtime/over_bodies, containing the code for that method.<br>


<a name="166073"> </a>3.	 Add this method to the list of overridden methods in OverriddenMethodGenerator.<br>


<p>
  <a name="166074"> </a>Note that the term <i>overridden</i> in this context does not refer to methods that are overridden through inheritance in Java classes.
</p>


<h4>
  <a name="166075"> </a>Suppressing Code Generation for a Method, Class or Package
</h4>


<a name="166076"> </a><br>


<p>
  <a name="166077"> </a>To "turn off" code generation for a method, override it without creating code for it in runtime/over_bodies. For an entire class or package, list it in OverriddenMethodGenerator.isOverriddenClass(). This will generate methods with blank bodies and trivial return statements which will return 0 or NULL. 
</p>


<p>
  <a name="167212"> </a>CAVEAT: Make sure that the returned values are not used. Referencing a NULL pointer will cause the executable to throw a segmentation fault.
</p>


<h3>
  <a name="167213"> </a>4.4   Applet Code Generator
</h3>


<p>
  <a name="166584"> </a>The Applet code generator takes a model and creates HTML files for use as a web based applet.
</p>


<p>
  <a name="166587"> </a>The applet generator reads template files that end in .in from $PTII/ptolemy/copernicus/applet substitutes keywords and writes out the files in the destination directory. Users may modify the template files to match their local setup
</p>


<p>
  <a name="166593"> </a>Making an applet available via the web is somewhat complex because the Java Plugin has two sections, one for Netscape, the other for Internet Explorer, so changes to the htm files must be replicated in both sections. The codebase and the location of the jar files also add to the problems.
</p>


<p>
  <a name="166599"> </a>If a model is named MyModel, and the user selects foo.bar as the package, then saving the model as an applet will create a directory called $PTII/foo/bar/MyModel and create the following files for that model:
</p>


<p>
  <a name="166604"> </a>   
</p>


<p>
  <a name="166605"> </a>   makefile
</p>


<p>
  <a name="166606"> </a>          make demo will run appletviewer on the HTML files
</p>


<p>
  <a name="166607"> </a>          
</p>


<p>
  <a name="166608"> </a>   MyModel.xml
</p>


<p>
  <a name="166609"> </a>          A local copy of the model
</p>


<p>
  <a name="166610"> </a>          
</p>


<p>
  <a name="166611"> </a>   MyModel.htm
</p>


<p>
  <a name="166612"> </a>          An HTML file containing the code necessary to MyModel.xml
</p>


<p>
  <a name="166613"> </a>          
</p>


<p>
  <a name="166614"> </a>   MyModelVergil.htm
</p>

<dl>
  <dt> <a name="166615"> </a>          An HTML file containing the code necessary to display MyModel.xml graphically, using ptolemy.vergil.VergilApplet and in text format
</dl>

<h4>
  <a name="166618"> </a>4.4.1   Applet Code Generation demonstrations
</h4>


<a name="167739"> </a>Below are several demonstrations of the applet code generator. The code generator graphical user interface is difficult to use, so we recommend using the copernicus command instead of using the code generator GUI.<br>


<p>
  <a name="167895"> </a>The OrthogonalCom model generates prints output to standard out, so when this model is run as an applet, the output will appear in the Java Plugin console. Instead, we generate an applet for the Butterfly model, which will generate display a nice plot. Note that the Butterfly model uses the Expression actor so that while we cannot use deep code generation on the Butterfly actor, we can generate an applet for this model.
</p>


<h4>
  <a name="167907"> </a>Copernicus command - create applet within the Ptolemy tree
</h4>


<a name="167908"> </a><br>


<a name="167909"> </a>To create the html file and open it with the browser:<br>

<pre>
cd $PTII/ptolemy/domains/sdf/demo/Butterfly<a name="167910"> </a>
$PTII/bin/copernicus -codeGenerator applet Butterfly.xml<a name="167911"> </a>
</pre>

<p>
  <a name="167914"> </a>The HTML can be found in $PTII/ptolemy/copernicus/applet/cg/Butterfly.
</p>


<h4>
  <a name="167743"> </a>Applet code generator GUI - create applet within the Ptolemy Tree
</h4>


<a name="167761"> </a><br>


<a name="168316"> </a>If you would like to generate an applet in a directory within the Ptolemy tree using the experimental code generation GUI, follow these steps:<br>


<a name="168314"> </a>1.	 Open up the SDF Butterfly Model at $PTII/ptolemy/domains/sdf/demo/Butterfly/Butterfly.xml.<br>


<a name="167794"> </a>2.	 Select View -&gt; Code Generator<br>


<a name="166628"> </a>3.	 Change the CodeGenerator combo box from java to applet<br>


<a name="166629"> </a>4.	 Hit the Generate Button<br>


<a name="166630"> </a>5.	 The code generator will invoke an separate java process that generates code in $PTII/ptolemy/copernicus/applet/cg/Butterfly and then opens the generated file with the browser.<br>


<h4>
  <a name="167927"> </a>Copernicus command - create applet outside the Ptolemy tree
</h4>


<a name="167928"> </a><br>


<p>
  <a name="167943"> </a>Usually, one wants to put an applet on a website. Ptolemy applets require jar files for the runtime environment, so the applet code generator will copy the necessary jar files if the value of the ptIIUserDirectory parameter is outside the $PTII directory.
</p>


<a name="167929"> </a>1.	 If you built Ptolemy II from source, generate Ptolemy II jar files by running<br>

<pre>
cd $PTII<a name="167930"> </a>
make install<a name="167931"> </a>
</pre>

<a name="167932"> </a>2.	 Create the target directory:<br>

<pre>
mkdir c:/tmp/ptIIapplet/Butterfly<a name="168234"> </a>
</pre>

<a name="168230"> </a>3.	 Invoke copernicus:<br>

<pre>
cd $PTII/ptolemy/domains/sdf/demo/Butterfly<a name="167933"> </a>
$PTII/bin/copernicus -codeGenerator applet -ptIIUserDirectory \<a name="167934"> </a>
       c:/tmp/ptIIapplet -targetPath Butterfly Butterfly.xml<a name="168226"> </a>
</pre>

<p>
  <a name="167936"> </a>Note that the copernicus command should be typed in on one line.
</p>


<h4>
  <a name="167755"> </a>Applet code generator GUI - create applet outside the Ptolemy tree
</h4>


<a name="167780"> </a><br>


<a name="167777"> </a>If you would like to generate an applet in a directory outside of the Ptolemy tree using the experimental code generation GUI, follow these steps:<br>


<a name="166635"> </a>1.	 If you built Ptolemy II from source, generate Ptolemy II jar files by running<br>

<pre>
cd $PTII<a name="167830"> </a>
make install<a name="167831"> </a>
</pre>

<a name="168252"> </a>2.	 Create the target directory:<br>

<pre>
mkdir c:/tmp/ptIIapplet/Butterfly<a name="168253"> </a>
</pre>

<a name="168250"> </a>3.	 Open up the SDF Butterfly Model at $PTII/ptolemy/domains/sdf/demo/Butterfly/Butterfly.xml<br>


<a name="167883"> </a>4.	 Select View -&gt; Code Generator<br>


<a name="166637"> </a>5.	 Change the CodeGenerator combo box from java to applet<br>


<a name="166638"> </a>6.	 Change the ptIIUserDirectory to the directory where you would like the applet to be created, for example<br>

<pre>
c:/tmp/ptapplet<a name="167819"> </a>
</pre>

<p>
  <a name="166642"> </a>       Note that the directory must already exist. If it does not exist, then the default directory will automatically be used.
</p>


<a name="166644"> </a>7.	 Change the targetPath to the string<br>

<pre>
$modelName<a name="167808"> </a>
</pre>

<a name="166646"> </a>8.	 Change the modelName parameter to<br>

<pre>
Butterfly<a name="168262"> </a>
</pre>

<a name="168258"> </a>9.	 Hit the Parameters button, which will update the parameters and display their values.<br>


<a name="167531"> </a>10.	 Hit the Generate Button<br>


<a name="166649"> </a>11.	 The code generator will invoke an separate java process that generates an applet and then invokes the browser on the generated HTML code.<br>


<h4>
  <a name="168287"> </a>4.4.2     Applet Limitations
</h4>


<p>
  <a name="166656"> </a>Under Web Start, you may need to add classes to the necessaryClasses parameter so that the necessaryClassPath parameter will get updated with the appropriate jar files and passed to the subprocess that invokes the applet code generator. The reason this is necessary is because Web Start is invoked using a special class loader that accesses separate jar files in the Web Start cache. The applet code generator does not have direct access to the Web Start class loader, so we tell it what classes we need so that they can be added to the class path.
</p>


<a name="166666"> </a>	 It would be nice if the applet code generator would bundle up the necessary class files in a single jar file so that it was easier to install an applet.<br>


<a name="166669"> </a>	 The applet code generator could use tree shaking to create a much smaller jar file that contains only the classes that are used. One issue is that the user would need to exercise the applet by invoking all the features of the GUI, such as the plot format window.<br>


<a name="166676"> </a>	 The applet code generator should grab the top level text annotations from the MoML file and use them as comments.<br>


<p>
  <a name="166678"> </a>
</p>
</blockquote>


<h2><a name="ui">The Code Generator User Interface</a></h2>
Christopher Hylands and Professor Edward A. Lee developed an initial
draft of a graphical user interface to control code generation.  

 <p>The user interface reads its parameters from a moml file, the
 default is 
<a href="../ptolemy/copernicus/kernel/Generator.xml"><CODE>$PTII/ptolemy/copernicus/kernel/Generator.xml</CODE></a>.
This file lists the parameters, the initial default value
the documentation for the parameter.
 <p>The documentation for a parameter is viewable as a tool tip.
Try moving the mouse over the name of the parameter, a tool
tip should pop up.
 <p>There are quite a few different parameters, and parameters
can refer to each other by name.  The values of some parameters,
such as the <CODE>modelName</CODE> and <CODE>iterations</CODE>
are derived from the model itself and not actually settable.
 <p>There are several buttons:
<dl>

<dt> <CODE>More Info</CODE>
<dd> Brings up this file.

<dt> <CODE>Parameters</CODE>
<dd> Display the name of the parameter, the value, the value
the parameter evaluates to and the documentation.
<dt> <CODE>Generate</CODE>
<dd> Run the code generator.  Note that the 
<CODE>compile</CODE>, <CODE>show</CODE> and 
<CODE>run</CODE> checkboxes determine whether code is generated
shown and run.
<dt> <CODE>Cancel</CODE>
<dd> Stop a Generation that is in progress
<dt> <CODE>Clear</CODE>
<dd> Clear the output display
</dl>

<h3>How the user interface works</h3>

The code generator is controlled by a GeneratorAttribute
that contains parameters read in from the 
<I>initialParametersURL</I> parameter.  

 <p>When the user hits View -&gt; Code Generator, the model
is queried and any necessary updates to the Parameters occurs.

 <p>When the user hits the <CODE>Generate</CODE> button, the model is
again queried and any necessary updates occur.

 <p>Each of the code generators contains template files
that determine what command is actually run.
For example, the
java code generator uses
<a href="../ptolemy/copernicus/java/runCommandTemplate.txt"><CODE>$PTII/ptolemy/copernicus/java/runCommandTemplate.txt</CODE></a>
to determine what command to run the generated code.
The format of the files is fairly straightforward, parameters are
substituted in and the command is executed.

We use template files
so that the code generator can be run without requiring the
<CODE>make</CODE> program.

<h3><a name="userInterfaceLimitations">User Interface Limitations</a></h3>

Unfortunately, this UI has many design issues:
<ul>
<li> The UI uses a GeneratorAttribute to manage the values of the
various settings for the code generator.  When you select
View -&gt; Code Generator, the GeneratorAttribute is added to
the model, which may require that the model be saved - even though
the user has not set any of the code generator settings yet.
<br>If the code generator is run on a model, and the GeneratorAttribute
is added to the model, then if the model is saved and then
opened in the Ptiny version of Ptolemy II (that does not include the
code generator),  then a dialog will pop up about 
how the GeneratorAttribute is not present.


<li> The interface is cluttered because there are many different
possible parameters to set.  It is fairly easy to make have an
interface that generates code in a default directory with default
names.  However, generating code in non-default locations requires
understanding how the parameter values affect code generation.

<li> The interface uses Ptolemy Parameters so that we can refer 
to other Parameters by name and use their values.  This means
that simple strings need to be enclosed in double quotes.

<li> It would be nice if there was an easier way to see what a
parameter evaluated to.

</ul>
 
<h2><a name="history">Code Generation History</a></h2>

<h3>Ptolemy Classic code generation</h3>

In Ptolemy Classic code generation, each separate platform had a
separate domain. This was a slight misuse of the domain
concept, since all most all of the separate platforms really had SDF
semantics, and each separate platform was really a target for the SDF
domain.  However, because of assumptions in the Ptolemy Classic
software architecture, it was easier to add new code generation
targets as separate domains.

 <p>In Ptolemy Classic, if you wanted to generate code for a new
processor, you had to create a new domain and then populate the domain
with new basic blocks that contained codeblocks of code that were
generated when the basic block was used.  This is a bit of a
simplification, but basically it meant that for each new processor,
the author had to generate a new Ramp basic block, a new Add basic
block etc.  This was very time consuming, and tended to have problems,
since if a bug was fixed in one Ramp actor, the bug needed to be fixed
in other Ramp actors in each domain.

 <p>The Adaptive Computing System (ACS) domain was an effort to work
around this issue, where the interface to each actor was shared
between multiple implementations.  This helped make it easier to
switch between different target implementations, since the ACS Ramp
actor always had the same interface, whereas if there were two Ramp
actors in two separate domains, then they might have different port
names, which made switching between the domains difficult.

 <p>More information about the ACS domain can be found in
E. K. Pauer, C. S. Myers, P. D. Fiore, J. M. Smith, C. M. Crawford, E. A. Lee, J. Lundblad and C. Hylands,
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/98/ACSmapping/">"Algorithm Analysis and Mapping Environment for Adaptive Computing Systems,"</a>
 Presented at the Second Annual Workshop on High Performance
 Embedded Computing, MIT Labs, Lexington, MA, September, 1998. 

 <p>The ACS domain is part of Ptolemy 0.7.2devel, see
<a href="http://ptolemy.eecs.berkeley.edu/ptolemyclassic/pt0.7.2/"><CODE>http://ptolemy.eecs.berkeley.edu/ptolemyclassic/pt0.7.2/</CODE></a>


The Ptolemy Classic style of code generation was used to customize
different actors to take advantage of different features of a
processor.  For example, the Motorola 56x FIR filter actor would pick
a different codeblock depending on how the FIR filter was configured.

 <p>However, the downside of this approach is that the inter-actor
communication tended to consume quite a bit of time, so even with
really great actor implementations, we were getting performance hits
when data was passed between these actors.  It seems to us that
looking at the whole model would yield further performance
improvements.


<h3>Deep Generation History</h3>

Deep code generation parses Java component definitions, and provides
an API for accessing the abstract syntax tree.  It is possible,
in principle, to generate implementations in languages other than
Java from this AST.  Thus, we hope that in the future, we will have
code generators that produce C code for embedded processors,
or VHDL code for hardware design.
<p>
In 2000, Jeff Tsay created an initial implementation of Deep code
generation as part of his  his Masters project:
Jeff Tsay, "<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/" target="_top">A Code Generation Framework for Ptolemy II</a>," ERL Technical Report UCB/ERL No. M00/25, Dept. EECS, University of California, Berkeley, CA  94720, May 19, 2000.

 <p>There is a shorter summary of Jeff's work at:
 <p>Jeff Tsay, Christopher Hylands and Edward Lee, 
<a href="http://ptolemy.eecs.berkeley.edu/publications/papers/00/javacodegen">"A Code Generation Framework for Java Component-Based Designs,"</a>
 CASES 00, November 17-19, 2000, San Jose, CA.

 <p>Jeff's work was a prototype of how we could do code generation in a
different manner, described in the above references and below.
Unfortunately, his prototype code was not easy to extend to match
changes in the Ptolemy type system.  More specifically, the type system
is Yuhong Xiong's area of research, and Jeff's work was not easy to
extend to deal with ArrayTokens.


<h2><a name="soot">Soot</a></h2>
Stephen Neuendorffer developed the framework for the current code generators 
using Soot, which is a Java optimization framework from
<a href="http://www.sable.mcgill.ca/soot/" target="_top"><CODE>http://www.sable.mcgill.ca/soot/</CODE></a> 

<p>Soot operates on class files by applying a series of transformations
that usually do compiler things like common subexpression elimination
or loop unrolling.  We can add transformations that do things like
flattening a model into one class for shallow code generation, or
further processing the AST for deep code generation.

<p>The advantage of Soot over Jeff Tsay's work is that by using soot, we
do not have to parse java files, and the name resolution of objects is
done.  In Jeff's code, we spent a lot of time trying to figure out the
fully dot qualified name of an object who's base name was 'String'.

<p>Jeff Tsay's work was a proof of concept demonstration on what
could be done.  We hope that by using Soot, we can generate a stable system
for use in a production environment.

<h3>Multiprocessors and DSP targets</h3>

Partitioning a model between multiple processors is fairly tricky, and
was a large area of research in Ptolemy Classic.  Only models with a
high degree of parallelism are amenable to running on multiple
processors.  Simply assigning each actor to a processor is not likely
to yield performance improvements, since the inter-actor communication
will really bog things down, especially on a high latency system like
a switched ethernet network.

 <p>Java can take advantage of multiple processors, so in theory, if
we use the process domains in Ptolemy II without code generation on a
multi processor machine, we should see that each Java thread will be
run on a separate processor.  However we have not done much work in
this area.  We'd like to see someone take the PN domain and work on
running it on multiple processors and seeing what sort of improvements
can be made.

 <p>In theory, once we have deep code generation, and we are creating
an AST and generating .class files, we can generate code for any
processor by either writing a new back end, or using a native Java
compiler like gcj.

<h2><a name="future">Future Plans</a></h2>
<ul>
<li> Deep code generation needs to have the tokens unboxed so
that it no longer depends on ptolemy.data
<li> Generating C code from a Ptolemy Model is in progress.
<li> We have demonstrated that the Ptolemy code generation framework can
be used to generate FGPA code using
JHDL from Brigham Young University (<a href="http://www.jhdl.org" target="_top"><code>http://www.jhdl.org</code></a>)
</ul>

<h2><a name="resources">Resources</a></h2>
Below are links to various resources:

Soot uses jasmin
<ul>
<li> <a href="http://found.cs.nyu.edu/meyer/jasmin/" target="_top">Jasmin</a> 
a Java Assembler Interface (1997)
<li> <a
href="http://www.geocrawler.com/archives/3/338/1996/8/0/1876595/" target="_top">Jasmin
emacs mode</a>
</ul>

<h3><a name="disassemblers">Disassemblers</a></h3>
Soot works with byte codes.  A Java decompiler or disassembler 
can help with debugging
<dl>
<dt> <CODE>jode</CODE>
<dd> <a href="http://jode.sourceforge.net/download.php" target="_top">http://jode.sourceforge.net/download.php</a> - Written
in Java, but full GPL, so we can't distribute it.
<CODE>$PTII/bin/configure</CODE> looks for jode in 
<CODE>$PTII/vendors/jode/1.1.1</CODE>, and if it finds it, then
<CODE>$PTII/bin/jode</CODE> can be used to invoke jode.

<ol>
<li> Download <a href="http://prdownloads.sourceforge.net/jode/jode-1.1.1.jar"><code>http://prdownloads.sourceforge.net/jode/jode-1.1.1.jar</code></a>
and save it as <CODE>$PTII/ptolemy/vendors/jode/1.1.1/jode.jar</CODE>

<li> Rerun configure:
<pre>
cd $PTII
rm config.*
./configure
</pre>

<li> Update <CODE>$PTII/bin/jode</CODE>:
<pre>
cd $PTII/bin
make

</pre>

<li> Test it out be decompiling NamedObj:
<pre>
$PTII/bin/jode ptolemy.kernel.util.NamedObj
</pre>

</ol>

 <br>For example, this command will decompile 
the Main class that is generated by the deep code generator:
<pre>
$PTII/bin/jode ptolemy.copernicus.java.cg.OrthogonalCom.Main 
</pre>

<dt> <CODE>javap</CODE>
<dd> <a href="http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html" target="_top"><CODE>http://java.sun.com/j2se/1.3/docs/tooldocs/solaris/javap.html</CODE></a> - Shipped with Sun's JDK.

<dt> <code>Source Again</code>
<dd> <a href="http://www.ahpah.com/sourceagain/" target="_top"><code>http://www.ahpah.com/sourceagain/</code></a> - Commercial product

<dt> <code>WingDis</code>
<dd> <a href="http://www.wingsoft.com/wingdis.html" target="_top"><code>http://www.wingsoft.com/wingdis.html</code></a> - Commercial product

<dt> <CODE>jad</CODE>
<dd> <a href="http://www.geocities.com/SiliconValley/Bridge/8617/jad.html" target="_top"><CODE>http://www.geocities.com/SiliconValley/Bridge/8617/jad.html</CODE></a> - Jad home page - used to have binaries only, but now broken.
<br><a href="http://www.geocities.com/zz_xu/jad.html#download" target="_top"><code>http://www.geocities.com/zz_xu/jad.html#download</code></a> - Mirror site from 1999 - Jad 1.5.7
<br><a href="http://www.jproof.com/faq/MoreInfo.html" target="_top">http://www.jproof.com/faq/MoreInfo.html</a> - Jad 1.5.7

<a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/jad15.html" target="_top">Mirror, though downloads do not work</a>

</dl>

Other possibilities:
<ul>
<li> <a href="http://bcel.sourceforge.net/" target="_top"><CODE>http://bcel.sourceforge.net/</CODE></a>
</ul>


<h3>Java To C converters</h3>
<dl>
<dt> Java Coffee Break Decompiler links
<dd> <a href="http://www.javacoffeebreak.com/directory/index(32).html" target="_top"><CODE>http://www.javacoffeebreak.com/directory/index(32).html</CODE></a>

<dt> GCJ - The GNU Compiler for Java
<dd> <a href="http://gcc.gnu.org/java/" target="_top"><CODE>http://gcc.gnu.org/java/</CODE></a>: JDK1.2 compliant
<BLOCKQUOTE>
<ul>
<li> Java source code directly to native machine code, 
<li> Java source code to Java bytecode (class files), 
<li>  and Java bytecode to native machine code. 
</ul>
</BLOCKQUOTE>


<dt> Jolt: Converting bytecode to C
<dd> <a href="http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html" target="_top"><CODE>http://www.meurrens.org/ip-Links/Java/codeEngineering/blackDown/jolt.html</CODE></a>: initial hack


<dt> Harissa
<dd> <a href="http://compose.labri.fr/prototypes/harissa" target="_top"><code>http://compose.labri.fr/prototypes/harissa</code></a>: 1999: JDK1.0.2?


<dt> Toba: A Java-to-C Translater
<dd> <a href="http://www.cs.arizona.edu/sumatra/toba/" target="_top"><CODE>http://www.cs.arizona.edu/sumatra/toba/</CODE></a>: Does not support JDK1.2

</dl>

</body>
</html>

