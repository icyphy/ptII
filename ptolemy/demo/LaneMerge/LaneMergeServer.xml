<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="LaneMergeServer" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[65.0, 30.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={0, 23, 864, 632}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[630, 522]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.1332845233691975">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{282.95490121841436, 169.8920815744708}">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="At 120 km/hr, if cars&#10;appear every 6 seconds,&#10;they will be 200m apart.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[10.0, 185.0]">
        </property>
    </property>
    <property name="sensorDistanceToMerge" class="ptolemy.data.expr.Parameter" value="2.0">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 20.0]">
        </property>
    </property>
    <property name="freewaySpeed" class="ptolemy.data.expr.Parameter" value="120.0">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 35.0]">
        </property>
    </property>
    <property name="rampLength" class="ptolemy.data.expr.Parameter" value="0.5">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 50.0]">
        </property>
    </property>
    <property name="maxRampSpeed" class="ptolemy.data.expr.Parameter" value="60.0">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 65.0]">
        </property>
    </property>
    <property name="minSpacing" class="ptolemy.data.expr.Parameter" value="0.1">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 80.0]">
        </property>
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Server that provides a merge time for each arrival of a merge request over&#10;a web socket.  The accessor Merge.js provides access to this server.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[15.0, -60.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0,0.0,0.2,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="NOTE: It takes 60 seconds&#10;before traffic will create&#10;congestion at the entrance&#10;ramp.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[10.0, 255.0]">
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.2,1.0,1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Run client after running this: LaneMergerClient.xml">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[15.0, 345.0]">
        </property>
        <property name="LiveLink" class="ptolemy.actor.gui.LiveLink" value="LaneMergeClient.xml">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">LL</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{35, 415}">
            </property>
        </property>
    </property>
    <entity name="WaitingTime" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={931, 242, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Waiting Time">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[455.0, 140.0]">
        </property>
    </entity>
    <entity name="FreewayRamp" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="/** Model of a freeway entrance ramp that delays merge requests until&#10; *  it is safe to merge and also provides a roadside service&#10; *  that suggests a ramp speed that will result in smooth joining on the&#10; *  freeway. This model accepts input events at the freewayCar port that&#10; *  represent cars on the freeway approaching the ramp entrance. It also&#10; *  accepts input events at the rampCar port, and in response to those&#10; *  events, provides a suggestedRampSpeed output. These events represent&#10; *  cars approaching the entrance on the ramp. Finally, it accepts&#10; *  events at the merge port, representing cars on the ramp that have&#10; *  arrived at the ramp entrance. In response to these events, it waits&#10; *  until the car can safely enter the freeway, and at that time,&#10; *  produces on the **merged** output the same data received on the **merge**&#10; *  input and produces a mergeTime output indicating the total amount of time&#10; *  that the car had to wait between arriving at the entrance and entering the&#10; *  freeway.&#10; *  &#10; *  This model makes a number of unrealistic simplications. First, the&#10; *  speed of cars on the freeway is fixed and independent of congestion.&#10; *  Second, It assumes that cars on the ramp accelerate instantaneously&#10; *  to the suggested speed and, once reaching the ramp entrace, can&#10; *  accelerate instantaneously to freeway speed.&#10; *  &#10; *  For much better freeway traffic models, see &lt;i&gt;Freeway Traffic Modeling&#10; *  and Control&lt;/i&gt;, by Antonella Ferrara, Simona Sacone, and Silvia Siri,&#10; *  Springer, 2018.&#10; *  &#10; *  @accessor FreewayRamp&#10; *  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *  @parameter {number} sensorDistanceToMerge The distance in kilometers&#10; *   between a car sensor on the freeway and the ramp entrance. This is&#10; *   a number that defaults to 2.0.&#10; *  @parameter {number} freewaySpeed The speed of cars on the freeway in&#10; *   kilometers per hour.&#10; *  @parameter {number} rampLength The distance between the sensor that&#10; *   sees cars at the rampCar position and the freeway entrance (in&#10; *   kilometers). This is a number that defaults to 0.5&#10; *  @parameter {number} maxRampSpeed The maximum speed on the ramp in&#10; *   kilometers per hour. This is a number that defaults to 60.&#10; *  @parameter {number} minSpacing The minimum spacing between cars&#10; *   for a car to safely enter the freeway in kilometers. This is a&#10; *   number that defaults to 0.05.&#10; *   &#10; *  @input freewayCar An event indicating that a car on the freeway &#10; *   is approaching the ramp entrace. At the time of this event, the car&#10; *   is distance sensorDistanceToMerge prior to the merge.&#10; *  @input rampCar An event indicating that a car on the ramp &#10; *   is approaching the ramp entrace. At the time of this event, the car&#10; *   is distance rampLength prior to the merge.&#10; *  @input merge An event indicating that a car on the ramp &#10; *   has arrived at the ramp entrace. At the time of this event, the car&#10; *   is exactly at the merge.&#10; *  &#10; *  @output {number} output The output for the doubled value.&#10; *  @output {number}&#10; */&#10;exports.setup = function() {&#10;	this.parameter('sensorDistanceToMerge', {'type':'number', 'value':2.0});&#10;	this.parameter('freewaySpeed', {'type':'number', 'value':120.0});&#10;	this.parameter('rampLength', {'type':'number', 'value':0.5});&#10;	this.parameter('maxRampSpeed', {'type':'number', 'value':60.0});&#10;	this.parameter('minSpacing', {'type':'number', 'value':0.05});&#10;	&#10;	this.input('freewayCar');&#10;	this.input('rampCar');&#10;	this.input('merge');&#10;	&#10;	this.output('suggestedRampSpeed', {'type':'number'});&#10;	this.output('mergeTime', {'type':'number'});&#10;	this.output('merged');&#10;}&#10;&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;	var blocked = [];&#10;	&#10;	this.addInputHandler('freewayCar', function() {&#10;		var distance = thiz.getParameter('sensorDistanceToMerge');&#10;		var speed = thiz.getParameter('freewaySpeed');&#10;		var minSpacing = thiz.getParameter('minSpacing');&#10;		&#10;		var time = currentTime();&#10;		&#10;		var tmin = time + 3600 * (distance - minSpacing)/speed;&#10;		var tmax = time + 3600 * (distance + minSpacing)/speed;&#10;		blocked.push([tmin, tmax]);&#10;		&#10;		// When car is no longer relevant, remove its blocked interval.&#10;		setTimeout(function() {&#10;			blocked.shift();&#10;		}, 1000 * tmax);&#10;	});&#10;	&#10;	this.addInputHandler('rampCar', function() {&#10;		var time = currentTime();&#10;		var minSpacing = thiz.getParameter('minSpacing');&#10;		var rampLength = thiz.getParameter('rampLength');&#10;		var maxRampSpeed = thiz.getParameter('maxRampSpeed');&#10;		&#10;		var suggestedRampSpeed = maxRampSpeed;&#10;		var arrivalTime = time + 3600 * rampLength / suggestedRampSpeed;&#10;		&#10;		for (var i = 0; i &lt; blocked.length; i++) {&#10;			if (blocked[i][0] &lt; arrivalTime &amp;&amp; blocked[i][1] &gt; arrivalTime) {&#10;				// Ramp will be blocked at current speed.&#10;				suggestedRampSpeed = 3600 * rampLength/(blocked[i][1] - time);&#10;			}&#10;		}&#10;		thiz.send('suggestedRampSpeed', suggestedRampSpeed);&#10;	});&#10;	&#10;	// Queue of cars waiting to enter the freeway. This queue&#10;	// contains the arrival time for each car.&#10;	var waiting = [];&#10;	var cars = [];&#10;	var lastMergeTime = -Infinity;&#10;	&#10;	// Function to enter the freeway. If the freeway is not currently&#10;	// blocked, this function allows a car to enter the freeway and&#10;	// produces a mergeTime output. Otherwise, it continues to wait.&#10;	// If a car is allowed to enter the freeway and there are one or&#10;	// more additional cars waiting, then it waits a safe amount of&#10;	// time before trying to enter again.&#10;	function enter() {&#10;		var arrivalTime = waiting[0];&#10;		var car = cars[0];&#10;		var time = currentTime();&#10;		&#10;		var minSpacing = thiz.getParameter('minSpacing');&#10;		var speed = thiz.getParameter('freewaySpeed');&#10;		var safeWaitingTime = 3600 * minSpacing / speed;&#10;		&#10;		// Check to see whether the most recent merge was too recent&#10;		// (within clock resolution of 1ms).&#10;		var wait = lastMergeTime + safeWaitingTime - time;&#10;		if (wait &gt;= 0.001) {&#10;		    // Last merge was too recent. Wait.&#10;		    setTimeout(enter, 1000 * wait);&#10;		    return;&#10;		}&#10;				&#10;		// Check to see whether the ramp is blocked.&#10;		var timeToWait = 0.0;&#10;		for (var i = 0; i &lt; blocked.length; i++) {&#10;			if (blocked[i][0] &lt; time &amp;&amp; blocked[i][1] &gt; time) {&#10;				// Ramp is blocked.&#10;				timeToWait = blocked[i][1] - time;&#10;			}&#10;		}&#10;		// Timing here has a resolution of ms, so if the timeToWait is&#10;		// small enough that setTimeout() won't result in any delay, then&#10;		// set it to zero.&#10;		if (timeToWait &lt; 0.001) {&#10;			timeToWait = 0.0;&#10;		}&#10;		// console.log('At time ' + time + ', wait for ' + timeToWait);&#10;		if (timeToWait &lt;= 0.0) {&#10;			thiz.send('mergeTime', time - arrivalTime);&#10;			thiz.send('merged', car);&#10;			lastMergeTime = time;&#10;			// Discard the car from the queue.&#10;			waiting.shift();&#10;			cars.shift();&#10;			if (waiting.length &gt; 0) {&#10;				// There are additional cars waiting.&#10;				// Try again after safe waiting time.&#10;				setTimeout(enter, 1000 * safeWaitingTime);&#10;			}&#10;		} else {&#10;			setTimeout(enter, 1000 * timeToWait);&#10;		}&#10;	}&#10;	&#10;	this.addInputHandler('merge', function() {&#10;		var time = currentTime();&#10;		var car = thiz.get('merge');&#10;		waiting.push(time);&#10;		cars.push(car);&#10;		if (waiting.length == 1) {&#10;			// This is the only car waiting, so trigger a wait.&#10;			// Otherwise, assume it will be triggered after the&#10;			// currently waiting car enters the freeway.&#10;			enter();&#10;		}&#10;	});&#10;}&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="$PTII/ptolemy/demo/LaneMerge/FreewayRamp.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[310.0, 140.0]">
        </property>
        <property name="sensorDistanceToMerge" class="ptolemy.data.expr.Parameter" value="sensorDistanceToMerge">
        </property>
        <property name="freewaySpeed" class="ptolemy.data.expr.Parameter" value="freewaySpeed">
        </property>
        <property name="rampLength" class="ptolemy.data.expr.Parameter" value="rampLength">
        </property>
        <property name="maxRampSpeed" class="ptolemy.data.expr.Parameter" value="maxRampSpeed">
        </property>
        <property name="minSpacing" class="ptolemy.data.expr.Parameter" value="minSpacing">
        </property>
        <port name="freewayCar" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="rampCar" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="merge" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="suggestedRampSpeed" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="mergeTime" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="merged" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="SuggestedRampSpeed" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={360, 598, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Suggested Ramp Speed">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[445.0, 35.0]">
        </property>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="6.0">
        </property>
        <doc>Create periodic timed events.</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[65.0, 130.0]">
        </property>
    </entity>
    <entity name="WebSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2016-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  The output `connection` reports when a&#10; *  connection is opened or closed.&#10; *  The output is an object with two fields, a 'socketID',&#10; *  which is a unique ID for this client connection, and a 'status' field,&#10; *  which is the string 'open' or 'closed'.&#10; *&#10; *  When a message arrives on a connection, a `received`&#10; *  output is produced with that message. Note that the message may arrive in&#10; *  multiple frames, but it will be produced on this port as a single message.&#10; *  The output is an object with two fields,&#10; *  a 'socketID', which is a unique ID for this client connection, and a 'message' field,&#10; *  which is the message received from the client.&#10; *&#10; *  When an input arrives on `toSend`, then a message is&#10; *  sent to one or all of the open socket connections.&#10; *  If this is an object with 'socketID' field and a 'message' field,&#10; *  then send the value of the message field to the socket identified&#10; *  by the socketID field. If the input has any other form, then the&#10; *  message is broadcast to all open socket connections.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  server and all connections.&#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The this.send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to this.send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  This accessor requires the module webSocket.&#10; *&#10; *  @accessor net/WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen to for connections.&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true, then this option needs&#10; *   to specify the password for the pfx key-cert file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true, then this option needs to&#10; *   specify the fully qualified filename for the file that stores the private key and certificate&#10; *   that this server will use to identify itself. This path can be any of those understood by the&#10; *   Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {string} receiveType The MIME type for incoming messages,&#10; *    which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages,&#10; *    which defaults to 'application/json'.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @input toSend The data to be sent to open sockets.&#10; *    If this is an object with 'socketID' field and a 'message' field,&#10; *    then send the value of the message field to the socket identified&#10; *    by the socketID field. If the input has any other form, then the&#10; *    message is broadcast to all open socket connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *  @output connection An output produced when a connection opens or closes.&#10; *    The output is an object with two fields, a 'socketID',&#10; *    which is a unique ID for this client connection, and a 'status' field,&#10; *    which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields,&#10; *    a 'socketID', which is a unique ID for this client connection, and a 'message' field,&#10; *    which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;/*jslint plusplus: true */&#10;&#10;var WebSocket = require('@accessors-modules/web-socket-server');&#10;var server = null;&#10;var running = false;&#10;var debug = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function () {&#10;    this.parameter('hostInterface', {&#10;        value: &quot;localhost&quot;,&#10;        type: &quot;string&quot;&#10;    });&#10;    this.parameter('port', {&#10;        value: 8080,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('receiveType', {&#10;        type: 'string',&#10;        value: 'application/json'&#10;    });&#10;    this.parameter('sendType', {&#10;        type: 'string',&#10;        value: 'application/json'&#10;    });&#10;    this.parameter('sslTls', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.input('toSend');&#10;    this.output('received', {&#10;        'spontaneous': true        &#10;    });&#10;    this.output('listening', {&#10;        'type': 'int',&#10;        'spontaneous': true&#10;    });&#10;    this.output('connection', {&#10;        'spontaneous': true&#10;    });&#10;&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options: WebSocket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options: WebSocket.supportedSendTypes()&#10;        });&#10;    } catch (err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;//var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs.&#10; * Adds an input handler on toSend that sends the input received to the right socket. */&#10;exports.initialize = function () {&#10;    var self = this;&#10;    self.sockets = [];&#10;&#10;    if (!server) {&#10;        server = new WebSocket.Server({&#10;            'port': this.getParameter('port'),&#10;            'hostInterface': this.getParameter('hostInterface'),&#10;            'pfxKeyCertPassword': this.getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath': this.getParameter('pfxKeyCertPath'),&#10;            'receiveType': this.getParameter('receiveType'),&#10;            'sendType': this.getParameter('sendType'),&#10;            'sslTls': this.getParameter('sslTls')&#10;        });&#10;        // Using 'this.exports' rather than just 'exports' in the following allows&#10;        // these functions to be overridden in derived accessors.&#10;        server.on('listening', this.exports.onListening.bind(this));&#10;        server.on('connection', this.exports.onConnection.bind(this));&#10;        server.on('error', function (message) {&#10;            self.error(message);&#10;        });&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    this.addInputHandler('toSend', function () {&#10;        var data = self.get('toSend'),&#10;            id;&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;&#10;            // JSHint WARNING: Do not change dataSocketID != null to&#10;            // data.socketID !== null because it will cause&#10;            // org/terraswarm/accessor/test/auto/WebSocketClient.xml&#10;            // to fail upon reloading.  See&#10;            // org/terraswarm/accessor/test/WebSocketClientTest.tcl&#10;            if ((data.socketID != null) &amp;&amp; (data.message !== null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (self.sockets[data.socketID] &amp;&amp; self.sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    /*&#10;                      console.log(self.accessorName + ': WebSocketServer: Sending to socket id ' +&#10;                      data.socketID +&#10;                      &quot; message: &quot; +&#10;                      data.message);&#10;                    */&#10;                    self.sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log(self.accessorName + ': WebSocketServer.js: Socket with ID ' + data.socketID +&#10;                        ' is not open. Discarding message.');&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                // var success = false;&#10;                for (id = 0; id &lt; self.sockets.length; id += 1) {&#10;                    if (self.sockets[id].isOpen()) {&#10;                        // console.log(self.accessorName + 'WebSocketServer.js: Broadcasting to socket id ' + id&#10;                        //         + ' message: ' + data);&#10;                        self.sockets[id].send(data);&#10;                        // success = true;&#10;                    }&#10;                }&#10;                // if (!success) {&#10;                //     console.log(self.accessorName + 'WebSocketServer.js: No open sockets. Discarding message: ' + data.message);&#10;                // }&#10;            }&#10;        }&#10;    });&#10;};&#10;&#10;exports.onListening = function () {&#10;    if (debug) {&#10;        console.log(this.accessorName + 'WebSocketServer.js: Listening for socket connection requests.');&#10;    }&#10;    this.send('listening', this.getParameter('port'));&#10;};&#10;&#10;/** Executes when a connection has been established.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;exports.onConnection = function (socket) {&#10;    // socketID is the index of the socket in the sockets array.&#10;    var self = this,&#10;        socketID = self.sockets.length;&#10;    if (debug) {&#10;        console.log(this.accessorName + 'WebSocketServer.js: new socket established with ID: ' + socketID);&#10;    }&#10;    this.send('connection', {&#10;        'socketID': socketID,&#10;        'status': 'open'&#10;    });&#10;&#10;    self.sockets.push(socket);&#10;&#10;    self.sockets[socketID].on('message', function (message) {&#10;        console.log('WebSocketServer message(): ' + message + ', typeof message: ' + typeof message);&#10;        // For some reason, under the Node Host, the message is an&#10;        // object.  Under CapeCode, it is a string?&#10;        var isObjectWithQuotes = (typeof message === 'object' &amp;&amp; message.toString().startsWith('&quot;') &amp;&amp; message.toString().endsWith('&quot;'));&#10;        // If message is a string, strip leading and trailing &quot;&#10;        if (typeof message === 'string' || isObjectWithQuotes) {&#10;            if (isObjectWithQuotes) {&#10;                message = message.toString();&#10;            }&#10;            message = message.replace(/^&quot;(.*)&quot;$/, '$1');&#10;        }&#10;        self.send('received', {&#10;            'message': message,&#10;            'socketID': socketID&#10;        });&#10;    });&#10;    self.sockets[socketID].on('close', function () {&#10;        self.send('connection', {&#10;            'socketID': socketID,&#10;            'status': 'closed'&#10;        });&#10;    });&#10;    self.sockets[socketID].on('error', function (message) {&#10;        console.log(self.accessorName + ': WebSocketServer.js: error ' + message);&#10;        self.error(message);&#10;    });&#10;&#10;&#10;};&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server.&#10; */&#10;exports.wrapup = function () {&#10;    this.sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.stop();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/WebSocketServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor starts a server that listens for web socket&#10; connection requests on the specified hostInterface and port.  The&#10; hostInterface is needed only if the host machine has more than one&#10; network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; not resolve to the desired interface.&lt;/p&gt;&#10;&lt;p&gt; The output &lt;code&gt;connection&lt;/code&gt; reports when a&#10; connection is opened or closed.&#10; The output is an object with two fields, a 'socketID',&#10; which is a unique ID for this client connection, and a 'status' field,&#10; which is the string 'open' or 'closed'.&lt;/p&gt;&#10;&lt;p&gt; When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; output is produced with that message. Note that the message may arrive in&#10; multiple frames, but it will be produced on this port as a single message.&#10; The output is an object with two fields,&#10; a 'socketID', which is a unique ID for this client connection, and a 'message' field,&#10; which is the message received from the client.&lt;/p&gt;&#10;&lt;p&gt; When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; sent to one or all of the open socket connections.&#10; If this is an object with 'socketID' field and a 'message' field,&#10; then send the value of the message field to the socket identified&#10; by the socketID field. If the input has any other form, then the&#10; message is broadcast to all open socket connections.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; server and all connections.&lt;/p&gt;&#10;&lt;p&gt; The default type for both sending and receiving&#10; is 'application/json', which allows sending and receiving anything that has&#10; a string representation in JSON. The types supported by this implementation&#10; include at least:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;application/json&lt;/strong&gt;: The this.send() function uses JSON.stringify() and sends the&#10;result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10;and if the parsing fails, will be provided as a string interpretation of the byte&#10;stream.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;text/*&lt;/strong&gt;: Any text type is sent as a string encoded in UTF-8.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;image/x&lt;/strong&gt;: Where &lt;strong&gt;x&lt;/strong&gt; is one of &lt;strong&gt;json&lt;/strong&gt;, &lt;strong&gt;png&lt;/strong&gt;, &lt;strong&gt;gif&lt;/strong&gt;,&#10;and more.&#10;In this case, the data passed to this.send() is assumed to be an image, as encoded&#10;on the host, and the image will be encoded as a byte stream in the specified&#10;format before sending.  A received byte stream will be decoded as an image,&#10;if possible.&lt;/p&gt;&#10;&lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Edward Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent to open sockets.&#10;   If this is an object with 'socketID' field and a 'message' field,&#10;   then send the value of the message field to the socket identified&#10;   by the socketID field. If the input has any other form, then the&#10;   message is broadcast to all open socket connections.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="An output produced when a connection opens or closes.&#10;   The output is an object with two fields, a 'socketID',&#10;   which is a unique ID for this client connection, and a 'status' field,&#10;   which is the string 'open' or 'closed'.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="A message received a client in the form of an object with two fields,&#10;   a 'socketID', which is a unique ID for this client connection, and a 'message' field,&#10;   which is the message received from the client.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of the&#10;   network interface to listen to.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to listen to for connections.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option needs&#10;  to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option needs to&#10;  specify the fully qualified filename for the file that stores the private key and certificate&#10;  that this server will use to identify itself. This path can be any of those understood by the&#10;  Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for incoming messages,&#10;   which defaults to 'application/json'.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for outgoing messages,&#10;   which defaults to 'application/json'.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[315.0, 225.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Received" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={933, 451, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Received">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[310.0, 315.0]">
        </property>
    </entity>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[225.0, 215.0]">
        </vertex>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[400.0, 225.0]">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="WaitingTime.input" relation="relation3"/>
    <link port="FreewayRamp.freewayCar" relation="relation7"/>
    <link port="FreewayRamp.merge" relation="relation2"/>
    <link port="FreewayRamp.suggestedRampSpeed" relation="relation5"/>
    <link port="FreewayRamp.mergeTime" relation="relation3"/>
    <link port="FreewayRamp.merged" relation="relation"/>
    <link port="SuggestedRampSpeed.input" relation="relation5"/>
    <link port="DiscreteClock.output" relation="relation7"/>
    <link port="WebSocketServer.toSend" relation="relation"/>
    <link port="WebSocketServer.received" relation="relation2"/>
    <link port="Received.input" relation="relation2"/>
</entity>
