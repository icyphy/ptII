/* Lexical analyzer for Java, $Id$ */

/* Authors: Paul N. Hilfinger, Jeff Tsay */
/* Copyright (C) 1995, 1997 by Paul N. Hilfinger.  All rights reserved.	*/

package ptolemy.lang.java;

import ptolemy.lang.*;

%%

%integer
%full
%line
%notunix

%{
  public int lineNumber() { return yyline + 1; }

  public parserval getParserVal() { return retval; }

  protected parserval retval = new parserval(0);
%}

HEX=[0-9A-Fa-f]
DEC=[0-9]
OCT=[0-7]

Letter=[a-zA-Z_]
AlphaNum=({Letter}|{DEC})

UnicodeChar=(\\u+{HEX}{HEX}{HEX}{HEX})
LiteralChar=(\\([btnfr\"'\\]|{OCT}{OCT}?|[0-3]{OCT}{OCT})|[^'\"\n]|{UnicodeChar})

C_StyleComment=("/*"([^*]|"*"+[^*/])*"*"+"/")
CPlusPlusStyleComment=("//".*[\n\r])

%%

[ \f\t\r\n]+           { }

{C_StyleComment} { }
{CPlusPlusStyleComment}	{ }

"abstract"	    {  return parser.ABSTRACT; }
"boolean"	    {  return parser.BOOLEAN; }
"break"	      {  return parser.BREAK; }
"byte"	        {  return parser.BYTE; }
"case"	        {  return parser.CASE; }
"catch"	      {  return parser.CATCH; }
"char"	        {  return parser.CHAR; }
"class"	      {  return parser.CLASS; }
"continue"	    {  return parser.CONTINUE; }
"default"	    {  return parser.DEFAULT; }
"do"		        {  return parser.DO; }
"double"	      {  return parser.DOUBLE; }
"else"	        {  return parser.ELSE; }
"extends"	    {  return parser.EXTENDS; }
"final"	      {  return parser.FINAL; }
"finally"	    {  return parser.FINALLY; }
"float"	      {  return parser.FLOAT; }
"for"		      {  return parser.FOR; }
"if"		        {  return parser.IF; }
"implements"	  {  return parser.IMPLEMENTS; }
"import"	      {  return parser.IMPORT; }
"instanceof"	  {  return parser.INSTANCEOF; }
"int"		      {  return parser.INT; }
"interface"	  {  return parser.INTERFACE; }
"long"	        {  return parser.LONG; }
"native"	      {  return parser.NATIVE; }
"new"		      {  return parser.NEW; }
"null"	        {  return parser._NULL; }
"package"	    {  return parser.PACKAGE; }
"private"	    {  return parser.PRIVATE; }
"protected"	  {  return parser.PROTECTED; }
"public"	      {  return parser.PUBLIC; }
"return"	      {  return parser.RETURN; }
"short"	      {  return parser.SHORT; }
"static"	      {  return parser.STATIC; }
"super"	      {  return parser.SUPER; }
"switch"	      {  return parser.SWITCH; }
"synchronized"	{  return parser.SYNCHRONIZED; }
"this"	        {  return parser.THIS; }
"throw"	      {  return parser.THROW; }
"throws"	      {  return parser.THROWS; }
"transient"	  {  return parser.TRANSIENT; }
"try"		      {  return parser.TRY; }
"void"	        {  return parser.VOID; }
"volatile"     {  return parser.VOLATILE; }
"while"        {  return parser.WHILE; }
"strictfp"     {  return parser.STRICTFP; }

"const"|"goto"	{ ApplicationUtility.error("reserved keyword " +
                  yytext() + " ignored"); }

"true"	 {  return parser.TRUE; }
"false" {  return parser.FALSE; }

{Letter}{AlphaNum}* {
           
     retval = new parserval(0);
     retval.sval = yytext();
		  return parser.IDENTIFIER;
		}

[1-9]{DEC}*	{
      
     retval = new parserval(0);
     retval.sval = yytext();
		  return parser.INT_LITERAL;
		}

0{OCT}*	{
      
     retval = new parserval(0);
     retval.sval = yytext();
		  return parser.INT_LITERAL;
		}

0[xX]{HEX}+	{
      
     retval = new parserval(0);
     retval.sval = yytext();
		  return parser.INT_LITERAL;
		}

[1-9]{DEC}*[lL]	{
      
     retval = new parserval(0);
     String s = yytext();
     retval.sval = s.substring(0, s.length() - 1);
		  return parser.LONG_LITERAL;
		}

0{OCT}*[lL]	{
      
     retval = new parserval(0);
     String s = yytext();
     retval.sval = s.substring(0, s.length() - 1);
		  return parser.LONG_LITERAL;
		}

0[xX]{HEX}+[lL]	{
      
     retval = new parserval(0);
     String s = yytext();
     retval.sval = s.substring(0, s.length() - 1);
		  return parser.LONG_LITERAL;
		}

{DEC}+"."{DEC}*([eE][-+]?{DEC}+)?[dD]?|"."{DEC}+([eE][-+]?{DEC}+)?[dD]?|{DEC}+([eE][-+]?{DEC}+)[dD]?|{DEC}+[dD]
   {
      
     retval = new parserval(0);
		  retval.sval = yytext();
		  return parser.DOUBLE_LITERAL;
		}

{DEC}+"."{DEC}*([eE][-+]?{DEC}+)?[fF]|"."{DEC}+([eE][-+]?{DEC}+)?[fF]|{DEC}+([eE][-+]?{DEC}+)[fF]|{DEC}+[fF]
   {
       
     retval = new parserval(0);
		  retval.sval = yytext();
		  return parser.FLOAT_LITERAL;
		}

'({LiteralChar}|\")'	{
      
     retval = new parserval(0);
     String s = yytext();
     retval.sval = s.substring(1, s.length() - 1);
		  return parser.CHARACTER_LITERAL;
		}

\"({LiteralChar}|"'")*\" {
      
     retval = new parserval(0);
     String s = yytext();
     retval.sval = s.substring(1, s.length() - 1);
		  return parser.STRING_LITERAL;
		}

["(){}];,."]	{  return yytext().charAt(0); }

"["([ \t\n]|{C_StyleComment}|{CPlusPlusStyleComment})*"]"?  {
      
     String s = yytext();

		  if (s.charAt(s.length() - 1) == ']') {
   		  return parser.EMPTY_DIM;
		  } else {
		      return yytext().charAt(0);
     }
		}

["-=><!~?:+*/&|^%"]   {  return yytext().charAt(0); }

"&&"		{  return parser.CAND; }
"||"		{  return parser.COR; }
"=="		{  return parser.EQ; }
"!="		{  return parser.NE; }
"<="		{  return parser.LE; }
">="		{  return parser.GE; }
"<<"		{  return parser.LSHIFTL; }
">>"		{  return parser.ASHIFTR; }
">>>"	{  return parser.LSHIFTR; }
"+="		{  return parser.PLUS_ASG; }
"-="		{  return parser.MINUS_ASG; }
"*="		{  return parser.MULT_ASG; }
"/="		{  return parser.DIV_ASG; }
"%="		{  return parser.REM_ASG; }
"<<="	{  return parser.LSHIFTL_ASG; }
">>="	{  return parser.ASHIFTR_ASG; }
">>>="	{  return parser.LSHIFTR_ASG; }
"&="		{  return parser.AND_ASG; }
"^="		{  return parser.XOR_ASG; }
"|="		{  return parser.OR_ASG; }
"++"		{  return parser.PLUSPLUS; }
"--"		{  return parser.MINUSMINUS; }

.	{
      ApplicationUtility.error("Lexical error : Line " + (1 + yyline) +
"Unmatched input : " + yytext());
		}

