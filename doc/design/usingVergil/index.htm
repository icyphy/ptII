<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="Quadralay WebWorks Publisher Standard Edition 6.0.2">
<meta name="TEMPLATEBASE" content="Portable HTML Standard Edition">
<meta name="LASTUPDATED" content="02/20/02 13:55:04">
<title>usingVergil.html</title>
</head>

<body link="#3366CC" vlink="#9999CC" text="#000000" alink="#0000CC" bgcolor="#FFFFFF"
background="images/backgrnd.gif">

<hr align="bottom">

<blockquote>
<div align="center">
<h1><a name="158262"> </a>Using Vergil<br></h1>
</div>

This version is in HTML, a <a href="usingVergil.pdf">PDF version</a>
is also available.
<p><p>
<a name="162678"> </a>Authors:		Edward A. Lee<br>


<a name="169035"> </a>		Steve Neuendorffer<br>



<h2><a name="164801"> </a>2.1   Introduction<br></h2>


<a name="167666"> </a>There are many ways to use Ptolemy II. It can be used as a framework for assembling software components, as a modeling and simulation tool, as a block-diagram editor, as a system-level rapid prototyping application, as a toolkit supporting research in component-based design, or as a toolkit for building Java applications. This chapter introduces its use as a modeling and simulation tool.<br>


<p>
  <a name="167754"> </a>In this chapter, we describe how to graphically construct models using Vergil, a graphical user interface (GUI) for Ptolemy II. figure <p><img src="images/usingVergil5.gif" height="470" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#167754">2.1</a> shows a simple Ptolemy II model in Vergil, showing the graph editor, one of several editors available in Vergil. Keep in mind as you read this document that graphical entry of models is only one of several possible entry mechanisms available in Ptolemy II. Moreover, only some of the execution engines (called <i>domains</i>) are represented here. A major emphasis of Ptolemy II is to provide a framework for the construction of modeling and design tools, so the specific modeling and design tools described here should be viewed as representative of our efforts.
</p>


<h2><a name="165833"> </a>2.2   Quick Start<br></h2>


<p>
  <a name="165834"> </a>The traditional first programming example is one that prints "Hello World." Why break tradition?
</p>


<h3><a name="169820"> </a>2.2.1   Starting Vergil<br></h3>


<p>
  <a name="165846"> </a>First start Vergil. From the command line, enter "vergil", or select Vergil or Ptolemy II in the Start menu, or click on a Web Start link on a web page supporting the web edition. You should see an initial welcome window that looks like the one in figure <p><img src="images/usingVergil26.gif" height="294" width="599" align="bottom" border="0" hspace="0" vspace="12"><p>
<a href="usingVergil.html#165846">2.2</a>. Feel free to explore the links in this window. Most useful is probably the "Quick tour" link.
</p>


<h3><a name="166445"> </a>2.2.2   Creating a New Model<br></h3>


<p>
  <a name="169824"> </a>Create a new graph editor from the File-&gt;New menu in the welcome window. You should see something like the window shown in figure <p><img src="images/usingVergila.gif" height="421" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#169824">2.3</a>. Ignoring the menus and toolbar for a moment, on the left is a palette of objects that can be dragged onto the page on the right. To begin with, the page on the right is blank. Open the <i>actor library</i> in the palette, and go into the <i>sources</i> library. Find the <i>Const</i> actor and drag an instance over onto the blank page. Then go into the <i>sinks </i>library and drag a <i>Display</i> actor onto the page. Each of these actors can be dragged around on the page. However, we would like to connect one to the other. To do this, drag a connection from the output port on the right of the <i>Const </i>actor to the input port of the <i>Display</i> actor. Lastly, open the <i>director library</i> and drag an <i>SDFDirector</i> onto the page. The director gives an execution meaning to the graph, but for now we don't have to be concerned about exactly what that is.
</p>


<p>
  <a name="165895"> </a>Now you should have something that looks like figure <p><img src="images/usingVergil3.gif" height="421" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#165895">2.4</a>. The <i>Const</i> actor is going to create our string, and the <i>Display</i> actor is going to print it out for us. We need to take care of one small detail to make it look like figure <a href="usingVergil.html#165895">2.4</a>: we need to tell the <i>Const</i> actor that we want the string "Hello World". To do this we need to edit one of the parameters of the <i>Const</i>. To do this, either double click on the <i>Const</i> actor icon, or right click on the <i>Const</i> actor icon and select "Configure". You should see the dialog box in figure <p><img src="images/usingVergil9.gif" height="137" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#165895">2.5</a>. Enter the string "Hello World" for the value parameter and click the Commit button. Be sure to include the double quotes, so that the expression is interpreted as a string.
</p>


<p>
  <a name="169832"> </a>You may wish to save your model, using the File menu. Note that because of a bug, you will need to explicitly add ".xml" to the end of the filename so that Vergil will properly process the file the next time you open that file.
</p>


<h3><a name="169828"> </a>2.2.3   Running the Model<br></h3>


<p>
  <a name="166518"> </a>To run the example, go to the View menu and select the Run Window. If you click the "Go" button, you will see a large number of strings in the display at the right. To stop the execution, click the "Stop" button. To see only one string, change the <i>iterations</i> parameter of the SDF Director to 1, which can be done in the run window, or in the graph editor in the same way you edited the parameter of the <i>Const</i> actor before. The run window is shown in figure <p><img src="images/usingVergil13.gif" height="239" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#166518">2.6</a>.
</p>


<h3><a name="169795"> </a>2.2.4   Making Connections<br></h3>


<a name="169838"> </a>The model constructed above contained only two actors and one connection between them. If you move either actor (by clicking and dragging), you will see that the connection is routed automatically (although not particularly intelligently). We can now explore how to create and manipulate more complicated connections.<br>


<p>
  <a name="169954"> </a>First create a model in a new graph editor that includes an <i>SDFDirector</i>, a <i>Ramp</i> actor (found in the <i>sources</i>) library, a <i>Display </i>actor, and a <i>SequencePlotter</i> actor, found in the <i>sinks</i> library, as shown in figure <p><img src="images/usingVergil23.gif" usemap="#usingVergil23_gif" height="169" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil23_gif">

<area href="usingVergil.html#169954" shape=rect coords="3,136,597,162">
</map>
<a href="usingVergil.html#169954">2.7</a>. Suppose we wish to route the output of the <i>Ramp</i> to both the <i>Display</i> and the <i>SequencePlotter</i>. If we simply attempt to make the connections, we get the exception shown in figure <p><img src="images/usingVergil37.gif" height="201" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#169954">2.7</a>. Don't panic! Exceptions are normal and common. The key line in this exception report is the last one, which says
</p>


<a name="169899"> </a><br>


<a name="169903"> </a>Attempt to link more than one relation to a single port.<br>


<a name="169908"> </a><br>


<a name="169909"> </a>The line above that gives the names of the objects involved, which are <br>


<a name="169915"> </a><br>


<a name="169919"> </a>.&lt;Unnamed Object&gt;.Ramp.output and .&lt;Unnamed Object&gt;.relation3<br>


<a name="169931"> </a><br>


<a name="169932"> </a>In Ptolemy II models, all objects have a dotted name. The dots separate elements in the hierarchy. Thus, ".&lt;Unnamed Object&gt;.Ramp.output" is an object named "output" contained by an object named "Ramp", which is contained by an unnamed object (the model itself). The model has no name because we have not assigned one (it acquires a name when we save it).<br>


<p>
  <a name="169979"> </a>Why did this exception occur? Ptolemy II supports two distinct flavors of ports, indicated in the diagrams by a filled triangle or an unfilled triangle. The output port of the <i>Ramp</i> actor is a <i>single port</i>, indicated by a filled triangle, which means that it can only support a single connection. The input port of the <i>Display</i> and <i>SequencePlotter</i> actors are <i>multiports</i>, indicated by unfilled triangles, which means that they can support multiple connections. Each connection is treated as a separate <i>channel</i>, which is aA path from an output port to an input port (via relations) that can transport a single stream of tokens. path from an output port to an input port (via relations) that can transport a single stream of tokens.
</p>


<p>
  <a name="169983"> </a>So how do we get the output of the <i>Ramp</i> to the other two actors? We need an explicit <i>relation</i> in the diagram. A relation is represented in the diagram by a black diamond, as shown in figure <p><img src="images/usingVergil2.gif" height="257" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#169983">2.9</a>. It can be created by either control-clicking on the background or by clicking on the button in the toolbar with the black diamond on it.
</p>


<p>
  <a name="170018"> </a>Making a connection to a relation can be tricky, since if you just click and drag on the relation, the relation gets selected and moved. To make a connection, hold the control button while clicking and dragging on the relation.
</p>


<p>
  <a name="170023"> </a>In the model shown in figure <a href="usingVergil.html#169983">2.9</a>, the relation is used to broadcast the output from a single port to a number of places. The single port still has only one connection to it, a connection to a relation. Relations can also be used to control the routing of wires in the diagram. However, as of the 2.0 release of Ptolemy II, a connection can only have a single relation on it, so the degree to which routing can be controlled is limited.
</p>


<p>
  <a name="170038"> </a>To explore multiports, try putting some other signal source in the diagram and connecting it to the <i>SequencePlotter</i> or to the <i>Display</i>. If you explore this fully, you will discover that the <i>SequencePlotter</i> can only accept inputs of type <i>double</i>, or some type that can be losslessly converted to <i>double</i>, such as <i>int.</i> These data type issues are explored next.
</p>


<h2><a name="167800"> </a>2.3   Tokens and Data Types<br></h2>


<p>
  <a name="167804"> </a>In the example of figure <a href="usingVergil.html#165895">2.4</a>, the <i>Const</i> actor creates a sequence of values on its output port. The values are encapsulated as <i>tokens</i>, and sent to the <i>Display</i> actor, which consumes them and displays them in the run window.
</p>


<p>
  <a name="167859"> </a>The tokens produced by the <i>Const</i> actor can have any value that can be expressed in the Ptolemy II <i>expression language</i>. We will say more about the expression language, but for now, try giving the value 1 (the integer with value one), or 1.0 (the floating-point number with value one), or {1.0} (An array containing a one), or {value=1, name="one"} (A record with two elements: an integer named "value" and a string named "name"), or even [1,0;0,1] (the two-by-two identity matrix). These are all expressions.
</p>


<p>
  <a name="168187"> </a>The <i>Const</i> actor is able to produce data with different <i>types</i>, and the <i>Display</i> actor is able to display data with different types. Most actors in the actor library are <i>polymorphic</i>, meaning that they can operate on or produce data with multiple types. The behavior may even be different for different types. Multiplying matrices, for example, is not the same as multiplying integers, but both are accomplished by the <i>MultiplyDivide </i>actor in the <i>math library</i>. Ptolemy II includes a sophisticated type system that allows this to be done efficiently and safely.
</p>


<p>
  <a name="168209"> </a>To explore data types a bit further, try creating the model in figure<p><img src="images/usingVergil7.gif" height="241" width="600" align="center" border="0" hspace="0" vspace="0"><p>
 <a href="usingVergil.html#168209">2.10</a>. The <i>Ramp</i> actor is listed under <i>sources</i> and the <i>AddSubtract</i> actor is listed under <i>math</i>. Set the <i>value</i> parameter of the constant to be 0 and the <i>iterations</i> parameter of the director to 5. Running the model should result in 5 numbers between 0 and 4, as shown in the figure. These are the values produced by the <i>Ramp</i>, which are having the value of the <i>Const</i> actor subtracted from them. Experiment with changing the value of the <i>Const</i> actor and see how it changes the 5 numbers at the output.
</p>


<p>
  <a name="168231"> </a>Now for the real test: change the value of the <i>Const</i> actor back to "Hello World". When you execute the model, you should see an exception window, as shown in figure <p><img src="images/usingVergil53.gif" height="265" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168231">2.11</a>. Do not worry; exceptions are a normal part of constructing (and debugging) models. In this case, the exception window is telling you that you have tried to subtract a string value from an integer value, which doesn't make much sense at all (following Java, adding strings <i>is</i> allowed). This is an example of a type error.
</p>


<p>
  <a name="168136"> </a>Exceptions can be a very useful debugging tool, particularly if you are developing your own components in Java. To illustrate how to use them, click on the Display Stack Trace button in the exception window of figure <a href="usingVergil.html#168231">2.11</a>. You should see the stack trace shown in figure <p><img src="images/usingVergil11.gif" usemap="#usingVergil11_gif" height="354" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil11_gif">

<area href="usingVergil.html#168231" shape=rect coords="3,322,597,348">
</map>
<a href="usingVergil.html#168136">2.12</a>. This window displays the execution sequence that resulted in the exception. For example, the line
</p>


<a name="168266"> </a><br>


<a name="168270"> </a>at ptolemy.data.IntToken.subtract(IntToken.java:547)<br>


<a name="168275"> </a><br>


<a name="168276"> </a>indicates that the exception occurred within the subtract() method of the class ptolemy.data.IntToken, at line 547 of the source file IntToken.java. Since Ptolemy II is distributed with source code (except in the Web Edition), this can be very useful information. For type errors, you probably do not need to see the stack trace, but if you have extended the system with your own Java code, or you encounter a subtle error that you do not understand, then looking at the stack trace can be very illuminating.<br>


<p>
  <a name="168405"> </a>To find the file IntToken.java referred to above, find the Ptolemy II installation directory. If that directory is $PTII, then the location of this file is given by the full class name, but with the periods replaced by slashes; in this case, it is at $PTII/ptolemy/data/IntToken.java (the slashes might be backslashes under Windows).
</p>


<p>
  <a name="168116"> </a>Let's try a small change to the model to get something that does not trigger an exception. Disconnect the <i>Const</i> from the lower port of the <i>AddSubtract</i> actor and connect it instead to the upper port, as shown in figure <p><img src="images/usingVergil15.gif" height="245" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168116">2.13</a>. You can do this by selecting the connection and deleting it (using the delete key), then adding a new connection, or by selecting it and dragging one of its endpoints to the new location. Notice that the upper port is an unfilled triangle; this indicates that it is a <i>multiport</i>, meaning that you can make more than one connection to it. Now when you run the model you should see strings like "0HelloWorld", as shown in the figure.
</p>


<p>
  <a name="166645"> </a>There are two interesting things going on here. The first is that, as in Java, strings are added by concatenating them. The second is that the integers from the <i>Ramp</i> are converted to strings and concatenated with the string "Hello World". All the connections to a multiport must have the same type. In this case, the multiport has a sequence of integers coming in (from the <i>Ramp</i>) and a sequence of strings (from the <i>Const</i>).
</p>


<p>
  <a name="168385"> </a>Ptolemy II automatically converts the integers to strings when integers are provided to an actor that requires strings. But in this case, why does the <i>AddSubtract</i> actor require strings? Because it would not work to require integers; the string "Hello World" would have to be converted to an integer. As a rough guideline, Ptolemy II will perform automatic type conversions when there is no loss of information. An integer can be converted to a string, but not vice versa. An integer can be converted to a double, but not vice versa. An integer can be converted to a long, but not vice versa. The details are explained in the Data chapter, but many users will not need to understand the full sophistication of the system. You should find that most of the time it will just do what you expect.
</p>


<p>
  <a name="168409"> </a>To further explore data types, try modifying the <i>Ramp</i> so that its parameters have different types. For example, try making <i>init</i> and <i>step</i> strings.
</p>


<h2><a name="166138"> </a>2.4   Hierarchy<br></h2>


<p>
  <a name="170409"> </a>Ptolemy II supports (and encourages) hierarchical models. These are models that contain components that are themselves models. Such components are called <i>composite actors</i>. Consider a small signal processing problem, where we are interested in recovering a signal based only on noisy measurements of it. We will create a composite actor modeling a communication channel that adds noise, and then use that actor in a model.
</p>


<h3><a name="170413"> </a>2.4.1   Creating a Composite Actor<br></h3>


<p>
  <a name="170457"> </a>First open a new graph editor and drag in a <i>Typed Composite Actor</i> from the <i>utilities</i> library. This actor is going to add noise to our measurements. First, using the context menu (obtained by right clicking over the composite actor), select "Customize Name", and give the composite a better name, like "Channel", as shown in figure <p><img src="images/usingVergil55.gif" height="245" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170457">2.14</a>. Then, using the context menu again, select "Look Inside" on the actor. You should get a blank graph editor, as shown in figure <p><img src="images/usingVergil58.gif" height="324" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170457">2.15</a>. The original graph editor is still open. To see it, move the new graph editor window by dragging the title bar of the window.
</p>


<h3><a name="170461"> </a>2.4.2   Adding Ports to a Composite Actor<br></h3>


<p>
  <a name="166651"> </a>First we have to add some ports to the composite actor. There are several ways to do this, but clicking on the port buttons in the toolbar is probably the easiest. You can explore the ports in the toolbar by lingering with the mouse over each button in the toolbar. A tooltip pops up that explains the button. The buttons are summarized in figure <p><img src="images/usingVergil57.gif" height="217" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#166651">2.16</a>. Create an input port and an output port and rename them <i>input</i> and <i>output </i>right clicking on the ports and selecting "Customize Name". Note that, as shown in figure <p><img src="images/usingVergil59.gif" height="217" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#166651">2.17</a>, you can also right click on the background of the composite actor and select <i>Configure Ports</i> to change whether a port is an input, an output, or a multiport. The resulting dialog also allows you to set the type of the port, although much of the time you will not need to do this, since the type inference mechanism in Ptolemy II will figure it out from the connections.
</p>


<p>
  <a name="168725"> </a>Then using these ports, create the diagram shown in figure <p><img src="images/usingVergil60.gif" height="174" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168725">2.18</a><a href="#166915"><sup>1</sup></a>. The <i>Gaussian</i> actor creates values from a Gaussian distributed random variable, and is found in the <i>random</i> library. Now if you close this editor and return to the previous one, you should be able to easily create the model shown in figure <p><img src="images/usingVergil17.gif" height="164" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168725">2.19</a>. The <i>Sinewave</i> actor is listed under <i>sources</i>, and the <i>SequencePlotter</i> actor is found in <i>sinks</i>. Notice that the <i>Sinewave</i> actor is also a hierarchical model, as suggested by its red outline (try looking inside). If you execute this model (you will probably want to set the iterations to something reasonable, like 100), you should see something like figure <p><img src="images/usingVergil20.gif" usemap="#usingVergil20_gif" height="302" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil20_gif">

<area href="usingVergil.html#168725" shape=rect coords="3,269,597,296">
</map>
<a href="usingVergil.html#168725">2.20</a>.
</p>


<h3><a name="170343"> </a>2.4.3   Setting the Types of Ports<br></h3>


<a name="170465"> </a>In the above example, we never needed to define the types of any ports. The types were inferred from the connections. Indeed, this is usually the case in Ptolemy II, but occasionally, you will need to set the types of the ports. Notice in figure <a href="usingVergil.html#166651">2.17</a> that there is a position in the dialog box that configures ports for specifying the type. The natural question you might have is "how do I specify the type?"<br>


<p>
  <a name="170473"> </a>The answer to this question seems too obvious: you specify a <i>prototype</i>, an expression that has the type that you want to specify. Thus, to specify that a port has type <i>boolean</i>, you could enter into the dialog of figure <a href="usingVergil.html#166651">2.17</a> the value "true" or "false". This, however, might not be too clear. For this reason, Ptolemy II has a built-in constant named "boolean" that happens to have value "true". Thus, if you specify that the type is "<i>boolean</i>", then, well, you have specified that the type is boolean.
</p>


<p>
  <a name="170481"> </a>There are several other constants that similarly can be used to specify types. They are <i>complex</i>, <i>double</i>, <i>fixedpoint</i>, <i>general</i>, <i>int</i>, <i>long</i>, <i>matrix</i>, <i>object</i>, <i>scalar</i>, <i>string</i>, and <i>unknown</i>. So how would you specify that the type of a port is a double matrix? Easy:
</p>


<a name="170539"> </a><br>


<a name="170543"> </a>[double]<br>


<a name="170544"> </a><br>


<a name="170545"> </a>This expression actually creates a 1 by 1 matrix containing a double (the value of which is irrelevant). It thus serves as a prototype to specify a double matrix type. Similarly, we can specify an array of complex numbers as<br>


<a name="170549"> </a><br>


<a name="170553"> </a>{complex}<br>


<a name="170554"> </a><br>


<a name="170555"> </a>In the Ptolemy II expression language, square braces are used for matrices, and curly braces are used for arrays. What about a record containing a string named "name" and an integer named "address"? Easy:<br>


<a name="170561"> </a><br>


<a name="170565"> </a>{name=string, address=int}<br>


<a name="170566"> </a><br>


<h2><a name="168727"> </a>2.5   Annotations and Parameterization<br></h2>


<a name="168830"> </a>In this section, we will enhance the model in figure <a href="usingVergil.html#168725">2.19</a> in a number of ways.<br>


<p>
  <a name="168893"> </a>First, notice from figure <a href="usingVergil.html#168725">2.20</a> that the noise overwhelms the sinusoid, making it barely visible. A useful channel model would have a parameter that sets the level of the noise. Look inside the channel model, and add a parameter by dragging one in from the <i>utilities</i> library, as shown in figure <p><img src="images/usingVergil62.gif" height="580" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168893">2.21</a>. Right click on the parameter to change its name to "noisePower". (In order to be able to use this parameter in expressions, the name cannot have any spaces in it.) Also, right click or double click on the parameter to change its default value to 0.1.
</p>


<p>
  <a name="168902"> </a>Now we can use this parameter. First, let's use it to set the amount of noise. The <i>Gaussian</i> actor has a parameter called <i>standardDeviation</i>. In this case, the power of the noise is equal to the variance of the Gaussian, not the standard deviation. If you recall from basic statistics, the standard deviation is equal to the square root of the variance. Change the <i>standardDeviation </i>parameter of the <i>Gaussian</i> actor so its value is "sqrt(noisePower)", as shown in figure <p><img src="images/usingVergil29.gif" height="165" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168902">2.22</a>. This is an expression that references the <i>noisePower</i> parameter. We will explain the expression language in the next section. But first, let check our improved model. Return to the top-level model, and edit the parameters of the <i>Channel</i> actor (by either double clicking or right clicking and selecting "Configure"). Change the noise power from the default 0.1 to 0.01. Run the model. You should now get a relatively clean sinusoid like that shown in figure <p><img src="images/usingVergil61.gif" usemap="#usingVergil61_gif" height="302" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil61_gif">

<area href="usingVergil.html#168725" shape=rect coords="3,269,597,296">
</map>
<a href="usingVergil.html#168902">2.23</a>.
</p>


<p>
  <a name="168972"> </a>Note that you can also add parameters to a composite actor without dragging from the <i>utilities </i>library by clicking on the "Add" button in the edit parameters dialog for the <i>Channel</i> composite. This dialog can be obtained by either double clicking on the <i>Channel</i> icon, or by right clicking and selecting "Configure", or by right clicking on the background inside the composite and selecting "Edit Parameters".
</p>


<p>
  <a name="168981"> </a>There are several other useful enhancements you could make to this model. Try dragging an <i>annotation</i> from the <i>utilities</i> library and creating a title on the diagram. Also, try setting the title of the plot by clicking on the second button from the right in the row of buttons at the top right of the plot. This button produces the tooltip "Set the plot format" and bring up the format control window.
</p>


<h2><a name="168803"> </a>2.6   Expressions<br></h2>


<p>
  <a name="167419"> </a>The values of parameters can be expressions. We have already seen a simple one,
</p>


<a name="168988"> </a><br>


<a name="168994"> </a>sqrt(noisePower)<br>


<a name="169002"> </a><br>


<a name="168989"> </a>Expressions can be used to specify the value of a parameter, or to specify the calculation performed by the <i>Expression</i> actor when it fires.<br>


<h3><a name="171261"> </a>2.6.1   Expression Actor<br></h3>


<a name="171267"> </a>The <i>Expression</i> actor is a particularly useful actor found in the <i>math</i> library. By default, it has one output an no inputs, as shown in figure <p><img src="images/usingVergil43.gif" height="455" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171267">2.24</a>(a). The first step in using it is to add ports, as shown in (b) and (c), resulting in a new icon as shown in (d). Then specify an expression using the port names, as shown in (e), resulting in the icon shown in (f).<br>


<h3><a name="171266"> </a>2.6.2   Constants and Literals<br></h3>


<p>
  <a name="169751"> </a>Expressions can include references to variables and some constants. By default, the constants supported are PI, pi, E, e, true, false, i, and j. for example,
</p>


<a name="167480"> </a><br>


<a name="167488"> </a>PI/2.0<br>


<a name="167489"> </a><br>


<a name="167490"> </a>is a valid expression, and can be given as the value of a parameter that can accept doubles. The constants i and j are complex numbers with value equal to 0.0 + 1.0i. In addition, literal string constants are supported. Anything between quotes, "...", is interpreted as a string constant. Numerical values without decimal points, such as "10" or "-3" are integers. Numerical values with decimal points, such as "10.0" or "3.14159" are doubles. Integers followed by the character "l" (el) or "L" are long integers.<br>


<h3><a name="169755"> </a>2.6.3   Operators<br></h3>


<p>
  <a name="167501"> </a>The arithmetic operators are +, <font  face="Symbol">-, *, /, ^, and %. Most of these operators operate on most data types, including matrices. The ^ operator computes "to the power of" where the power can only be an integer. The bitwise operators are &amp;, |, and ~. They operate on integers, where &amp; is bitwise and, ~ is bitwise not, and | is bitwise or. 
</p>


<p>
  <a name="167512"> </a>The relational operators are &lt;, &lt;=, &gt;, &gt;=, == and !=. They return booleans. Boolean-valued expressions can be used to give conditional values. The syntax for this is 
</p>


<a name="167514"> </a>boolean ? value1 : value2<br>


<a name="167515"> </a>If the boolean is true, value1 is returned, else value2 is returned. The logical boolean operators are &amp;&amp;, ||, !, &amp; and |. They operate on booleans and return booleans. Note that the difference between logical &amp;&amp; and logical &amp; is that &amp; evaluates all the operands regardless of whether their value is now irrelevant. Similarly for logical || and |. This approach is borrowed from Java.<br>


<h3><a name="169759"> </a>2.6.4   Variables<br></h3>


<p>
  <a name="167529"> </a>Expressions can contain references by name to parameters within the <i><b>scope</b></i> of the expression. Consider a parameter <i>P </i>in actor <i>X</i> which is in turn contained by composite actor <i>Y</i>. The scope of an expression for <i>P </i>includes all the parameters contained by <i>X</i> and <i>Y</i>, plus those of the container of <i>Y</i>, its container, etc. That is, the scope includes any parameters defined above in the hierarchy. You can add parameters to actors (composite or not) by right clicking on the actor, selecting "Configure" and then clicking on "Add", or by dragging in a parameter from the <i>utilities</i> library.
</p>


<h3><a name="169763"> </a>2.6.5   Arrays<br></h3>


<p>
  <a name="167020"> </a>Arrays are specified with curly brackets. E.g., "{1, 2, 3}" is an array of integers, while "{"x", "y", "z"}" is an array of strings. An array is an ordered list of tokens of any type, with the only constraint being that the elements all have the same type. Thus, for example, "{1, 2.3}" is illegal because the first element is an integer and the second is a double. The elements of the array can be given by expressions, as in the example "{2*pi, 3*pi}." Arrays can be nested; for example, "{{1, 2}, {3, 4, 5}}" is an array of arrays of integers.
</p>


<h3><a name="169767"> </a>2.6.6   Matrices<br></h3>


<p>
  <a name="169058"> </a>In Ptolemy II, arrays are ordered sets of tokens. Ptolemy II also supports matrices, which are more specialized than arrays. They contain only primitive types, currently <i>boolean</i>, <i>complex</i>, <i>double</i>, <i>fixedpoint</i>, <i>int</i>, and <i>long</i>. Matrices cannot contain arbitrary tokens, so they cannot, for example, contain matrices. They are intended for data intensive computations.
</p>


<p>
  <a name="167023"> </a>Matrices are specified with square brackets, using commas to separate row elements and semicolons to separate rows. E.g., "[1, 2, 3; 4, 5, 5+1]" gives a two by three integer matrix (2 rows and 3 columns). Note that an array or matrix element can be given by an expression, but all elements must have the same type, and that type must be one of the types for which matrices are defined. A row vector can be given as "[1, 2, 3]" and a column vector as "[1; 2; 3]". Some Matlab-style array constructors are supported. For example, "[1:2:9]" gives an array of odd numbers from 1 to 9, and is equivalent to "[1, 3, 5, 7, 9]." Similarly, "[1:2:9; 2:2:10]" is equivalent to "[1, 3, 5, 7, 9; 2, 4, 6, 8, 10]." In the syntax "[<i>p</i>:<i>q</i>:<i>r</i>]", <i>p</i> is the first element, <i>q</i> is the step between elements, and <i>r</i> is an upper bound on the last element. That is, the matrix will not contain an element larger than <i>r</i>.
</p>


<a name="167025"> </a>Reference to matrices have the form "<i>name</i>(<i>n</i>, <i>m</i>)" where <i>name</i> is the name of a matrix variable in scope, <i>n</i> is the row index, and <i>m</i> is the column index. Index numbers start with zero, as in Java, not 1, as in Matlab.<br>


<h3><a name="169771"> </a>2.6.7   Records<br></h3>


<a name="167028"> </a>A record token is a composite type where each element is named, and each element can have a distinct type. Records are delimited by curly braces, with each element given a name. For example, "{a=1, b="foo"}" is a record with two elements, named "a" and "b", with values 1 (an integer) and "foo" (a string), respectively. The value of a record element can be an arbitrary expression, and records can be nested (an element of a record token may be a record token).<br>


<h3><a name="169775"> </a>2.6.8   Functions<br></h3>


<p>
  <a name="169189"> </a>The expression language includes an extensible set of functions, such as sin(), cos(), etc. The functions that are built in include all static methods of the java.lang.Math class and the ptolemy.data.expr.UtilityFunctions class. This can easily be extended by registering another class that includes static methods. The functions currently available are shown in figures <p><img src="images/usingVergil63.gif" height="815" width="600" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#169189">2.25</a> and <p><img src="images/usingVergil64.gif" height="455" width="600" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#169189">2.26</a>, with the argument types and return types<a href="#169470"><sup>2</sup></a>.
</p>


<p>
  <a name="167314"> </a>One slightly subtle function is the random() function shown in figure <a href="usingVergil.html#169189">2.25</a>. It takes no arguments, and hence is written "random()". It returns a random number. However, this function is evaluated only when the expression within which it appears is evaluated. The result of the expression may be used repeatedly without re-evaluating the expression. The random() function is not called again. Thus, for example, if the <i>value</i> parameter of the <i>Const</i> actor is set to "random()", then its output will be a random constant; i.e., it will not change on each firing.
</p>


<h3><a name="169779"> </a>2.6.9   Methods<br></h3>


<p>
  <a name="167316"> </a>Every element and subexpression in an expression represents an instance of the Token class in Ptolemy II (or more likely, a class derived from Token). The expression language supports invocation of any method of a given token, as long as the arguments of the method are of type Token and the return type is Token (or a class derived from Token, or something that the expression parser can easily convert to a token, such as a string, double, int, etc.). The syntax for this is (<i>token</i>).<i>methodName</i>(<i>args</i>), where <i>methodName</i> is the name of the method and <i>args</i> is a comma-separated set of arguments. Each argument can itself be an expression. Note that the parentheses around the <i>token</i> are not required, but might be useful for clarity. As an example, the ArrayToken class has a getElement(int) method, which can be used as follows:
</p>


<a name="167319"> </a><br>


<a name="167320"> </a>{1, 2, 3}.getElement(1)<br>


<a name="167321"> </a><br>


<a name="167322"> </a>This returns the integer 2. Another useful function of array token is illustrated by the following example:<br>


<a name="167323"> </a><br>


<a name="167325"> </a>{1, 2, 3}.length()<br>


<a name="167326"> </a><br>


<a name="167327"> </a>which returns the integer 3.<br>


<p>
  <a name="167329"> </a>The MatrixToken classes have three particularly useful methods, illustrated in the following examples:
</p>


<a name="167330"> </a><br>


<a name="167332"> </a>[1, 2; 3, 4; 5, 6].getRowCount()<br>


<a name="167333"> </a><br>


<a name="167334"> </a>which returns 3, and<br>


<a name="167335"> </a><br>


<a name="167337"> </a>[1, 2; 3, 4; 5, 6].getColumnCount()<br>


<a name="167338"> </a><br>


<a name="167339"> </a>which returns 2, and<br>


<a name="167340"> </a><br>


<a name="167342"> </a>[1, 2; 3, 4; 5, 6].toArray()<br>


<a name="167343"> </a><br>


<a name="167344"> </a>which returns {1, 2, 3, 4, 5, 6}. The latter function can be particularly useful for creating arrays using Matlab-style syntax. For example, to obtain an array with the integers from 1 to 100, you can enter:<br>


<a name="167345"> </a><br>


<a name="167346"> </a>[1:1:100].toArray()<br>


<a name="167347"> </a><br>


<a name="167348"> </a>The get() method of RecordToken accesses a record field, as in the following example:<br>


<a name="167349"> </a><br>


<a name="167350"> </a>{a=1, b=2}.get("a")<br>


<a name="167351"> </a><br>


<a name="167352"> </a>which returns 1.<br>


<p>
  <a name="169720"> </a>The Token classes from the data package form the primitives of the language. For example the number 10 becomes an IntToken with the value 10 when evaluating an expression. Normally this is invisible to the user. The expression language is object-oriented, of course, so methods can be invoked on these primitives. A sophisticated user, therefore, can make use of the fact that "10" is in fact an object to invoke methods of that object. 
</p>


<p>
  <a name="169722"> </a>In particular, the convert() method of the Token class might be useful, albeit a bit subtle in how it is used. For example:
</p>


<a name="169723"> </a><br>


<a name="169724"> </a>double.convert(1)<br>


<a name="169725"> </a><br>


<a name="169726"> </a>creates a DoubleToken with value 1.0. The variable <i>double</i> is a built-in constant with type double. The convert() method of DoubleToken converts the argument to a DoubleToken, so the result of this expression is 1.0. A more peculiar way to write this is<br>


<a name="169727"> </a><br>


<a name="169728"> </a>(1.2).convert(1)<br>


<a name="169729"> </a><br>


<a name="169730"> </a>Any double constant will work in place of 1.2. Its value is irrelevant.<br>


<p>
  <a name="169734"> </a>The convert() method supports only lossless type conversion. Lossy conversion has to be done explicitly via a function call.
</p>


<h3><a name="169783"> </a>2.6.10   Supported Types<br></h3>


<p>
  <a name="172005"> </a>The types currently supported in the expression language are <i>boolean</i>, <i>complex</i>, <i>fixedpoint</i>, <i>double</i>, <i>int</i>, <i>long</i>, <i>array</i>, <i>matrix</i>, <i>record</i>, and <i>string</i>. Note that there is no float or byte (as yet). Use double or int instead. A long is defined by appending an integer with "l" (lower case L) or "L", as in Java. A complex is defined by appending an "i" or a "j" to a double for the imaginary part. This gives a purely imaginary complex number which can then leverage the polymorphic operations in the Token classes to create a general complex number. Thus "2 + 3i" will result in the expected complex number. A fixed point number is defined using the "fix" function, as will be explained below.
</p>


<h3><a name="169787"> </a>2.6.11   Comments<br></h3>


<a name="167558"> </a>In expressions, anything inside<b> /*...*/</b> is ignored, so you can insert comments.<br>


<h3><a name="171756"> </a>2.6.12   Fixed Point Numbers<br></h3>


<a name="171760"> </a>Ptolemy II includes a preliminary fixed point data type. We represent a fixed point value in the expression language using the following format: <br>


<a name="171766"> </a><br>


<a name="171768"> </a>fix(value, integerBits, fractionBits)<br>


<a name="171769"> </a><br>


<a name="171770"> </a>Thus, a fixed point value of 5.375 that uses 8 bit precision of which 4 bits are used to represent the integer part can be represented as:<br>


<a name="171771"> </a><br>


<a name="171772"> </a>fix(5.375, 8, 4)<br>


<a name="171773"> </a><br>


<a name="171777"> </a>The value can also be a matrix of doubles. The values are rounded, yielding the nearest value representable with the specified precision. If the value to represent is out of range, then it is saturated, meaning that the maximum or minimum fixed point value is returned, depending on the sign of the specified value. For example,<br>


<a name="171778"> </a><br>


<a name="171779"> </a>fix(5.375, 8, 3)<br>


<a name="171780"> </a><br>


<a name="171781"> </a>will yield 3.968758, the maximum value possible with the (8/3) precision.<br>


<p>
  <a name="171783"> </a>In addition to the fix() function, the expression language offers a quantize() function. The arguments are the same as those of the fix() function, but the return type is a DoubleToken or DoubleMatrixToken instead of a FixToken or FixMatrixToken. This function can therefore be used to quantize double-precision values without ever explicitly working with the fixed-point representation.
</p>


<p>
  <a name="171805"> </a>To make the FixToken accessible within the expression language, the following functions are available: 
</p>


<a name="171806"> </a>·	 To create a single FixPoint Token using the expression language:<br>


<a name="171807"> </a>fix(5.34, 10, 4)<br>


<a name="171808"> </a>This will create a FixToken. In this case, we try to fit the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. <br>


<a name="171809"> </a>·	 To create a Matrix with FixPoint values using the expression language:<br>


<a name="171810"> </a>fix([ -.040609, -.001628, .17853 ], 10,  2) <br>


<a name="171811"> </a>This will create a FixMatrixToken with 1 row and 3 columns, in which each element is a FixPoint value with precision (10/2). The resulting FixMatrixToken will try to fit each element of the given double matrix into a 10 bit representation with 2 bits used for the integer part. It uses by default the round quantizer.<br>


<a name="171812"> </a>·	 To create a single DoubleToken, which is the quantized version of the double value given, using the expression language:<br>


<a name="171813"> </a>quantize(5.34, 10, 4)<br>


<a name="171814"> </a>This will create a DoubleToken. The resulting DoubleToken contains the double value obtained by fitting the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. <br>


<a name="171815"> </a>·	 To create a Matrix with doubles quantized to a particular precision using the expression language:<br>


<a name="171816"> </a>quantize([ -.040609, -.001628, .17853 ], 10,  2) <br>


<a name="171817"> </a>This will create a DoubleMatrixToken with 1 row and 3 columns. The elements of the token are obtained by fitting the given matrix elements into a 10 bit representation with 2 bits used for the integer part. Instead of being a fixed point value, the values are converted back to their double representation and by default the round quantizer is used.<br>


<h2><a name="166337"> </a>2.7   Navigating Larger Models<br></h2>


<a name="168635"> </a>Sometimes, a model gets large enough that it is not convenient to view it all at once. There are four toolbar buttons, shown in figure <p><img src="images/usingVergil6.gif" height="183" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#168635">section 2.27</a>, that help. These buttons permit zooming in and out. The "Zoom reset" button restores the zoom factor to the "normal" one, and the "Zoom fit" calculates the zoom factor so that the entire model is visible in the editor window.<br>


<p>
  <a name="170131"> </a>In addition, it is possible to pan over a model. Consider the window shown in figure <p><img src="images/usingVergil4.gif" height="459" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170131">2.28</a>. Here, we have zoomed in so that icons are larger than the default. The <i>pan window</i> at the lower left shows the entire model, with a red box showing the visible portion of the model. By clicking and dragging in the pan window, it is easy to navigate around the entire model. Clicking on the "Zoom fit" button in the toolbar results in the editor area showing the entire model, just as the pan window does.
</p>


<h2><a name="168634"> </a>2.8   Domains<br></h2>


<a name="170167"> </a>A key innovation in Ptolemy II is that, unlike other design and modeling environments, there are several available <i>models of computation</i> that define the meaning of a diagram. In the above examples, we directed you to drag in an <i>SDFDirector</i> without justifying why. A director in Ptolemy II gives meaning (semantics) to a diagram. It specifies what a connection means, and how the diagram should be executed. In Ptolemy II terminology, the director realizes a <i>domain</i>. Thus, when you construct a model with an SDF director, you have constructed a model "in the SDF domain."<br>


<p>
  <a name="170171"> </a>The SDF director is fairly easy to understand. "SDF" stands for "synchronous dataflow." In dataflow models, actors are invoked (fired) when their input data is available. SDF is particularly simple case of dataflow where the order of invocation of the actors can be determined statically from the model. It does not depend on the data that is processed (the tokens that are passed between actors).
</p>


<p>
  <a name="170175"> </a>But there are several other models of computation available in Ptolemy II. It can be difficult to determine which one to use without having experience with several. Moreover, you will find that although most actors in the library do <i>something</i> in any domain in which you use them, they do not always do something useful. It is important to understand the domain you are working with and the actors you are using. Here, we give a very brief introduction to some of the domains. But we begin first by explaining some of the subtleties in SDF.
</p>


<h3><a name="168472"> </a>2.8.1   SDF and Multirate Systems<br></h3>


<p>
  <a name="166341"> </a>So far we have been dealing with relatively simple systems. They are simple in the sense that each actor produces and consumes one token from each port at a time. In this case, the SDF director simply ensures that an actor fires after the actors whose output values it depends on. The number of output values that are created by each actor is determined by the number of iterations.
</p>


<p>
  <a name="166684"> </a>It turns out that the SDF scheduler is actually much more sophisticated. It is capable of scheduling the execution of actors with arbitrary prespecified data rates. Not all actors produce and consume just a single sample each time they are fired. Some require several input token before they can be fired, and produce several tokens when they are fired.
</p>


<p>
  <a name="166688"> </a>One such actor is a spectral estimation actor. Figure <p><img src="images/usingVergil31.gif" height="195" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#166688">2.29</a> shows a system that computes the spectrum of the same noisy sine wave that we constructed in figure <a href="usingVergil.html#168725">2.19</a>. The <i>Spectrum</i> actor has a single parameter, which gives the <i>order</i> of the FFT used to calculate the spectrum. Figure <p><img src="images/usingVergil34.gif" usemap="#usingVergil34_gif" height="328" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil34_gif">

<area href="usingVergil.html#166688" shape=rect coords="3,296,597,322">
</map>
<a href="usingVergil.html#166688">2.30</a> shows the output of the model with <i>order</i> set to 8 and the number of <i>iterations</i> set to 1. <b>Note that there are 256 output samples output from the </b><i>Spectrum</i><b> actor</b>. This is because the <i>Spectrum</i> actor requires 2^8, or 256 input samples to fire, and produces 2^8, or 256 output samples when it fires. Thus, one iteration of the model produces 256 samples. The <i>Spectrum</i> actor makes this a <i>multirate</i> model, because the firing rates of the actors are not all identical.
</p>


<p>
  <a name="170218"> </a>It is common in SDF to construct models that require exactly one iteration to produce a useful result. In some multirate models, it can be complicated to determine how many firings of each actor occur per iteration of the model. See the SDF chapter for details.
</p>


<p>
  <a name="170224"> </a>A second subtlety with SDF models is that if there is a feedback loop, as in figure <p><img src="images/usingVergil8.gif" height="183" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170224">2.31</a>, then the loop must have at least one instance of the <i>SampleDelay</i> actor in it (found in the <i>flow control</i> library). Without this actor, the loop will deadlock. The <i>SampleDelay</i> actor produces initial tokens on its output, before the model begins firing. The initial tokens produced are given by a the <i>initialOutputs</i> parameter, which specifies an array of tokens. These initial tokens enable downstream actors and break the circular dependencies that would result otherwise from a feedback loop.
</p>


<p>
  <a name="170292"> </a>A final issue to consider with the SDF domain is time. Notice that in all the examples above we have suggested using the <i>SequencePlotter</i> actor, not the <i>TimedPlotter</i> actor, which is in the same <i>sinks </i>library. This is because the SDF domain does not include in its semantics a notion of time. Time does not advance as an SDF model executes, so the <i>TimedPlotter</i> actor would produce very uninteresting results, where the horizontal axis value would always be zero. An experimental domain, discrete time (DT), adds time to SDF. This turns out to be somewhat subtle for multirate systems, and this domain has not yet (as of version 2.0) reached the maturity of SDF.
</p>


<p>
  <a name="170571"> </a>The <i>SequencePlotter</i> actor uses the index in the sequence for the horizontal axis. The first token received is plotted at horizontal position 0, the second at 1, the third at 2, etc. The next domain we consider, DE, includes much stronger notion of time, and it is almost always more appropriate in the DE domain to use the <i>TimedPlotter</i> actor.
</p>


<h3><a name="166726"> </a>2.8.2   Discrete-Event Systems<br></h3>


<a name="170574"> </a>In discrete-event (DE) systems, the connections between actors carry signals that consist of <i>events</i> placed on a time line. Each event has both a value and a time stamp, where its time stamp is a double-precision floating-point number. This is different from dataflow, where a signal consists of a sequence of tokens, and there is no time significance in the signal.<br>


<p>
  <a name="170587"> </a>A DE model executes chronologically, processing the oldest events first. Time advances as events are processed. There is potential confusion, however, between <i>model time</i>, the time that evolves in the model, and <i>real time</i>, the time that elapses in the real world while the model executes (also called <i>wall-clock time</i>). Model time may advance more rapidly than real time or more slowly. The DE director has a parameter, <i>synchronizeToRealTime</i>, that, when set to true, attempts to synchronize the two notions of time. It does this by delaying execution of the model, if necessary, allowing real time to catch up with model time.
</p>


<p>
  <a name="170593"> </a>Consider the DE model shown in figure <p><img src="images/usingVergil10.gif" height="378" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170593">2.32</a>. This model includes a <i>PoissonClock</i> actor, a <i>CurrentTime</i> actor, and a <i>WallClockTime</i> actor, all found in the <i>sources</i> library. The <i>PoissonClock</i> actor generates a sequence of events with random times, where the time between events is exponentially distributed. Such an event sequence is known as a Poisson process. The value of the events produced by the <i>PoissonClock</i> actor is a constant, but the value of that constant is ignored in this model. Instead, these events trigger the <i>CurrentTime</i> and <i>WallClockTime</i> actors. The <i>CurrentTime</i> actor outputs an event with the same time stamp as the input, but whose value is the current model time (equal to the time stamp of the input). The <i>WallClockTime</i> actor an event with the same time stamp as the input, but whose value is the current real time, in seconds since initialization of the model.
</p>


<p>
  <a name="170654"> </a>The plot in figure <a href="usingVergil.html#170593">2.32</a> shows an execution. Note that model time has advanced approximately 10 seconds, but real time has advanced almost not at all. In this model, model time advances much more rapidly than real time. If you build this model, and set the <i>synchronizeToRealTime</i> parameter of the director to true, then you will find that the two plots coincide almost perfectly.
</p>


<p>
  <a name="170656"> </a>A significant subtlety in using the DE domain is in how simultaneous events are handled. Simultaneous events are simply events with the same time stamp. We have stated that events are processed in chronological order, but if two events have the same time stamp, then there is some ambiguity. Which one should be processed first? If the two events are on the same signal, then the answer is simple: process first the one that was produced first. However, if the two events are on different signals, then the answer is not so clear.
</p>


<p>
  <a name="170730"> </a>Consider the model shown in figure <p><img src="images/usingVergil12.gif" height="365" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170730">2.33</a>, which produces a histogram of the interarrival times of events from the <i>PoissonClock</i> actor. In this model, we calculate the difference between the current event time and the previous event time, resulting in the plot that is shown in the figure. The <i>Previous </i>actor is a <i>zero-delay</i> actor, meaning that it produces an output with the same time stamp as the input (except on the first firing, where in this case it produces no output). Thus, when the <i>PoissonClock </i>actor produces an output, there will be two simultaneous events, one at the input to the <i>plus</i> port of the <i>AddSubtract</i> actor, and one at the input of the <i>Previous</i> actor. Should the director fire the <i>AddSubtract </i>actor or the <i>Previous</i> actor? Either seems OK if it is to respect chronological order, but it seems intuitive that the <i>Previous</i> actor should be fired first.
</p>


<p>
  <a name="170775"> </a>It is helpful to know how the <i>AddSubtract </i>actor works. When it fires, it adds all available tokens on the <i>plus </i>port, and subtracts all available tokens on the <i>minus</i> port. If the <i>AddSubtract </i>actor fires before the <i>Previous</i> actor, then the only available token will be the one on the <i>plus</i> port, and the expected subtraction will not occur. Intuitively, we would expect the director to invoke the <i>Previous</i> actor before the <i>AddSubtract </i>actor so that the subtraction occurs.
</p>


<p>
  <a name="170953"> </a>How does the director deliver on the intuition that the <i>Previous</i> actor should be fired first? Before executing the model, the DE director constructs a <i>topological sort</i> of the model. A topological sort is simply a list of the actors in data-precedence order. For the model in figure <a href="usingVergil.html#170730">2.33</a>, there is only one allowable topological sort:
</p>


<a name="170958"> </a>·	 <i>PoissonClock</i>, <i>CurrentTime</i>, <i>Previous</i>, <i>AddSubtract</i>, <i>HistogramPlotter</i><br>


<a name="170873"> </a>In this list, <i>AddSubtract</i> is after <i>Previous</i>. So the when they have simultaneous events, the DE director fires <i>Previous</i> first.<br>


<p>
  <a name="170881"> </a>Thus, the DE director, by analyzing the structure of the model, usually delivers the intuitive behavior, where actors that produce data are fired before actors that consume their results, even in the presence of simultaneous events.
</p>


<p>
  <a name="170882"> </a>There remains one key subtlety. If the model has a directed loop, then a topological sort is not possible. In the DE domain, every feedback loop is required to have at least one actor in it that introduces a time delay, such as the <i>TimedDelay</i> actor, which can be found in the <i>domain specific</i> library under <i>discrete-event</i> (this library is shown on the left in figure <p><img src="images/usingVergil14.gif" height="522" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170882">2.34</a>). Consider for example the model shown in figure <a href="usingVergil.html#170882">2.34</a>. That model has a <i>Clock</i> actor, which is set to produce events every 1.0 time units. Those events trigger the <i>Ramp</i> actor, which produces outputs that start at 0 and increase by 1 on each firing. In this model, the output of the <i>Ramp</i> goes into an <i>AddSubtract</i> actor, which subtracts from the <i>Ramp</i> output its own prior output delayed by one time unit. The result is shown in the plot in the figure.
</p>


<p>
  <a name="171032"> </a>Occasionally, you will need to put a <i>TimedDelay</i> actor in a feedback loop with a delay of 0.0. This is particularly true if you are building complex models that mix domains, and there is a delay inside a composite actor that the DE director cannot recognize as a delay. The <i>TimedDelay</i> actor with a delay of 0.0 can be thought of as a way to let the director know that there is a time delay in the preceding actor, without specifying the amount of the time delay.
</p>


<h3><a name="170874"> </a>2.8.3   Continuous-Time Systems<br></h3>


<a name="171090"> </a>The continuous-time domain (CT) is another relatively mature domain with semantics considerably different from either DE or SDF. In CT, the signals sent along connections between actors are continuous-time signals, or in some cases, discrete-events that behave similarly to those in DE, with some restrictions. The typical application of the CT domain is to model differential equations. Consider the following set of three differential equations:<br>

<div align="center">
<a name="171067"> </a>(1) <p><img src="images/usingVergil46.gif" height="66" width="140" align="bottom" border="0" hspace="0" vspace="0"><p>
<br>
</div>

<a name="171089"> </a>There are three variables, <p><img src="images/usingVergil18.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
, <p><img src="images/usingVergil19.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
, and <p><img src="images/usingVergil21.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
, and three constants, <p><img src="images/usingVergil22.gif" height="18" width="12" align="left" border="0" hspace="0" vspace="0">
, <p><img src="images/usingVergil24.gif" height="18" width="12" align="left" border="0" hspace="0" vspace="0">
, and <p><img src="images/usingVergil25.gif" height="18" width="11" align="left" border="0" hspace="0" vspace="0">
. The variables vary continuously with time, and hence represent continuous-time signals. The notation <p><img src="images/usingVergil27.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
 refers to the time derivative of <p><img src="images/usingVergil28.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
.<br>


<p>
  <a name="171152"> </a>A model of these differential equations in the CT domain is shown in figure <p><img src="images/usingVergil30.gif" height="572" width="600" align="center" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171152">2.35</a>. As is customary in modeling differential equations, we use <i>integrators</i> instead of differentiators. Integrators are much more numerically robust. They are arranged in a feedback loop, so that the input to an integrator is simply the derivative of the output. Thus, the output of <i>Integrator 1</i> is <p><img src="images/usingVergil32.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
, and its input is <p><img src="images/usingVergil33.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
. A feedback loop is used to specify the value of <p><img src="images/usingVergil35.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
 in terms of <p><img src="images/usingVergil36.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
, <p><img src="images/usingVergil38.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
, and <p><img src="images/usingVergil39.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
.
</p>


<p>
  <a name="171151"> </a>This set of differential equations describe a famous chaotic system called a Lorenz attractor. It is a special case of a family of nonlinear feedback systems that exhibit <i>strange attractor</i> behavior. The "attractors" are the two nodes in the plot in figure <a href="usingVergil.html#171152">2.35</a> that the trace seems to be alternately orbiting.
</p>


<p>
  <a name="171229"> </a>The model in figure <a href="usingVergil.html#171152">2.35</a> illustrates several points. First, in CT, every feedback loop must contain an integrator. Second, the <i>XYPlotter</i> actor is used to plot <p><img src="images/usingVergil56.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
vs. <p><img src="images/usingVergil41.gif" height="21" width="16" align="left" border="0" hspace="0" vspace="0">
. Third, three instances of the <i>Expression</i> actor are used instead of complex block diagrams to specify arithmetic expressions. Use of the <i>Expression</i> actor is explained in <a href="usingVergil.html#171261">section 2.6.1</a>.
</p>


<p>
  <a name="171230"> </a>The CT domain can also handle discrete events. These events are usually related to a continuous-time signal, for example representing a zero-crossing of the continuous-time signal. The CT director is quite sophisticated in its handling of such mixed signal systems. For details, refer to the CT chapter.
</p>


<h3><a name="170329"> </a>2.8.4   FSM and Modal Models<br></h3>


<a name="170308"> </a>The finite-state machine domain (FSM) in Ptolemy II is a relatively less mature domain (but mature enough to be useful) with semantics very different from the domains covered so far. An FSM model looks different in Vergil. An example is shown in figure <p><img src="images/usingVergil45.gif" height="369" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#170308">2.36</a>. Notice that the component library on the left and the toolbar at the top are different for this model. We will explain how to construct this model.<br>


<p>
  <a name="171389"> </a>First, the FSM domain is almost always used in combination with other domains in Ptolemy II to create <i>modal models</i>. A modal model is one that has <i>modes</i>, which represent regimes of operation. Each mode in a modal model is represented by a <i>state</i> in a finite-state machine. The circles in figure <a href="usingVergil.html#170308">2.36</a> are states, and the arcs between circles are <i>transitions </i>between states.
</p>


<p>
  <a name="171407"> </a>A modal model is typically a component in a larger model. You can create a modal model by dragging one in from the <i>utilities</i> library. By default, it has no ports. To make it useful, you will probably need to add ports. Figure <p><img src="images/usingVergil50.gif" height="207" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171407">2.37</a> shows a top-level continuous-time model with a single modal model that has been renamed <i>Ball Model</i>. It represents a bouncing ball. Three outputs have been added, but only the top one is used. It gives the vertical distance of the ball from the surface on which it bounces.
</p>


<p>
  <a name="171433"> </a>If you create a new modal model by dragging it in from the <i>utilities</i> library, and then look inside, you will get an FSM editor like that in figure <a href="usingVergil.html#170308">2.36</a>, except that it will be almost blank. The only items in it will be the ports you have added. You may want to move these ports to reasonable locations.
</p>


<p>
  <a name="171440"> </a>To create a finite-state machine like that in figure <a href="usingVergil.html#170308">2.36</a>, drag in states (white circles). You can rename these states by right clicking on them and selecting "Customize Name". Choose names that are pertinent to your application. In figure <a href="usingVergil.html#170308">2.36</a>, there is an <i>init</i> state for initialization, a <i>free</i> state for when the ball is in the air, and a <i>stop</i> state for when the ball is no longer bouncing. You must specify the initial state of the FSM by right clicking on the background of the FSM Editor, selecting "Edit Parameters", and specifying an initial state name. In this example, the initial state is <i>init</i>.
</p>


<p>
  <a name="171454"> </a>To create transitions, you must hold the control button on the keyboard while clicking and dragging from one state to the next (a transition can also go back to the same state). The handles on the transition can be used to customize its curvature and orientation. Double clicking on the transition (or right clicking and selecting "Configure") allows you to configure the transition. The dialog for the transition from <i>init</i> to <i>free </i>is shown in figure <p><img src="images/usingVergil48.gif" usemap="#usingVergil48_gif" height="207" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil48_gif">

<area href="usingVergil.html#170308" shape=rect coords="3,182,593,204">
</map>
<a href="usingVergil.html#171454">2.38</a>. In that dialog, we see the following:
</p>


<a name="171487"> </a>·	 The guard expression is <i>true</i>, so this transition is always enabled. The transition will be taken as soon as the model begins executing. A guard expression can be any boolean-valued expression that depends on the inputs, parameters, or even the outputs of any refinement of the current state (see below). Thus, this transition is used to initialize the model.<br>


<a name="171492"> </a>·	 The output actions are empty, meaning that when this transition is taken, no output is specified. This parameter can have a list of assignments of values to output ports, separated by semicolons. Those values will be assigned to output ports when the transition is taken.<br>


<a name="171536"> </a>·	 The set actions contain the following statements:<br>


<a name="171538"> </a><br>


<a name="171542"> </a>free.initialPosition = initialPosition; free.initialVelocity = 0.0<br>


<a name="171551"> </a><br>


<a name="171552"> </a>The "free" in these expressions refers to the mode refinement in the "free" state. Thus, "free.initialPosition" is a parameter of that mode refinement. Here, its value is assigned to the value of the parameter "initialPosition". The parameter "free.initialVelocity" is set to zero.<br>


<a name="171557"> </a>·	 The <i>reset</i> parameter is set to <i>true</i>, meaning that the destination mode should be initialized when the transition is taken.<br>


<a name="171562"> </a>·	 The <i>preemptive</i> parameter is set to <i>false</i>. In this case, it makes no difference, since the <i>init</i> state has no refinement. Normally, if a transition out of a state is enabled and <i>preemptive</i> is <i>true</i>, then the transition will be taken without first firing the refinement.<br>


<a name="171563"> </a>To create a refinement for a state, right click on the state, and select "Add Refinement". You will see a dialog like that in figure <p><img src="images/usingVergil52.gif" height="187" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171948">2.42</a>. You can specify the class name for the refinement, but for now, it is best to accept the default. Once you have created a refinement, you can look inside a state. For the bouncing ball example, the refinement of the <i>free</i> state is shown in figure <p><img src="images/usingVergil49.gif" usemap="#usingVergil49_gif" height="212" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<map name="usingVergil49_gif">

<area href="usingVergil.html#170308" shape=rect coords="3,187,593,209">
</map>
<a href="usingVergil.html#171563">2.40</a>. This model exhibits certain key properties of state refinements:<br>


<a name="171623"> </a>·	 Refinements must contain directors. In this case, the CTEmbeddedDirector is used. When a continuous-time model is used inside a mode, this director must be used instead of the default<br>CTDirector (see the CT chapter for details).<br>


<a name="171628"> </a>·	 The refinement has the same ports as the modal model, and can read input value and specify output values. When the state machine is in the state of which this is the refinement, this model will be executed to read the inputs and produce the outputs.<br>


<a name="171629"> </a>·	 In this case, the refinement simply defines the laws of gravity. An acceleration of -10 m/sec2 (roughly) is integrated to get the velocity. This, in turn, is integrated to get the vertical position.<br>


<a name="171635"> </a>·	 A <i>ZeroCrossingDetector</i> actor is used to detect when the vertical position of the actor is zero. This results in production of an event on the (discrete) output <i>bump</i>. Examining figure <a href="usingVergil.html#170308">2.36</a>, you can see that this event triggers a state transition back to the same <i>free</i> state, but where the <i>initialVelocity</i> parameter is changed to reverse the sign and attenuate it by the <i>elasticity</i>. This results in the ball bouncing, and losing energy.<br>


<a name="171494"> </a>As you can see from figure <a href="usingVergil.html#170308">2.36</a>, when the position and velocity of the ball drop below a specified threshold, the state machine transitions to the state <i>stop</i>, which has no refinement. This results in the model producing no further output. The result of an execution is shown in figure <p><img src="images/usingVergil54.gif" height="291" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171494">2.41</a>. Notice that the ball bounces until it stops, after which there are no further outputs.<br>


<p>
  <a name="171675"> </a>This model illustrates an interesting property of the CT domain. The <i>stop</i> state, it turns out, is essential. Without it, the time between bounces keeps decreasing, as does the magnitude of each bounce. At some point, these numbers get smaller than the representable precision, and large errors start to occur. Try removing the <i>stop</i> state from the FSM, and re-run the model. What happens? Why?
</p>


<p>
  <a name="171500"> </a>Modal models can be used in any domain. Their behavior is simple. When the modal model is fired, the following sequence of events occurs:
</p>


<a name="171501"> </a>·	 The refinement of the current state, if there is one, is fired (unless <i>preemptive </i>is true, and one of the guards on outgoing transitions evaluates to true).<br>


<a name="171509"> </a>·	 The guard expressions on all the outgoing transitions are evaluated. If none are true, the firing is complete. If one is true, then that transition is taken. If more than one is true, then an exception is thrown (the FSM is nondeterministic).<br>


<a name="171510"> </a>·	 When a transition is taken, its output actions and set actions are evaluated.<br>


<a name="171511"> </a>·	 If <i>reset</i> is true, then the refinement of the destination mode (if there is one) is initialized.<br>


<h3><a name="168491"> </a>2.9   Using the Plotter<br></h3>


<a name="166744"> </a>Several of the plots shown above have flaws that can be fixed using the features of the plotter. For instance, the plot shown in figure <a href="usingVergil.html#166688">2.30</a> has the default (uninformative) title, the axes are not labeled, and the horizontal axis ranges from 0 to 255<a href="#166823"><sup>3</sup></a>, because in one iteration, the <i>Spectrum</i> actor produces 256 output tokens. These outputs represent frequency bins that range between <p><img src="images/usingVergil40.gif" height="18" width="19" align="bottom" border="0" hspace="0" vspace="0"><p>
 and <p><img src="images/usingVergil42.gif" height="18" width="12" align="bottom" border="0" hspace="0" vspace="0"><p>
 radians per second.<br>


<p>
  <a name="171948"> </a>The <i>SequencePlotter</i> actor has some pertinent parameters, shown in figure <p><img src="images/usingVergil44.gif" height="153" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171563">2.39</a>. The <i>xInit</i> parameter specifies the value to use on the horizontal axis for the first token. The <i>xUnit</i> parameter specifies the value to increment this by for each subsequent token. Setting these to "-PI" and "PI/128" respectively results in the plot shown in figure <p><img src="images/usingVergil47.gif" height="261" width="598" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171948">2.43</a>.
</p>


<p>
  <a name="171960"> </a>This plot is better, but still missing useful information. To control more precisely the visual appearance of the plot, click on the second button from the right in the row of buttons at the top right of the plot. This button brings up a format control window. It is shown in figure <p><img src="images/usingVergil51.gif" height="248" width="594" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171960">2.44</a>, filled in with values that result in the plot shown in figure <p><img src="images/usingVergil16.gif" height="282" width="599" align="bottom" border="0" hspace="0" vspace="0"><p>
<a href="usingVergil.html#171960">2.45</a>. Most of these are self-explanatory, but the following pointers may be useful:
</p>


<a name="166883"> </a>·	 The grid is turned off to reduce clutter.<br>


<a name="166887"> </a>·	 Titles and axis labels have been added.<br>


<a name="166888"> </a>·	 The X range and Y range are determined by the fill button at the upper right of the plot.<br>


<a name="166889"> </a>·	 Stem plots can be had by clicking on "Stems"<br>


<a name="166890"> </a>·	 Individual tokens can be shown by clicking on "dots"<br>


<a name="166891"> </a>·	 Connecting lines can be eliminated by deselecting "connect"<br>


<a name="166892"> </a>·	 The X axis label has been changed to symbolically indicate multiples of PI/2. This is done by entering the following in the X Ticks field:<br>


<a name="166870"> </a>-PI -3.14159, -PI/2 -1.570795, 0 0.0, PI/2 1.570795, PI 3.14159<br>


<a name="166896"> </a>The syntax in general is:<br>


<a name="166897"> </a>label value, label value, ...<br>


<a name="166898"> </a>where the label is any string (enclosed in quotation marks if it includes spaces), and the value is a number.<br>


  
<a name="166915"> </a><a href="#168725"><sup>1</sup></a>
<a name="166915"> </a><b>Hint: </b>to create a connection starting on one of the external ports, hold down the control key when dragging.<br>

<br>


<a name="169470"> </a><a href="#169189"><sup>2</sup></a>
<a name="169470"> </a>At this time, in release 2.0, the types must match exactly for the expression evaluator to work. Thus, "sin(1)" fails, because the argument to the sin() function is required to be a double.<br>

<br>


<a name="166823"> </a><a href="#166744"><sup>3</sup></a>
<a name="166823"> </a><b>Hint:</b> Notice the "x102 " at the bottom right, which indicates that the label "2.5" stands for "250".<br>

<br>
</blockquote>

<hr>

</body>
</html>
