<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Code Generation</title>
<link href="../../doc/default.css" rel="stylesheet" type="text/css">
</head>
<body>
<html>
<h1>Code Generation</h1>
This code generator is patterned after the Ptolemy Classic 
code generator where actors have template files consisting
of code blocks.  The code blocks are stitched together to create
the resulting file.

<ul>
<li><a href="#Simple Demo">Simple Demo</a>
<li><a href="#Java Command Line Demo">Java Command Line Demo</a>
<li><a href="#Package Overview">Package Overview</a>
<li><a href="#Limitations">Limitations</a>
<li><a href="#FAQ">FAQ</a>
</ul>

<h2><a name="Simple Demo">Simple Demo</a></h2>
<ol>
<li>Generate HTML code that describes a model.
  <br/>If you are viewing this page from within vergil, 
open <a href="adapter/generic/html/demo/HierarchicalModel/HierarchicalModel.xml"><code>$PTII/ptolemy/cg/adapter/generic/html/demo/HierarchicalModel/HierarchicalModel.xml</code></a>
  <br/>If you are viewing this page from a browser, start vergil with:
  <code>$PTII/bin/vergil /Users/cxh/ptII/ptolemy/cg/adapter/generic/html/demo/HierarchicalModel/HierarchicalModel.xml</code></li> 
<li> Click on the HTMLCodeGenerator icon.</li>
<li> A dialog box will appear, click on "Generate"</li>
<li> An HTML description of the model will be generated and displayed.</li>
</ol>

<h2><a name="Java Command Line Demo">Java Command Line Demo</a></h2>
To generate Java code for a simple model, run:
<pre>
$PTII/bin/ptcg -language java $PTII/ptolemy/cg/kernel/generic/program/procedural/java/test/auto/Display.xml 
</pre>
or
<pre>
java -classpath $PTII ptolemy.cg.kernel.generic.GenericCodeGenerator -language java $PTII/ptolemy/cg/kernel/generic/program/procedural/java/test/auto/Display.xml
</pre>

<h2><a name="Package Overview">Package overview</a></h2>
The cg facility uses an adapter pattern where classes in a regular
Ptolemy II model have corresponding classes in the cg facility.

<p>The cg subpackages are structured so that language specific code
is separate from generic code.</p>   

<p>The main entry point is
$PTII/ptolemy/cg/kernel/generic/GenericCodeGenerator.java.
This file is invoked by <code>$PTII/bin/ptcg</code>.  To get the complete list
of options, run <code>$PTII/bin/ptcg -help</code>.</p>

<p>To invoke the cg code generator from the GUI, drag in
a code generator attribute from More Libraries -&gt;
CodeGenerators -&gt;CGCodegen.</p>

<p>The ptolemy/cg directory has these subdirectories:</p>
<dl>
  <dt> ptolemy/cg/adapter</dt>
  <dd> Language specific adapters classes that correspond with
regular Ptolemy II classes.
    <dl> 
      <dt> ptolemy/cg/adapter/generic/program/procedural/</dt>
      <dd> The classes for the procedural languages (C and Java)
        <dl>
	  <dt> ptolemy/cg/adapter/generic/program/procedural/adapters</dt>
	  <dd> The adapter definitions that are shared between the procedural languages.  For example, the Display adapter is at ptolemy/cg/adapter/generic/program/procedural/adapters/ptolemy/actor/lib/gui/Display.java</dd>
	  <dt> ptolemy/cg/adapter/generic/program/procedural/adapters/c</dt>
	  <dd> The adapters for actors that generate C.  In general, the Java class extends the shared adapter
	    and contains only a constructor.  There is an optional <code>.c</code> file that contains
	    C-specific blocks of code used in code generation.
	    For example, we have ptolemy/cg/adapter/generic/program/procedural/c/adapters/ptolemy/actor/lib/gui/Display.java
	    and ptolemy/cg/adapter/generic/program/procedural/c/adapters/ptolemy/actor/lib/gui/Display.c
	  </dd>
	  <dd> The adapters for actors that generate Java.  The layout is similar to the C version, except the
	    <code>.j</code> file contains the Java template blocks.  The file is named .j so that it does not get compiled.
	  </dd>
        </dl>
    </dl>
  </dd>
  <dt> ptolemy/cg/gui</dt>
  <dd>Graphical User Interface (gui) code.  If a model has a
  ptolemy.cg.gui.CodeGeneratorGUIFactory attribute in it, then
  double clicking on that attribute brings up the code generator gui.
  </dd>
  <dt> ptolemy/cg/kernel</dt>
  <dd>Non-language specific code generation classes and language-specific
    type information.</dd>
  <dt>ptolemy/cg/lib</dt>
  <dd>Modular code generation work and syntactic code generation
work</dd>
</dl>

<h2>Hints about working with the tree</h2>

Because the tree is so deep, you may find it easier to use a few tools to quickly search files from the command line.

<h3>Search for files</h3>
To find all the files named <code>Display</code> use:
<pre>
cd $PTII/ptolemy/cg
find . -name "Display"
</pre>

<h3>Search all the files for a string</h3>
<pre>
find . -type f | xargs grep MyString
</pre>

<h2>How to add an actor</h2>

<p>Adding code generation support for an actor is fairly complex, but
follows a pattern.</p>

<ol>

 <li>First, check to see that there is no already a code generation
 version of the actor.  It could be that there is one for a different
 language.  Also, look for code generation versions of the actors that
 are similar to the actor in question.</li>

 <li>Read the style guide
 at <a href="../../doc/coding/style.htm">$PTII/doc/coding/style.htm</a>.
 In particular, pay attention to the parts about makefiles.</li>

 <li>The ptolemy/cg directory contains subdirectories that mimic the
 Ptolemy II tree.  So, if we are adding a code generation version of
 an actor in ptolemy/actor/lib, then we will be working in similar
 subdirectories in ptolemy/cg.</li>

 <li>The code generation system reads blocks of code from a template
 file and does substitution.  Most of the work occurs in a file that
 is shared between the procedural languages (C and Java).  The directory is
 <code>$PTII/ptolemy/cg/adapter/generic/program/procedural/adapters/ptolemy/actor/lib/</code>

 <li>The C or Java specific code is in
   <br/><code>$PTII/ptolemy/cg/adapter/generic/program/procedural/<b>c</b>/adapters/ptolemy/actor/lib/</code>
or
   <br/><code>$PTII/ptolemy/cg/adapter/generic/program/procedural/<b>java</b>/adapters/ptolemy/actor/lib/</code>
  <br/>These directories contain corresponding <code>.c</code> or <code>.j</code> files that define the blocks
  used in the generated code.
  <br/>These directories also contain a <code>test/auto/</code> directory that contains the test models.
 </li>

</ol>


<h2>Supporting different targets</h2>

<p>A target is typically an architecture-specific platform.  For
example, the <code>arduino</code> target generates C-code meant to run
on the Arduino platform. </p>

<p>To generate code for a target, use the <code>-generatorPackageList</code> command line argument to 
<code>$PTII/bin/cg</code>.  The value of the <code>-generatorPackageList</code> parameter i
a semicolon or * separated list of Java packages to be searched for adapters.  For example
<pre>
$PTII/bin/ptcg -generatorPackageList generic.program.procedural.c.arduino ptolemy/cg/adapter/generic/program/pro\
cedural/c/arduino/adapters/ptolemy/actor/lib/gui/test/auto/Display.xml
</pre>

<p>
<br><b>FIXME: Not updated below here</b>
<br><b>FIXME: Not updated below here</b>
<br><b>FIXME: Not updated below here</b>
<p>
<a href="../configs/codegen/demos.htm">Other Codegen Demonstrations</a>


<h2><a name="Limitations">Limitations</a></h2>
This is a highly preliminary code generator facility, with many 
limitations.  It is best viewed as a concept demonstration.

<ul>
<li> Only SDF, FSM and HDF domains are supported
<li> Only IntToken, DoubleToken, StringToken, ComplexToken and ArrayToken are supported.
Other tokens are not supported at this time.
<li> A limited number of actors have supporting adapters code.
The easiest way to build models that only the actors that have
code generation support is to run
<pre>
$PTII/bin/vergil -codegen
</pre>

<li> The macro facility does not ignore comments in C files.  Thus
if a comment in a C files has <CODE>$channel</CODE>, then it
will be expanded.  This can cause problems if the 
macro is ill-formed. To top expansion, use <CODE>\$channel</CODE>

</ul>

<h2><a name="FAQ">FAQ</a>
<h3><a name="ProblemsGeneratingCode">Problems Generating Code</a></h3>

<dl>
<dt> Generating code results in <code>IOException: java.io.IOException: CreateProcess: make -f <i>Model</i>.mk error=2</code>
<dl> This will happen if <code>make</code> is not in your path.
Under Windows, you may need to install Cygwin, see the
<a
href="http://ptolemy.eecs.berkeley.edu/ptolemyII/ptIIlatest/cygwin.htm">Ptolemy
II Cygwin installer</a>.  Under Windows, if Cygwin is installed, then
be sure that <code>C:\cygwin\bin</code> is in your Windows path.
To edit your path, do <CODE>Start Menu </CODE> -&gt; <CODE>Settings</CODE> -&gt;
<CODE>Control Panels</CODE> -&gt; <CODE>System</CODE> -&gt;
<CODE>Advanced</CODE> -&gt; <CODE>Environment Variables</CODE>.

<dt> Models that use a plotter fail to compile.
<dd> Models that use the plotter use the Java Native Interface (JNI)
to invoke the plotter from within the C process. This is done
so that the plotter is interactive while the model is running
as opposed to plotting the data after the model completes.
The JNI facility requires that a Java Development Kit (JDK)
be installed instead of a Java Runtime Environment (JRE).
The Ptolemy II Windows installer includes a JRE which is optionally
installed.  If the Windows installer is installed with the bundled
JRE, then models that use the plotter will probably fail to compile
with message like:
<pre>
make: *** [Ramp] Error 1
</pre>

</dl>

<h3><a name="ProblemsRunning">Problems Running</a></h3>
<dl>

<dt> Models that use the plotter require setup
<dd> To properly run a model that has a plotter, you must have jvm.dll
in your path.
If you do not, then when you run the executable, it will immediately exit
with no message!
For example, place <pre>C:\Progra~1\Java\jdk1.5.0_11\jre\bin\client</pre>
in your path.  If you are running Vergil from the command line as 
$PTII/bin/ptinvoke, then this has been handled for you.
If you are running via Eclipse, then you must update your path by hand.

<dt> When in Windows, clicking on a .exe produced by the 
code generator fails to start up.  The message is:
 <br>  The procedure entry point _impure_ptr could not be located in
  the dynamic link library cygwin1.dll
<dd> The solution is to add <CODE>C:\cygwin\bin</CODE> to the
Windows path by doing:
<CODE>Start Menu </CODE> -&gt; <CODE>Settings</CODE> -&gt;
<CODE>Control Panels</CODE> -&gt; <CODE>System</CODE> -&gt;
<CODE>Advanced</CODE> -&gt; <CODE>Environment Variables</CODE>
and adding <CODE>C:\cygwin\bin</CODE> to the path.
 <br>To get rid of the console, compile with the exe with -mwindows:
<pre>
make -f <I>Model</I>.mk CC_FLAGS=-mwindows
</pre>
</dl>

<h3><a name="Extending">Extending the Code Generator</a></h3>

<dl>
<dt> Why are some of my ports being generated as Tokens in the C output?
<dd> 

The simple rule for the the type resolution in codegen is that any
resolved Ptolemy types the codegen kernel defines to be non-primitive
will be Token type in the generated code. User code (helper classes)
is responsible for making the distinction between different data
types, which mean the helper code may have different code blocks for
handling different resolved type in the generated code.  The
CodeGeneratorHelper.isPrimitive() method is what is used to determine
if a type is primitive.  Also, a good example to look at is the
codegen/c/actor/lib/ArrayElement helper.

<br>
<dt> How do I get timing data from the C output?
<dd> At the top of the generated C file, insert
<pre>
#include &#60;sys/time.h&#62;
</pre>
At the beginning of <code>main()</code> method, insert:
<pre>
struct timespec start, end;
double dT = 0.0;
clock_gettime(CLOCK_REALTIME, &start);
</pre>

Toward the end of <code>main()</code> method, insert:

<pre>
clock_gettime(CLOCK_REALTIME, &end);
dT = end.tv_sec - start.tv_sec + (end.tv_nsec - start.tv_nsec) * 1.0e-9;
printf("execution time: %g seconds\n", dT);
</pre>

You can also get the time resolution of your system by inserting the following code:

<pre>
struct timespec res;
clock_getres(CLOCK_REALTIME, &res);
printf(" time resolution: %ld ns\n", res.tv_nsec);
</pre>

<dt>A test is failing, the output code is confusing, what do I do?</dt>
<dd>
  <p>Try creating the smallest possible test case and run it using
  <code>$PTII/bin/ptcg</code>.</p>
  <p>Try using the <code>-verbosity 10</code> command line argument
  option to <code>$PTII/bin/ptcg</code>.  This will cause the comments
  to include the classname where the comment() method was called.</p>
  <p>By hand, modify the output code so that it works and then change
  the code generator.  For example, if the command is
  <code>$PTII/bin/ptcg -language java Foo.xml</code>, then the file
  to modify will be <code>~/cg/Foo.java</code>.  To compile the file,
  run <code>(cd ~/cg; make -f Foo.mk run)</code>.
  </dd>

  <dt>Porting from ptolemy/codegen</dt>
  <dd>When porting code from ptolemy/codegen, the primary issue is
finding where to put the classes.  Looking at the mapping for
c and java files from codegen to cg can be helpful.  In general,
files that generate language-specific code for actors ends up
in ptolemy.cg.adapater.  Language-specific type code ends up
in ptolemy.cg.kernel.</dd>

</dl>

<h3>Compiling Large C Files</h3>
<pre>
make -f <I>ModelName</I>.mk WARNING_CC_FLAGS= USER_CC_FLAGS="-pipe -O0
--verbose -Q"
</pre>

Each of the options above:
<dl>
<dt> No <CODE>-Wall</CODE>
<dd> avoid any optimization

<dt> <CODE>-pipe</CODE>
<dd> avoid temporary files

<dt> <CODE>-O0</CODE>
<dd> avoid optimization

<dt> <CODE>--verbose</CODE>
<dd> print out steps

<dt> <CODE>-Q</CODE>
<dd> print out summary information.

</dl>

</body>
</html>
