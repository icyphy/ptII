<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="Ideas" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-90.0, -80.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={106, 22, 1090, 684}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[862, 567]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="0.5869239508042874">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{544.8180543087971, 366.77343749999994}">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="#1. WebServer accessor with app logic&#10;at the same hierarchy level. &#10; &#10;responseID is transmitted &#10;as part of data flow.&#10;Routing is explicitly shown.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-180.0, 35.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Ideas on how to architect a web server and web services using accessors.&#10;This model is not intended to run.&#10;">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-10.0, -105.0]">
        </property>
    </property>
    <property name="_layoutConfiguration" class="ptolemy.vergil.basic.layout.ActorLayoutConfiguration">
        <property name="includeDecorations" class="ptolemy.data.expr.Parameter" value="false">
            <display name="Include decorations"/>
        </property>
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="false">
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="AppLogic1 includes requestID &#10;as part of its response.">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-105.0, -85.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="AppLogic1">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="LibraryAccessor is unaware of requestIDs. &#10;requestID must be propagated separately.&#10;(Or, LibraryAccessor must be modified somehow).">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-189.76531982421875, 41.74468994140625]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="LibraryAccessor">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation5" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="#2. WebService composite refinement.&#10;&#10;WebService is a library accessor that &#10;contains the app logic and takes care &#10;of requestID propagation.  The app &#10;logic does not need to be aware&#10;of the requestID.  &#10;WebService could also offer standardized&#10;response creation (both error and normal).&#10;Custom responses are also possible.&#10;Routing is explicit as in #1.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-185.0, 300.0]">
        </property>
    </property>
    <property name="Annotation6" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Open me!">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[40.0, 30.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="WebService1">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation7" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Open me!">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-115.0, 20.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="WebService2">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation8" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="#3.  WebSource accessor, &#10;implementing webServer as a module.&#10;&#10;WebSource is an accessor that require()s a &#10;webServer module and registers a path with this &#10;module.  Routing is implicit.  The module hides &#10;responseIDs and offers standardized response &#10;creation (both error and normal).&#10;Custom responses are also possible.&#10;&#10;WebSource is similar to HttpActor.&#10;(Minus the festival of output ports).&#10;&#10;We would probably want some way to configure &#10;server properties e.g. default timeout, port.&#10;(Similar to the WebServer attribute in Ptolemy).">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-185.0, 560.0]">
        </property>
    </property>
    <property name="Annotation9" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="I have a path property!">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-65.0, -70.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="WebSource">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <entity name="WebServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for HTTP requests&#10; *  on the specified hostInterface and port and issues responses.&#10; *  The hostInterface specifies what network interface (e.g. Ethernet,&#10; *  WiFi, or localhost) to use. The default is 'localhost', which (usually)&#10; *  means that the server listens only for requests coming from the local machine.&#10; *  This is useful for testing. To listen for requests on all IPv4 addresses on&#10; *  the local machine, specify '0.0.0.0'. This will make the server accessible&#10; *  to any machine that has access to an IP address for the local machine.&#10; *&#10; *  When this server receives an http requests from the network (or from&#10; *  the local machine), it produces a JavaScript object on the output that&#10; *  includes at least the following properties:&#10; *  &#10; *  * body: The body of the request, or null if there is no body.&#10; *  * method: A string that describes the HTTP method of the request, which&#10; *    may be &quot;GET&quot;, &quot;PUT&quot;, etc.&#10; *  * path: The path in the URL of the request, such as &quot;/&quot; when there is no&#10; *    path.&#10; *  * requestID: An identifier for the request.&#10; *  &#10; *&#10; *  To produce a response, this accessor waits for an input on its *response*&#10; *  port that is a JavaScript object containing the following properties:&#10; *  &#10; *  * requestID: An identifier matching a request for which a response has not&#10; *    already been issued.&#10; *  * response: The body of the response, such as HTML to display to the&#10; *    requester or a JavaScript object with a JSON representation (the JSON&#10; *    representation will be sent back as the response). If this property is&#10; *    not included in the input, then the input will be stringified as a JSON&#10; *    object and sent. This will include the requestID property.&#10; *  &#10; *&#10; *  If there is no pending request with a matching ID, then an error will be&#10; *  issued.&#10; *  &#10; *  A simple use case is to connect the *request* output to some other actor&#10; *  that generates a response, and then to feed that response back to the&#10; *  *response* input. Be sure to include the requestID property in the response.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the  server.&#10; *&#10; *  This accessor requires the module httpServer.&#10; *&#10; *  @accessor net/WebServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen on.&#10; *&#10; *  @input response The response to issue to a request. &#10; *  @input shutdown Shutdown the web server.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *  @output request The request that came into the server.&#10; *  &#10; *  @author Edward A. Lee amd Elizabeth Osyk&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;&#10;var httpServer = require('@accessors-modules/http-server');&#10;var util = require('util');&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    this.parameter('hostInterface', {&#10;        value: &quot;localhost&quot;,&#10;        type: &quot;string&quot;&#10;    });&#10;    this.parameter('port', {&#10;        value: 80,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.input('response');&#10;    this.output('listening', {'type':'int'});&#10;    this.output('request', {'spontaneous': true});&#10;};&#10;&#10;/** Starts the server.&#10; */&#10;exports.initialize = function() {&#10;    var self = this;&#10;    &#10;    if (!self.server) {&#10;        console.log('WebServer: Creating new server.');&#10;        self.server = new httpServer.HttpServer({&#10;                'port': self.getParameter('port'),&#10;                'hostInterface': self.getParameter('hostInterface')&#10;        });&#10;        // Using 'self.exports' rather than just 'exports' in the following allows&#10;        // these functions to be overridden in derived accessors.&#10;        self.server.on('listening', self.exports.onListening.bind(self));&#10;        self.server.on('request', self.exports.request.bind(self));&#10;        self.server.on('error', function (message) {&#10;            self.error(message);&#10;        });&#10;        self.server.start();&#10;    }&#10;&#10;    self.addInputHandler('response', function() {&#10;        var response = self.get('response');&#10;        if (!response.hasOwnProperty('requestID')) {&#10;            error('Response has no requestID property.');&#10;            return;&#10;        }&#10;        var id = response.requestID;&#10;        if (!self.pendingRequests.hasOwnProperty(id)) {&#10;            error('No pending request with ID ' + id);&#10;            return;&#10;        }&#10;        delete self.pendingRequests[id];&#10;        // Default body of the response is the whole response object.&#10;        var body = response;&#10;        if (response.hasOwnProperty('response')) {&#10;            body = response.response;&#10;        }&#10;        if (typeof body !== 'string') {&#10;            body = JSON.stringify(body);&#10;        }&#10;        if (response.hasOwnProperty('responseCode')) {&#10;        	this.server.respond(response.requestID, body, response.responseCode);&#10;        } else {&#10;        	this.server.respond(response.requestID, body);&#10;        }&#10;    });&#10;    &#10;    // Initialize pendingRequests to an empty object.&#10;    self.pendingRequests = {};&#10;};&#10;&#10;exports.onListening = function() {&#10;    console.log('WebServer: Listening for requests.');&#10;    this.send('listening', this.getParameter('port'));&#10;};&#10;&#10;exports.request = function(request) {&#10;	console.log('Server received request.');&#10;    // console.log('Server received request: ' + util.inspect(request));&#10;    if (this.server) {&#10;        this.send('request', request);&#10;        this.pendingRequests[request.requestID] = request;&#10;    } else {&#10;        console.log('WARNING: server does not exist.');&#10;    }&#10;};&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server.&#10; */&#10;exports.wrapup = function(){&#10;    if (this.server !== null &amp;&amp; typeof this.server !== 'undefined') {&#10;        console.log('WebServer: Stopping the server.');&#10;        this.server.removeAllListeners();&#10;        this.server.stop();&#10;        this.server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/WebServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor starts a server that listens for HTTP requests&#10; on the specified hostInterface and port and issues responses.&#10; The hostInterface specifies what network interface (e.g. Ethernet,&#10; WiFi, or localhost) to use. The default is 'localhost', which (usually)&#10; means that the server listens only for requests coming from the local machine.&#10; This is useful for testing. To listen for requests on all IPv4 addresses on&#10; the local machine, specify '0.0.0.0'. This will make the server accessible&#10; to any machine that has access to an IP address for the local machine.&lt;/p&gt;&#10;&lt;p&gt; When this server receives an http requests from the network (or from&#10; the local machine), it produces a JavaScript object on the output that&#10; includes at least the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;body: The body of the request, or null if there is no body.&lt;/li&gt;&#10;&lt;li&gt;method: A string that describes the HTTP method of the request, which&#10;may be &amp;quot;GET&amp;quot;, &amp;quot;PUT&amp;quot;, etc.&lt;/li&gt;&#10;&lt;li&gt;path: The path in the URL of the request, such as &amp;quot;/&amp;quot; when there is no&#10;path.&lt;/li&gt;&#10;&lt;li&gt;requestID: An identifier for the request.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; To produce a response, this accessor waits for an input on its &lt;em&gt;response&lt;/em&gt;&#10; port that is a JavaScript object containing the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;requestID: An identifier matching a request for which a response has not&#10;already been issued.&lt;/li&gt;&#10;&lt;li&gt;response: The body of the response, such as HTML to display to the&#10;requester or a JavaScript object with a JSON representation (the JSON&#10;representation will be sent back as the response). If this property is&#10;not included in the input, then the input will be stringified as a JSON&#10;object and sent. This will include the requestID property.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; If there is no pending request with a matching ID, then an error will be&#10; issued.&lt;/p&gt;&#10;&lt;p&gt; A simple use case is to connect the &lt;em&gt;request&lt;/em&gt; output to some other actor&#10; that generates a response, and then to feed that response back to the&#10; &lt;em&gt;response&lt;/em&gt; input. Be sure to include the requestID property in the response.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  server.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the module httpServer.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee amd Elizabeth Osyk">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="response (port)" class="ptolemy.kernel.util.StringAttribute" value="The response to issue to a request.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on">
            </property>
            <property name="request (port)" class="ptolemy.kernel.util.StringAttribute" value="The request that came into the server.">
            </property>
            <property name="requestURI (port)" class="ptolemy.kernel.util.StringAttribute" value="FIXME">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of the&#10;   network interface to listen to.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to listen on.">
            </property>
            <property name="shutdown (port)" class="ptolemy.kernel.util.StringAttribute" value="Shutdown the web server.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 20.0]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="multiport"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="AppLogic1" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('request');&#10;	this.output('response');&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('request', function() {&#10;		var request = self.get('request');&#10;		var response = {&#10;			requestID: request.requestID,&#10;			response: &quot;&lt;H1&gt;Hello World&lt;/H1&gt;&quot;&#10;		};&#10;		self.send('response', response);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[445.0, 20.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Router" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[230.0, 30.0]">
        </property>
        <port name="path1" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="path2" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="LibraryAccessor" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[314.76531982421875, 113.25531005859375]">
        </property>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="RecordDisassembler" class="ptolemy.actor.lib.RecordDisassembler">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[169.76531982421875, 83.25531005859375]">
        </property>
        <port name="requestID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="requestData" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RecordAssembler" class="ptolemy.actor.lib.RecordAssembler">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[444.76531982421875, 83.25531005859375]">
        </property>
        <port name="requestID" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="responsedata" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="WebServer2" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for HTTP requests&#10; *  on the specified hostInterface and port and issues responses.&#10; *  The hostInterface specifies what network interface (e.g. Ethernet,&#10; *  WiFi, or localhost) to use. The default is 'localhost', which (usually)&#10; *  means that the server listens only for requests coming from the local machine.&#10; *  This is useful for testing. To listen for requests on all IPv4 addresses on&#10; *  the local machine, specify '0.0.0.0'. This will make the server accessible&#10; *  to any machine that has access to an IP address for the local machine.&#10; *&#10; *  When this server receives an http requests from the network (or from&#10; *  the local machine), it produces a JavaScript object on the output that&#10; *  includes at least the following properties:&#10; *  &#10; *  * body: The body of the request, or null if there is no body.&#10; *  * method: A string that describes the HTTP method of the request, which&#10; *    may be &quot;GET&quot;, &quot;PUT&quot;, etc.&#10; *  * path: The path in the URL of the request, such as &quot;/&quot; when there is no&#10; *    path.&#10; *  * requestID: An identifier for the request.&#10; *  &#10; *&#10; *  To produce a response, this accessor waits for an input on its *response*&#10; *  port that is a JavaScript object containing the following properties:&#10; *  &#10; *  * requestID: An identifier matching a request for which a response has not&#10; *    already been issued.&#10; *  * response: The body of the response, such as HTML to display to the&#10; *    requester or a JavaScript object with a JSON representation (the JSON&#10; *    representation will be sent back as the response). If this property is&#10; *    not included in the input, then the input will be stringified as a JSON&#10; *    object and sent. This will include the requestID property.&#10; *  &#10; *&#10; *  If there is no pending request with a matching ID, then an error will be&#10; *  issued.&#10; *  &#10; *  A simple use case is to connect the *request* output to some other actor&#10; *  that generates a response, and then to feed that response back to the&#10; *  *response* input. Be sure to include the requestID property in the response.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the  server.&#10; *&#10; *  This accessor requires the module httpServer.&#10; *&#10; *  @accessor net/WebServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen on.&#10; *&#10; *  @input response The response to issue to a request. &#10; *  @input shutdown Shutdown the web server.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *  @output request The request that came into the server.&#10; *  &#10; *  @author Edward A. Lee amd Elizabeth Osyk&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;&#10;var httpServer = require('@accessors-modules/http-server');&#10;var util = require('util');&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    this.parameter('hostInterface', {&#10;        value: &quot;localhost&quot;,&#10;        type: &quot;string&quot;&#10;    });&#10;    this.parameter('port', {&#10;        value: 80,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.input('response');&#10;    this.output('listening', {'type':'int'});&#10;    this.output('request', {'spontaneous': true});&#10;};&#10;&#10;/** Starts the server.&#10; */&#10;exports.initialize = function() {&#10;    var self = this;&#10;    &#10;    if (!self.server) {&#10;        console.log('WebServer: Creating new server.');&#10;        self.server = new httpServer.HttpServer({&#10;                'port': self.getParameter('port'),&#10;                'hostInterface': self.getParameter('hostInterface')&#10;        });&#10;        // Using 'self.exports' rather than just 'exports' in the following allows&#10;        // these functions to be overridden in derived accessors.&#10;        self.server.on('listening', self.exports.onListening.bind(self));&#10;        self.server.on('request', self.exports.request.bind(self));&#10;        self.server.on('error', function (message) {&#10;            self.error(message);&#10;        });&#10;        self.server.start();&#10;    }&#10;&#10;    self.addInputHandler('response', function() {&#10;        var response = self.get('response');&#10;        if (!response.hasOwnProperty('requestID')) {&#10;            error('Response has no requestID property.');&#10;            return;&#10;        }&#10;        var id = response.requestID;&#10;        if (!self.pendingRequests.hasOwnProperty(id)) {&#10;            error('No pending request with ID ' + id);&#10;            return;&#10;        }&#10;        delete self.pendingRequests[id];&#10;        // Default body of the response is the whole response object.&#10;        var body = response;&#10;        if (response.hasOwnProperty('response')) {&#10;            body = response.response;&#10;        }&#10;        if (typeof body !== 'string') {&#10;            body = JSON.stringify(body);&#10;        }&#10;        if (response.hasOwnProperty('responseCode')) {&#10;        	this.server.respond(response.requestID, body, response.responseCode);&#10;        } else {&#10;        	this.server.respond(response.requestID, body);&#10;        }&#10;    });&#10;    &#10;    // Initialize pendingRequests to an empty object.&#10;    self.pendingRequests = {};&#10;};&#10;&#10;exports.onListening = function() {&#10;    console.log('WebServer: Listening for requests.');&#10;    this.send('listening', this.getParameter('port'));&#10;};&#10;&#10;exports.request = function(request) {&#10;	console.log('Server received request.');&#10;    // console.log('Server received request: ' + util.inspect(request));&#10;    if (this.server) {&#10;        this.send('request', request);&#10;        this.pendingRequests[request.requestID] = request;&#10;    } else {&#10;        console.log('WARNING: server does not exist.');&#10;    }&#10;};&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server.&#10; */&#10;exports.wrapup = function(){&#10;    if (this.server !== null &amp;&amp; typeof this.server !== 'undefined') {&#10;        console.log('WebServer: Stopping the server.');&#10;        this.server.removeAllListeners();&#10;        this.server.stop();&#10;        this.server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/WebServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor starts a server that listens for HTTP requests&#10; on the specified hostInterface and port and issues responses.&#10; The hostInterface specifies what network interface (e.g. Ethernet,&#10; WiFi, or localhost) to use. The default is 'localhost', which (usually)&#10; means that the server listens only for requests coming from the local machine.&#10; This is useful for testing. To listen for requests on all IPv4 addresses on&#10; the local machine, specify '0.0.0.0'. This will make the server accessible&#10; to any machine that has access to an IP address for the local machine.&lt;/p&gt;&#10;&lt;p&gt; When this server receives an http requests from the network (or from&#10; the local machine), it produces a JavaScript object on the output that&#10; includes at least the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;body: The body of the request, or null if there is no body.&lt;/li&gt;&#10;&lt;li&gt;method: A string that describes the HTTP method of the request, which&#10;may be &amp;quot;GET&amp;quot;, &amp;quot;PUT&amp;quot;, etc.&lt;/li&gt;&#10;&lt;li&gt;path: The path in the URL of the request, such as &amp;quot;/&amp;quot; when there is no&#10;path.&lt;/li&gt;&#10;&lt;li&gt;requestID: An identifier for the request.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; To produce a response, this accessor waits for an input on its &lt;em&gt;response&lt;/em&gt;&#10; port that is a JavaScript object containing the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;requestID: An identifier matching a request for which a response has not&#10;already been issued.&lt;/li&gt;&#10;&lt;li&gt;response: The body of the response, such as HTML to display to the&#10;requester or a JavaScript object with a JSON representation (the JSON&#10;representation will be sent back as the response). If this property is&#10;not included in the input, then the input will be stringified as a JSON&#10;object and sent. This will include the requestID property.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; If there is no pending request with a matching ID, then an error will be&#10; issued.&lt;/p&gt;&#10;&lt;p&gt; A simple use case is to connect the &lt;em&gt;request&lt;/em&gt; output to some other actor&#10; that generates a response, and then to feed that response back to the&#10; &lt;em&gt;response&lt;/em&gt; input. Be sure to include the requestID property in the response.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  server.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the module httpServer.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee amd Elizabeth Osyk">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="response (port)" class="ptolemy.kernel.util.StringAttribute" value="The response to issue to a request.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on">
            </property>
            <property name="request (port)" class="ptolemy.kernel.util.StringAttribute" value="The request that came into the server.">
            </property>
            <property name="requestURI (port)" class="ptolemy.kernel.util.StringAttribute" value="FIXME">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of the&#10;   network interface to listen to.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to listen on.">
            </property>
            <property name="shutdown (port)" class="ptolemy.kernel.util.StringAttribute" value="Shutdown the web server.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[175.0, 330.0]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="multiport"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Router2" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[300.0, 340.0]">
        </property>
        <port name="path1" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="path2" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="WebService1" class="ptolemy.actor.TypedCompositeActor">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[415.0, 330.0]">
        </property>
        <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
            <property name="text" class="ptolemy.kernel.util.StringAttribute" value="WebService will internally strip off the requestID&#10;at the input, remember it, then append it to the&#10;response data for output.&#10;&#10;It could also offer standardized response page &#10;and error page creation.">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[35.0, 25.0]">
            </property>
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{20.0, 200.0}">
            </property>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[370.0, 200.0]">
            </property>
        </port>
        <entity name="AppLogic" class="ptolemy.actor.lib.jjs.JavaScript">
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
            </property>
            <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
            </property>
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{180, 200}">
            </property>
            <port name="data" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="responseData" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
        </entity>
        <relation name="relation" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        </relation>
        <link port="request" relation="relation"/>
        <link port="response" relation="relation2"/>
        <link port="AppLogic.data" relation="relation"/>
        <link port="AppLogic.responseData" relation="relation2"/>
    </entity>
    <entity name="WebService2" class="ptolemy.actor.TypedCompositeActor">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[415.0, 410.0]">
        </property>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={219, 75, 928, 617}, maximized=false}">
        </property>
        <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 500]">
        </property>
        <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
        </property>
        <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{347.0, 416.21875}">
        </property>
        <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
            <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Library accessors can be used without modification.&#10;&#10;WebService will internally strip off the requestID&#10;at the input, remember it, then append it to the&#10;response data for output.&#10;&#10;It could also offer standardized response page &#10;and error page creation.">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[75.0, 200.0]">
            </property>
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[95.0, 400.0]">
            </property>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[355.0, 400.0]">
            </property>
        </port>
        <entity name="LibraryAccessor" class="ptolemy.actor.lib.jjs.JavaScript">
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
            </property>
            <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
            </property>
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[215.0, 400.0]">
            </property>
            <port name="requestData" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="responseData" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
        </entity>
        <relation name="relation" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        </relation>
        <link port="request" relation="relation"/>
        <link port="response" relation="relation2"/>
        <link port="LibraryAccessor.requestData" relation="relation"/>
        <link port="LibraryAccessor.responseData" relation="relation2"/>
    </entity>
    <entity name="WebSource" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[255.0, 690.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="AppLogic" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('request');&#10;	this.output('response');&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('request', function() {&#10;		var request = self.get('request');&#10;		var response = {&#10;			requestID: request.requestID,&#10;			response: &quot;&lt;H1&gt;Hello World&lt;/H1&gt;&quot;&#10;		};&#10;		self.send('response', response);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[395.0, 690.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[530.0, 245.0]">
        </vertex>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[500.0, 225.0]">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[555.0, 485.0]">
        </vertex>
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[470.0, 465.0]">
        </vertex>
    </relation>
    <relation name="relation13" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation12" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation14" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation15" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[445.0, 755.0]">
        </vertex>
    </relation>
    <link port="WebServer.response" relation="relation5"/>
    <link port="WebServer.response" relation="relation"/>
    <link port="WebServer.request" relation="relation4"/>
    <link port="AppLogic1.request" relation="relation2"/>
    <link port="AppLogic1.response" relation="relation"/>
    <link port="Router.path1" relation="relation2"/>
    <link port="Router.path2" relation="relation3"/>
    <link port="Router.request" relation="relation4"/>
    <link port="LibraryAccessor.response" relation="relation7"/>
    <link port="LibraryAccessor.request" relation="relation6"/>
    <link port="RecordDisassembler.input" relation="relation3"/>
    <link port="RecordDisassembler.requestID" relation="relation8"/>
    <link port="RecordDisassembler.requestData" relation="relation6"/>
    <link port="RecordAssembler.output" relation="relation5"/>
    <link port="RecordAssembler.requestID" relation="relation8"/>
    <link port="RecordAssembler.responsedata" relation="relation7"/>
    <link port="WebServer2.response" relation="relation11"/>
    <link port="WebServer2.response" relation="relation9"/>
    <link port="WebServer2.request" relation="relation13"/>
    <link port="Router2.path1" relation="relation10"/>
    <link port="Router2.path2" relation="relation12"/>
    <link port="Router2.request" relation="relation13"/>
    <link port="WebService1.request" relation="relation10"/>
    <link port="WebService1.response" relation="relation9"/>
    <link port="WebService2.request" relation="relation12"/>
    <link port="WebService2.response" relation="relation11"/>
    <link port="WebSource.request" relation="relation14"/>
    <link port="WebSource.response" relation="relation15"/>
    <link port="AppLogic.request" relation="relation14"/>
    <link port="AppLogic.response" relation="relation15"/>
</entity>
