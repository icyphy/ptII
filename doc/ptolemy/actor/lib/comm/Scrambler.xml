<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="Scrambler" class="ptolemy.actor.lib.comm.Scrambler">
  <description>
Scramble the input bit sequence using a feedback shift register.&#10; The initial state of the shift register is given by the &lt;i&gt;initialState&lt;/i&gt;&#10; parameter, which should be a non-negative integer.&#10; The taps of the feedback shift register are given by the &lt;i&gt;polynomial&lt;/i&gt;&#10; parameter, which should be a positive integer.&#10; The n-th bit of this integer indicates whether the n-th tap of the delay&#10; line is fed back.&#10; The low-order bit is called the 0-th bit, and should always be set.&#10; The next low-order bit indicates whether the output of the first delay&#10; should be fed back, etc.&#10; The input port receives boolean tokens. &quot;TRUE&quot; is treated as 1 and &quot;FALSE&quot;&#10; is treated as 0. All the bits that are fed back are exclusive-ored together&#10; (i.e., their parity is computed), and the result is exclusive-ored with the&#10; input bit. The result is produced at the output and shifted into the delay line.&#10; &lt;p&gt;&#10; With a proper choice of polynomial, the resulting output appears highly&#10; random even if the input is highly non-random.&#10; If the polynomial is a &lt;i&gt;primitive polynomial&lt;/i&gt;, then the feedback&#10; shift register is a so-called &lt;i&gt;maximal length feedback shift register&lt;/i&gt;.&#10; This means that with a constant input (or no input, which is equivalent&#10; to a constant &lt;i&gt;false&lt;/i&gt; input) the output will be a sequence with&#10; period 2&lt;sup&gt;&lt;i&gt;N&lt;/i&gt;&lt;/sup&gt;-1, where &lt;i&gt;N&lt;/i&gt; is the order of the&#10; polynomial (the length of the shift register).&#10; This is the longest possible sequence.&#10; Moreover, within this period, the sequence will appear to be white,&#10; in that a computed autocorrelation will be very nearly an impulse.&#10; Thus, the scrambler with a constant input can be very effectively used&#10; to generate a pseudo-random bit sequence.&#10; &lt;p&gt;&#10; The maximal-length feedback shift register with constant input will&#10; pass through 2&lt;sup&gt;&lt;i&gt;N&lt;/i&gt;&lt;/sup&gt;-1 states before returning to a state&#10; it has been in before.  This is one short of the 2&lt;sup&gt;&lt;i&gt;N&lt;/i&gt;&lt;/sup&gt;&#10; states that a register with &lt;i&gt;N&lt;/i&gt; bits can take on.  This one missing&#10; state, in fact, is a &lt;i&gt;lock-up&lt;/i&gt; state, in that if the input is&#10; an appropriate constant, the scrambler will cease to produce random-looking&#10; output, and will output a constant. For example, if the input is all zeros,&#10; and the initial state of the scrambler is zero, then the outputs will be all&#10; zero, hardly random. This is easily avoided by initializing the scrambler&#10; to some non-zero state. The default value for the &lt;i&gt;shiftReg&lt;/i&gt; is set to 1.&#10; &lt;p&gt;&#10; The &lt;i&gt;polynomial&lt;/i&gt; must be carefully chosen. It must represent a&#10; &lt;i&gt;primitive polynomial&lt;/i&gt;, which is one that cannot be factored into two&#10; (nontrivial) polynomials with binary coefficients.  See Lee and Messerschmitt&#10; (Kluwer, 1994) for more details.  For convenience, we give here&#10; a set of primitive polynomials&#10; (expressed as octal numbers so that they are easily translated into taps&#10; on shift register).  All of these will result in maximal-length pseudo-random&#10; sequences if the input is constant and lock-up is avoided:&#10; &lt;pre&gt;&#10; order    polynomial&#10; 2        07&#10; 3        013&#10; 4        023&#10; 5        045&#10; 6        0103&#10; 7        0211&#10; 8        0435&#10; 9        01021&#10; 10       02011&#10; 11       04005&#10; 12       010123&#10; 13       020033&#10; 14       042103&#10; 15       0100003&#10; 16       0210013&#10; 17       0400011&#10; 18       01000201&#10; 19       02000047&#10; 20       04000011&#10; 21       010000005&#10; 22       020000003&#10; 23       040000041&#10; 24       0100000207&#10; 25       0200000011&#10; 26       0400000107&#10; 27       01000000047&#10; 28       02000000011&#10; 29       04000000005&#10; 30       010040000007&#10; &lt;/pre&gt;&#10; &lt;p&gt;&#10; The leading zero in the polynomial indicates an octal number.&#10; Note also that reversing the order of the bits in any of these numbers&#10; will also result in a primitive polynomial.&#10; Thus, the default value for the polynomial parameter&#10; is 0440001 in octal, or &quot;100 100 000 000 000 001&quot; in binary.&#10; Reversing these bits we get &quot;100 000 000 000 001 001&quot; in binary, or&#10; 0400011 in octal.&#10; This latter number is the one listed above as the primitive polynomial&#10; of order 17.&#10; The order is simply the index of the highest-order non-zero in the polynomial,&#10; where the low-order bit has index zero.&#10; &lt;p&gt;&#10; Since the polynomial and the feedback shift register are both implemented&#10; using type &quot;int&quot;, the order of the polynomial is limited by the size of&#10; the &quot;int&quot; data type.&#10; For simplicity and portability, the polynomial is not allowed to be&#10; interpreted as a negative integer, so the sign bit cannot be used.&#10; Thus, if &quot;int&quot; is a 32-bit word, then the highest order polynomial allowed&#10; is 30 (recall that indexing for the order starts at zero, and we cannot&#10; use the sign bit).&#10; Java has 32-bit integers, so we give the primitive&#10; polynomials above only up to order 30.&#10; &lt;p&gt;&#10; For more information on scrambler, see Lee and Messerschmitt, Digital&#10; Communication, Second Edition, Kluwer Academic Publishers, 1994, pp. 595-603.&#10; &lt;p&gt;  </description>
  <author>Edward A. Lee and Ye Zhou</author>
  <version>$Id$</version>
  <since>Ptolemy II 3.0</since>
  <Pt.ProposedRating>Red (eal)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (cxh)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="polynomial">Integer defining a polynomial with binary coefficients.&#10;  The coefficients indicate the presence (1) or absence (0)&#10;  of a tap in a feedback shift register. This parameter should&#10;  contain a positive integer with the lower-order bit being 1.&#10;  Its default value is the integer 0440001.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="initialState">Integer defining the initial state of the shift register.&#10;  The n-th bit of the integer indicates the value of the&#10;  n-th register. This parameter should be a non-negative&#10;  integer. Its default value is the integer 1.</property>
</doc>
