<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="TCPSocketTwoClients" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={4, 23, 1162, 636}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[928, 526]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0754349689848202">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{283.80404974489795, 147.08457054696882}">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="50">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-90.0, -65.0}">
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Demonstrate sending to two distinct clients.&#10;One gets even numbers, the other gets odd numbers.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-25.0, -95.0}">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Server is set to find an&#10;available port. It informs&#10;the clients of the port.&#10;Only then do they open&#10;a connection.">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[100.0, 30.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="TCPSocketServer">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This MicrostepDelay ensures that&#10;TCPSocketClient2 gets ID == 2.">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[25.0, 10.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="MicrostepDelay">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Upon receiving two connections, start sending them messages.">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-190.0, 40.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="DownSample">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation5" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="The JavaScriptBarrier has a timeout &#10;that is set to the same time as&#10;the stopTime of the DE Director.">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-30.0, -100.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="JavaScriptBarrier">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <entity name="TCPSocketClient1" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. If the value of the `port` input is initially&#10; *  negative, then this accessor waits until it receives a non-negative `port`&#10; *  input before making a connection. Otherwise,&#10; *  upon initialization, it initiates a connection to the&#10; *  specified server. If at any time during execution it receives&#10; *  a 'port' input, then it will close any open socket and, if the new&#10; *  'port' value is non-negative, open&#10; *  a new socket to the current 'host' and 'port'.&#10; *&#10; *  When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output. If the connection is broken during execution, then a `false`&#10; *  boolean is sent to the `connected` output. The swarmlet could respond to this by&#10; *  retrying to connect (send an event to either the `port` or `host` input).&#10; *&#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when a socket next opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the  connection.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  [https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3](https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3).&#10; *&#10; *  For numeric types, you can also send an array all at once by providing an&#10; *  array to the `toSend` input port.&#10; *  The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @input {int} port The port on the server to connect to. Defaults to -1, which means&#10; *   wait for a non-negative input before connecting.&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to this.send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the password for the pfx key-cert&#10; *    file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the fully qualified filename for&#10; *    the file that stores the private key and certificate that this client will use to authenticate&#10; *    itself to the server. This path can be any of those understood by the Ptolemy host,&#10; *    e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to this.send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    this.send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 1000 (1 second).&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and trustAll is&#10; *    set to false, then this option needs to specify the fully qualified filename&#10; *    for the file that stores the certificate of a certificate authority (CA) that&#10; *    this client will use to verify server certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim, Contributor: Matt Weber&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global console, error, exports, getParameter, require */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('@accessors-modules/socket');&#10;var openSocket = false; // state variable used for isOpen function.&#10;var client = null;&#10;var running = false;&#10;var pendingSends = [];&#10;var previousHost, previousPort;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    // console.log('TCPSocketClient.js: setup() start');&#10;    this.input('host', {&#10;        type: 'string',&#10;        value: 'localhost'&#10;    });&#10;    this.input('port', {&#10;        type: 'int',&#10;        value: -1&#10;    });&#10;    // This input is added after host and port so that if there are&#10;    // simultaneous inputs, host and port are handled first.&#10;    this.input('toSend');&#10;&#10;    this.output('connected', {&#10;        type: 'boolean'&#10;    });&#10;    this.output('received');&#10;&#10;    // The parameters are in alphabetical order.&#10;    this.parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('discardMessagesBeforeOpen', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('keepAlive', {&#10;        type: 'boolean',&#10;        value: true&#10;    });&#10;    this.parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('noDelay', {&#10;        type: 'boolean',&#10;        value: true&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    this.parameter('rawBytes', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type: 'string',&#10;        value: 'string'&#10;    });&#10;    this.parameter('reconnectAttempts', {&#10;        type: 'int',&#10;        value: 10&#10;    });&#10;    this.parameter('reconnectInterval', {&#10;        type: 'int',&#10;        value: 1000&#10;    });&#10;    this.parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('sendType', {&#10;        type: 'string',&#10;        value: 'string'&#10;    });&#10;    this.parameter('sslTls', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('trustAll', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('trustedCACertPath', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options: socket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options: socket.supportedSendTypes()&#10;        });&#10;    } catch (err) {&#10;        this.error(err);&#10;    }&#10;    // console.log('TCPSocketClient.js: setup() end');&#10;};&#10;&#10;&#10;/** Send the specified data if the client is set and open,&#10; *  reconnect the client if the socket is closed, and otherwise either&#10; *  discard or queue the data to send later depending on the value of&#10; *  `discardMessagesBeforeOpen`.&#10; */&#10;exports.send = function (data) {&#10;    // console.log('TCPSocketClient.js: send()');&#10;    // May be receiving inputs before client has been set.&#10;&#10;    if (client &amp;&amp; exports.isOpen()) {&#10;        client.send(data);&#10;    } else {&#10;        if (client) {&#10;            // In case the server has closed the socket, reconnect.&#10;            this.exports.connect.call(this);&#10;            client.send(data);&#10;        } else {&#10;            if (!getParameter('discardMessagesBeforeOpen')) {&#10;                var maxUnsentMessages = getParameter('maxUnsentMessages');&#10;&#10;                if (maxUnsentMessages &gt; 0 &amp;&amp; pendingSends.length &gt;= maxUnsentMessages) {&#10;                    this.error(&quot;Maximum number of unsent messages has been exceeded: &quot; +&#10;                        maxUnsentMessages +&#10;                        &quot;. Consider setting discardMessagesBeforeOpen to true.&quot;);&#10;                    return;&#10;                }&#10;                pendingSends.push(data);&#10;            } else {&#10;                console.log('Discarding data because TCP Socket Client has not yet been set up.');&#10;            }&#10;        }&#10;    }&#10;};&#10;&#10;/** Handle input on 'toSend' by sending the specified data to the server. */&#10;exports.toSendInputHandler = function () {&#10;    // console.log('TCPSocketClient.js: toSendInputHandler()');&#10;    this.exports.send.call(this, this.get('toSend'));&#10;};&#10;&#10;/** Set up input handlers, and if the current value of the 'port' input is&#10; *  non-negative, initiate a connection to the server using the&#10; *  current parameter values, and&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server.&#10; */&#10;exports.initialize = function () {&#10;    // console.log('TCPSocketClient.js: initialize()');&#10;    this.addInputHandler('host', this.exports.connect.bind(this));&#10;    this.addInputHandler('port', this.exports.connect.bind(this));&#10;    this.addInputHandler('toSend', this.exports.toSendInputHandler.bind(this));&#10;    this.exports.connect.call(this);&#10;    running = true;&#10;};&#10;&#10;&#10;/** Function is called by client when data has been received over the connection.&#10; *   This has been refactored out of exports.connect to facilitate overriding by an&#10; *   extending accessor.&#10; */&#10;exports.dataReceivedHandler = function (data) {&#10;    // console.log('TCPSocketClient.js: dataReceiveHandler() data: ' + data);&#10;    this.send('received', data);&#10;};&#10;&#10;/** Initiate a connection to the server using the current parameter values,&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server, and set up a handler for inputs&#10; *  on the toSend() input port.&#10; */&#10;exports.connect = function () {&#10;    // console.log('TCPSocketClient.js: connect()');&#10;    // Note that if 'host' and 'port' both receive new data in the same&#10;    // reaction, then this will be invoked twice. But we only want to open&#10;    // the socket once.  This is fairly tricky.&#10;&#10;    var portValue = this.get('port');&#10;    if (portValue &lt; 0) {&#10;        // No port is specified. This could be a signal to close a previously&#10;        // open socket.&#10;        if (client &amp;&amp; exports.isOpen()) {&#10;            client.close();&#10;        }&#10;        previousPort = null;&#10;        previousHost = null;&#10;        return;&#10;    }&#10;&#10;    var hostValue = this.get('host');&#10;    if (previousHost === hostValue &amp;&amp; previousPort === portValue) {&#10;        // A request to open a client for this host/port pair has already&#10;        // been made and has not yet been closed or failed with an error.&#10;        return;&#10;    }&#10;    // Record the host/port pair that we are now opening.&#10;    previousHost = hostValue;&#10;    previousPort = portValue;&#10;&#10;    if (client &amp;&amp; exports.isOpen()) {&#10;        // Either the host or the port has changed. Close the previous socket.&#10;        client.close();&#10;    }&#10;    // Create a new SocketClient.&#10;    client = new socket.SocketClient(portValue, hostValue, {&#10;        'connectTimeout': this.getParameter('connectTimeout'),&#10;        'discardMessagesBeforeOpen': this.getParameter('discardMessagesBeforeOpen'),&#10;        'idleTimeout': this.getParameter('idleTimeout'),&#10;        'keepAlive': this.getParameter('keepAlive'),&#10;        'maxUnsentMessages': this.getParameter('maxUnsentMessages'),&#10;        'noDelay': this.getParameter('noDelay'),&#10;        'pfxKeyCertPassword': this.getParameter('pfxKeyCertPassword'),&#10;        'pfxKeyCertPath': this.getParameter('pfxKeyCertPath'),&#10;        'rawBytes': this.getParameter('rawBytes'),&#10;        'receiveBufferSize': this.getParameter('receiveBufferSize'),&#10;        'receiveType': this.getParameter('receiveType'),&#10;        'reconnectAttempts': this.getParameter('reconnectAttempts'),&#10;        'reconnectInterval': this.getParameter('reconnectInterval'),&#10;        'sendBufferSize': this.getParameter('sendBufferSize'),&#10;        'sendType': this.getParameter('sendType'),&#10;        'sslTls': this.getParameter('sslTls'),&#10;        'trustAll': this.getParameter('trustAll'),&#10;        'trustedCACertPath': this.getParameter('trustedCACertPath')&#10;    });&#10;&#10;    var self = this;&#10;&#10;    client.on('open', function () {&#10;        // console.log('TCPSocketClient: open: Connection established');&#10;        self.send('connected', true);&#10;&#10;        // If there are pending sends, send them now.&#10;        // Note this implementation requires that the host invoke&#10;        // this callback function atomically w.r.t. the input handler&#10;        // that adds messages to the pendingSends queue.&#10;        for (var i = 0; i &lt; pendingSends.length; i++) {&#10;            client.send(pendingSends[i]);&#10;        }&#10;        pendingSends = [];&#10;        openSocket = true; //Update state variable&#10;    });&#10;    client.on('data', self.exports.dataReceivedHandler.bind(self));&#10;    client.on('close', function () {&#10;        // console.log('TCPSocketClient: close');&#10;        previousHost = null;&#10;        previousPort = null;&#10;        // console.log('Connection closed.');&#10;        // NOTE: Even if running is true, it can occur that it is too late&#10;        // to send the message (the wrapup process has been started), in which case&#10;        // the message may not be received.&#10;        if (running) {&#10;            self.send('connected', false);&#10;        }&#10;        openSocket = false; //Update state variable&#10;    });&#10;    client.on('error', function (message) {&#10;        // console.log('TCPSocketClient: error: ' + error);&#10;        previousHost = null;&#10;        previousPort = null;&#10;        self.error(message);&#10;    });&#10;&#10;    client.open();&#10;    // console.log('TCPSocketClient.js: connect() end');&#10;};&#10;&#10;/** Return true if this client has an open connection to the server. */&#10;exports.isOpen = function () {&#10;    // console.log('TCPSocketClient.js: isOpen()');&#10;    return openSocket;&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    // console.log('TCPSocketClient.js: wrapup()');&#10;    running = false;&#10;    if (client) {&#10;        client.close();&#10;        // console.log('Status: Connection closed in wrapup.');&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/TCPSocketClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{240.0, 10.0}">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a TCP socket at&#10; the specified host and port. If the value of the &lt;code&gt;port&lt;/code&gt; input is initially&#10; negative, then this accessor waits until it receives a non-negative &lt;code&gt;port&lt;/code&gt;&#10; input before making a connection. Otherwise,&#10; upon initialization, it initiates a connection to the&#10; specified server. If at any time during execution it receives&#10; a 'port' input, then it will close any open socket and, if the new&#10; 'port' value is non-negative, open&#10; a new socket to the current 'host' and 'port'.&lt;/p&gt;&#10;&lt;p&gt; When the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output. If the connection is broken during execution, then a &lt;code&gt;false&lt;/code&gt;&#10; boolean is sent to the &lt;code&gt;connected&lt;/code&gt; output. The swarmlet could respond to this by&#10; retrying to connect (send an event to either the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt; input).&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt; input,&#10; the data on that input is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when a socket next opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;received&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  connection.&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3&quot;&gt;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array all at once by providing an&#10; array to the &lt;code&gt;toSend&lt;/code&gt; input port.&#10; The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item provided on &lt;code&gt;toSend&lt;/code&gt;,&#10; of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'socket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim, Contributor: Matt Weber">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="host (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to 4000.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time to wait (in milliseconds) before declaring&#10;   a connection attempt to have failed. This defaults to 6000.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any messages&#10;   passed to SocketClient.send() before the socket is opened. If false,&#10;   then queue the messages to be sent when the socket opens. This&#10;   defaults to false.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="maxUnsentMessages (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The maximum number of unsent messages to queue before&#10;   further calls to this.send() will fail. A value of 0 means no limit.&#10;   This defaults to 100.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available (the default).&#10;   If false, data may be accumulated until a reasonable packet size is formed&#10;   in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="reconnectAttempts (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The number of times to try to reconnect.&#10;   If this is greater than 0, then a failure to attempt will trigger&#10;   additional attempts. This defaults to 10.">
            </property>
            <property name="reconnectInterval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time between reconnect attempts, in&#10;   milliseconds. This defaults to 1000 (1 second).">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then if the connection is closed&#10;   before this accessor is wrapped up, then attempt to reconnect.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to trust servers. This defaults to false.&#10;   Setting it to true means that if sslTls is set to true, then&#10;   any certificate provided by the server will be trusted.&#10;   FIXME: Need to provide a trusted list if this is false.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the password for the pfx key-cert&#10;   file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the fully qualified filename for&#10;   the file that stores the private key and certificate that this client will use to authenticate&#10;   itself to the server. This path can be any of those understood by the Ptolemy host,&#10;   e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and trustAll is&#10;   set to false, then this option needs to specify the fully qualified filename&#10;   for the file that stores the certificate of a certificate authority (CA) that&#10;   this client will use to verify server certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
            <property name="host (port)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (port)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to -1, which means&#10;  wait for a non-negative input before connecting.">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="host" class="ptolemy.actor.parameters.PortParameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.actor.parameters.PortParameter" value="-1">
        </property>
        <property name="connectTimeout" class="ptolemy.data.expr.Parameter" value="500">
        </property>
        <property name="reconnectInterval" class="ptolemy.data.expr.Parameter" value="200">
        </property>
        <port name="host" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="port" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TCPSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor establishes a server that can accept connection requests for&#10; *  a TCP socket and can send and/or receives messages from the client that makes the&#10; *  request.&#10; *&#10; *  When the server is listening and accepting connections, the port on which it is&#10; *  listening is emitted on the `listening` output port.&#10; *&#10; *  When a connection is established, this accessor outputs on the `connection` output&#10; *  an object with the following properties:&#10; *&#10; *  * **id**: A unique ID identifying the connection (a positive integer).&#10; *  * **remoteHost**: The IP address of the remote host for the socket (a string).&#10; *  * **remotePort**: The port of the remote host for the socket (an integer).&#10; *  * **status**: The string 'open'.&#10; *&#10; *&#10; *  When the connection is closed, the same object as above is produced on the&#10; *  `connection` output, except with status being 'closed'.&#10; *&#10; *  When data is received from the connection, two outputs are produced.&#10; *  The data itself is produced on the `received` output.  The ID of the connection&#10; *  over which the data arrived is produced on the `receivedID` output.&#10; *&#10; *  To send data over a connection, provide the data on the `toSend` input port&#10; *  and the ID of the connection on the `toSendID` input port.  To send to all open&#10; *  connections, provide an ID of 0 (zero).&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to this.send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item that arrives on&#10; *  `toSend`, of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *&#10; *  The client might similarly lose messages by the same two mechanisms occurring&#10; *  on the client side. In that case, messages will presumably be displayed on the&#10; *  client side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketServer&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @input toSendID The ID of the connection over which to send the data, where 0 means&#10; *    to send to all open connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *    (this is useful if the port is specified to be 0).&#10; *  @output connection Output an object with the properties specified above when a&#10; *     connection is established.&#10; *  @output received The data received from the web socket server.&#10; *  @output receivedID The ID of the connection over which data produced on the received&#10; *    output was received. This is a positive integer, as indicated in the connection&#10; *    output.&#10; *&#10; *  @parameter {string} clientAuth One of 'none', 'request', or 'required', meaning&#10; *    whether it requires that a certificate be presented.&#10; *  @parameter {boolean} discardSendToUnopenedSocket If true, then discard any data&#10; *   sent to a socket that is not open. The data will be logged using console.log()&#10; *   instead. This defaults to false.&#10; *  @parameter {string} hostInterface The name of the network interface to use for&#10; *    listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10; *    listen on all available interfaces.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available&#10; *    (the default). If false, data may be accumulated until a reasonable packet size is&#10; *    formed in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true, then this option&#10; *    needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true, then this option&#10; *    needs to specify the fully qualified filename for the file that stores the&#10; *    private key and certificate that this server will use to identify itself. This path can be&#10; *    any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {int} port The default port to listen on. This defaults to 4000.&#10; *    a value of 0 means to choose a random ephemeral free port.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to this.send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    this.send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See below.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See below.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and this server&#10; *    requests/requires a certificate from the client, then this option needs to specify&#10; *    the filename for the file that stores the certificate of a certificate authority (CA) that&#10; *    this server will use to verify client certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, require, send */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('@accessors-modules/socket');&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    // console.log('TCPSocketServer.js: setup() start.');&#10;    this.input('toSend');&#10;    this.input('toSendID', {&#10;        type: 'int',&#10;        value: 0&#10;    });&#10;    this.output('listening', {&#10;        type: 'int'&#10;    });&#10;    this.output('connection', {spontaneous: true});&#10;    this.output('received', {spontaneous: true});&#10;    this.output('receivedID', {spontaneous: true});&#10;&#10;    // The parameters below are listed alphabetically.&#10;    this.parameter('clientAuth', {&#10;        type: 'string',&#10;        value: 'none' // Indicates no SSL/TSL will be used.&#10;    });&#10;    this.parameter('discardSendToUnopenedSocket', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('hostInterface', {&#10;        type: 'string',&#10;        value: '0.0.0.0' // Means listen on all available interfaces.&#10;    });&#10;    this.parameter('idleTimeout', {&#10;        value: 0, // In seconds. 0 means don't timeout.&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('keepAlive', {&#10;        type: 'boolean',&#10;        value: true&#10;    });&#10;    this.parameter('noDelay', {&#10;        type: 'boolean',&#10;        value: true&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    this.parameter('port', {&#10;        type: 'int',&#10;        value: 4000&#10;    });&#10;    this.parameter('rawBytes', {&#10;        type: 'boolean',&#10;        value: false // Means to use a messaging protocol.&#10;    });&#10;    this.parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type: 'string',&#10;        value: 'string'&#10;    });&#10;    this.parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('sendType', {&#10;        type: 'string',&#10;        value: 'string'&#10;    });&#10;    this.parameter('sslTls', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('trustedCACertPath', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options: socket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options: socket.supportedSendTypes()&#10;        });&#10;    } catch (err) {&#10;        error(err);&#10;    }&#10;    // console.log('TCPSocketServer.js: setup() end.');&#10;};&#10;&#10;var server = null;&#10;var connectionCount = 0;&#10;var sockets = [];&#10;&#10;/** Handle input on 'toSend' by sending to one or all of the open sockets, depending&#10; *  on the most recently received value on the `toSendID` input.&#10; */&#10;exports.toSendInputHandler = function () {&#10;    // console.log('TCPSocketServer.js: toSendInputHandler() start.');&#10;    var dataToSend = this.get('toSend');&#10;    var idToSendTo = this.get('toSendID');&#10;    if (idToSendTo === 0) {&#10;        // Broadcast to all sockets.&#10;        for (var i = 0; i &lt; sockets.length; i++) {&#10;            // console.log('TCPSocketServer.js: toSendInputHandler() socket[' + i + '].');&#10;            if (sockets[i]) {&#10;                // console.log('TCPSocketServer.js: toSendInputHandler() socket[' + i + ']. sending: ' + dataToSend);&#10;                sockets[i].send(dataToSend);&#10;                // console.log('TCPSocketServer.js: toSendInputHandler() socket[' + i + ']. done sending: ' + dataToSend);&#10;            }&#10;        }&#10;    } else if (sockets[idToSendTo]) {&#10;        // console.log('TCPSocketServer.js: toSendInputHandler() socket[idToSendTo]: ' + dataToSend);&#10;        sockets[idToSendTo].send(dataToSend);&#10;        // console.log('TCPSocketServer.js: toSendInputHandler() socket[idToSendTo]: ' + dataToSend + ' done.');&#10;    } else {&#10;        var discardSendToUnopenedSocket = this.getParameter('discardSendToUnopenedSocket');&#10;        if (discardSendToUnopenedSocket) {&#10;            console.log('Socket with ID ' + idToSendTo +&#10;                ' is not open. Discarding data.');&#10;        } else {&#10;            error('Attempting to send data over socket with id ' + idToSendTo +&#10;                ', but this socket is not open.');&#10;        }&#10;    }&#10;    // console.log('TCPSocketServer.js: toSendInputHandler() end.');&#10;};&#10;&#10;/** Initialize the accessor by starting the server with the current parameter values&#10; *  specifying the options, setting up listeners to be notified when the server is&#10; *  is listening for connections, when a client requests and connection,&#10; *  and when errors occur, and setting up an input handler&#10; *  for data arriving on the toSend input. When a client requests a connection, the&#10; *  handler will open the socket, send a `connection` output, and and set up listeners&#10; *  for incoming data, errors, and closing of the socket from the remote site.&#10; */&#10;exports.initialize = function () {&#10;    // console.log('TCPSocketServer.js: initialize() start: port: ' + this.getParameter('port'));&#10;&#10;    server = new socket.SocketServer({&#10;        'clientAuth': this.getParameter('clientAuth'),&#10;        'hostInterface': this.getParameter('hostInterface'),&#10;        'idleTimeout': this.getParameter('idleTimeout'),&#10;        'keepAlive': this.getParameter('keepAlive'),&#10;        'noDelay': this.getParameter('noDelay'),&#10;        'pfxKeyCertPassword': this.getParameter('pfxKeyCertPassword'),&#10;        'pfxKeyCertPath': this.getParameter('pfxKeyCertPath'),&#10;        'port': this.getParameter('port'),&#10;        'rawBytes': this.getParameter('rawBytes'),&#10;        'receiveBufferSize': this.getParameter('receiveBufferSize'),&#10;        'receiveType': this.getParameter('receiveType'),&#10;        'sendBufferSize': this.getParameter('sendBufferSize'),&#10;        'sendType': this.getParameter('sendType'),&#10;        'sslTls': this.getParameter('sslTls'),&#10;        'trustedCACertPath': this.getParameter('trustedCACertPath')&#10;    });&#10;&#10;    var self = this;&#10;&#10;    server.on('error', function (message) {&#10;        self.error(message);&#10;    });&#10;&#10;    server.on('listening', function (port) {&#10;        // console.log('TCPSocketServer.js: Listening for socket connection requests on port ' + port);&#10;        self.send('listening', port);&#10;    });&#10;&#10;    server.on('connection', function (serverSocket) {&#10;        // console.log('TCPSocketServer.js: server connection listener: localPort: ' + serverSocket.localPort + ', remotePort: ' + serverSocket.remotePort());&#10;        // serverSocket is an instance of the Socket class defined&#10;        // in the socket module.&#10;        connectionCount++;&#10;        var socketInstance = connectionCount;&#10;        var socketID = {&#10;            'id': socketInstance,&#10;            'remoteHost': serverSocket.remoteHost(),&#10;            'remotePort': serverSocket.remotePort(),&#10;            'status': 'open'&#10;        };&#10;        self.send('connection', socketID);&#10;&#10;        sockets[socketInstance] = serverSocket;&#10;&#10;        serverSocket.on('close', function () {&#10;            // console.log('TCPSocketServer.js: serverSocket close listener');&#10;            socketID.status = 'closed';&#10;            self.send('connection', socketID);&#10;            // Avoid a memory leak here.&#10;            sockets[socketInstance] = null;&#10;        });&#10;        serverSocket.on('data', function (data) {&#10;            // console.log('TCPSocketServer.js: serverSocket data listener: ' + data);&#10;            var util = require('util');&#10;            // console.log(util.inspect(data));&#10;            self.send('received', data);&#10;            self.send('receivedID', socketInstance);&#10;        });&#10;        serverSocket.on('error', function (message) {&#10;            // console.log('TCPSocketServer.js: serverSocket error listener: ' + message);&#10;            self.error(message);&#10;        });&#10;    });&#10;&#10;    // Open the server after setting up all the handlers.&#10;    server.start();&#10;&#10;    // Bind the input handler to caller's object so that when it is invoked,&#10;    // it is invoked in the context of that object and not this one.&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(this));&#10;    // console.log('TCPSocketServer.js: initialize() end');&#10;};&#10;&#10;/** Close all sockets, unregister event listeners, and stop the server.&#10; */&#10;exports.wrapup = function () {&#10;    // console.log('TCPSocketServer.js: wrapup()');&#10;    sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.stop();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/TCPSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="clientAuth" class="ptolemy.data.expr.Parameter" value="none">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="keyStorePassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="keyStorePath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[275.0, 180.0]">
        </property>
        <property name="toSendID" class="ptolemy.actor.parameters.PortParameter" value="0">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor establishes a server that can accept connection requests for&#10; a TCP socket and can send and/or receives messages from the client that makes the&#10; request.&lt;/p&gt;&#10;&lt;p&gt; When the server is listening and accepting connections, the port on which it is&#10; listening is emitted on the &lt;code&gt;listening&lt;/code&gt; output port.&lt;/p&gt;&#10;&lt;p&gt; When a connection is established, this accessor outputs on the &lt;code&gt;connection&lt;/code&gt; output&#10; an object with the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;id&lt;/strong&gt;: A unique ID identifying the connection (a positive integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remoteHost&lt;/strong&gt;: The IP address of the remote host for the socket (a string).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remotePort&lt;/strong&gt;: The port of the remote host for the socket (an integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt;: The string 'open'.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; When the connection is closed, the same object as above is produced on the&#10; &lt;code&gt;connection&lt;/code&gt; output, except with status being 'closed'.&lt;/p&gt;&#10;&lt;p&gt; When data is received from the connection, two outputs are produced.&#10; The data itself is produced on the &lt;code&gt;received&lt;/code&gt; output.  The ID of the connection&#10; over which the data arrived is produced on the &lt;code&gt;receivedID&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; To send data over a connection, provide the data on the &lt;code&gt;toSend&lt;/code&gt; input port&#10; and the ID of the connection on the &lt;code&gt;toSendID&lt;/code&gt; input port.  To send to all open&#10; connections, provide an ID of 0 (zero).&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to this.send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item that arrives on&#10; &lt;code&gt;toSend&lt;/code&gt;, of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The client might similarly lose messages by the same two mechanisms occurring&#10; on the client side. In that case, messages will presumably be displayed on the&#10; client side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'socket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="clientAuth (parameter)" class="ptolemy.kernel.util.StringAttribute" value="One of 'none', 'request', or 'required', meaning&#10;   whether it requires that a certificate be presented.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The name of the network interface to use for&#10;   listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10;   listen on all available interfaces.">
            </property>
            <property name="keyStorePassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) If sslTls is set to true, then this option&#10;   needs to specify the password for the key store specified by keyStorePath.">
            </property>
            <property name="keyStorePath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;string&quot;]}) If sslTls is set to true, then this option&#10;   needs to specify the fully qualified filename for the file that stores the&#10;   certificate that this server will use to identify itself. This path can be&#10;   any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available&#10;   (the default). If false, data may be accumulated until a reasonable packet size is&#10;   formed in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The default port to listen on. This defaults to 4000.&#10;   a value of 0 means to choose a random ephemeral free port.">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on&#10;   (this is useful if the port is specified to be 0).">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="Output an object with the properties specified above when a&#10;    connection is established.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="receivedID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which data produced on the received&#10;   output was received. This is a positive integer, as indicated in the connection&#10;   output.">
            </property>
            <property name="toSendID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which to send the data, where 0 means&#10;   to send to all open connections.">
            </property>
            <property name="discardSendToUnopenedSocket (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any data&#10;  sent to a socket that is not open. The data will be logged using console.log()&#10;  instead. This defaults to false.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the fully qualified filename for the file that stores the&#10;   private key and certificate that this server will use to identify itself. This path can be&#10;   any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and this server&#10;   requests/requires a certificate from the client, then this option needs to specify&#10;   the filename for the file that stores the certificate of a certificate authority (CA) that&#10;   this server will use to verify client certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <port name="toSendID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="receivedID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="TCPSocketClient2" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. If the value of the `port` input is initially&#10; *  negative, then this accessor waits until it receives a non-negative `port`&#10; *  input before making a connection. Otherwise,&#10; *  upon initialization, it initiates a connection to the&#10; *  specified server. If at any time during execution it receives&#10; *  a 'port' input, then it will close any open socket and, if the new&#10; *  'port' value is non-negative, open&#10; *  a new socket to the current 'host' and 'port'.&#10; *&#10; *  When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output. If the connection is broken during execution, then a `false`&#10; *  boolean is sent to the `connected` output. The swarmlet could respond to this by&#10; *  retrying to connect (send an event to either the `port` or `host` input).&#10; *&#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when a socket next opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the  connection.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  [https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3](https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3).&#10; *&#10; *  For numeric types, you can also send an array all at once by providing an&#10; *  array to the `toSend` input port.&#10; *  The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @input {int} port The port on the server to connect to. Defaults to -1, which means&#10; *   wait for a non-negative input before connecting.&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to this.send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the password for the pfx key-cert&#10; *    file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the fully qualified filename for&#10; *    the file that stores the private key and certificate that this client will use to authenticate&#10; *    itself to the server. This path can be any of those understood by the Ptolemy host,&#10; *    e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to this.send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    this.send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 1000 (1 second).&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and trustAll is&#10; *    set to false, then this option needs to specify the fully qualified filename&#10; *    for the file that stores the certificate of a certificate authority (CA) that&#10; *    this client will use to verify server certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim, Contributor: Matt Weber&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global console, error, exports, getParameter, require */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('@accessors-modules/socket');&#10;var openSocket = false; // state variable used for isOpen function.&#10;var client = null;&#10;var running = false;&#10;var pendingSends = [];&#10;var previousHost, previousPort;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    // console.log('TCPSocketClient.js: setup() start');&#10;    this.input('host', {&#10;        type: 'string',&#10;        value: 'localhost'&#10;    });&#10;    this.input('port', {&#10;        type: 'int',&#10;        value: -1&#10;    });&#10;    // This input is added after host and port so that if there are&#10;    // simultaneous inputs, host and port are handled first.&#10;    this.input('toSend');&#10;&#10;    this.output('connected', {&#10;        type: 'boolean'&#10;    });&#10;    this.output('received');&#10;&#10;    // The parameters are in alphabetical order.&#10;    this.parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('discardMessagesBeforeOpen', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('keepAlive', {&#10;        type: 'boolean',&#10;        value: true&#10;    });&#10;    this.parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('noDelay', {&#10;        type: 'boolean',&#10;        value: true&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;    this.parameter('rawBytes', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type: 'string',&#10;        value: 'string'&#10;    });&#10;    this.parameter('reconnectAttempts', {&#10;        type: 'int',&#10;        value: 10&#10;    });&#10;    this.parameter('reconnectInterval', {&#10;        type: 'int',&#10;        value: 1000&#10;    });&#10;    this.parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('sendType', {&#10;        type: 'string',&#10;        value: 'string'&#10;    });&#10;    this.parameter('sslTls', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('trustAll', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.parameter('trustedCACertPath', {&#10;        type: 'string',&#10;        value: ''&#10;    });&#10;&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options: socket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options: socket.supportedSendTypes()&#10;        });&#10;    } catch (err) {&#10;        this.error(err);&#10;    }&#10;    // console.log('TCPSocketClient.js: setup() end');&#10;};&#10;&#10;&#10;/** Send the specified data if the client is set and open,&#10; *  reconnect the client if the socket is closed, and otherwise either&#10; *  discard or queue the data to send later depending on the value of&#10; *  `discardMessagesBeforeOpen`.&#10; */&#10;exports.send = function (data) {&#10;    // console.log('TCPSocketClient.js: send()');&#10;    // May be receiving inputs before client has been set.&#10;&#10;    if (client &amp;&amp; exports.isOpen()) {&#10;        client.send(data);&#10;    } else {&#10;        if (client) {&#10;            // In case the server has closed the socket, reconnect.&#10;            this.exports.connect.call(this);&#10;            client.send(data);&#10;        } else {&#10;            if (!getParameter('discardMessagesBeforeOpen')) {&#10;                var maxUnsentMessages = getParameter('maxUnsentMessages');&#10;&#10;                if (maxUnsentMessages &gt; 0 &amp;&amp; pendingSends.length &gt;= maxUnsentMessages) {&#10;                    this.error(&quot;Maximum number of unsent messages has been exceeded: &quot; +&#10;                        maxUnsentMessages +&#10;                        &quot;. Consider setting discardMessagesBeforeOpen to true.&quot;);&#10;                    return;&#10;                }&#10;                pendingSends.push(data);&#10;            } else {&#10;                console.log('Discarding data because TCP Socket Client has not yet been set up.');&#10;            }&#10;        }&#10;    }&#10;};&#10;&#10;/** Handle input on 'toSend' by sending the specified data to the server. */&#10;exports.toSendInputHandler = function () {&#10;    // console.log('TCPSocketClient.js: toSendInputHandler()');&#10;    this.exports.send.call(this, this.get('toSend'));&#10;};&#10;&#10;/** Set up input handlers, and if the current value of the 'port' input is&#10; *  non-negative, initiate a connection to the server using the&#10; *  current parameter values, and&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server.&#10; */&#10;exports.initialize = function () {&#10;    // console.log('TCPSocketClient.js: initialize()');&#10;    this.addInputHandler('host', this.exports.connect.bind(this));&#10;    this.addInputHandler('port', this.exports.connect.bind(this));&#10;    this.addInputHandler('toSend', this.exports.toSendInputHandler.bind(this));&#10;    this.exports.connect.call(this);&#10;    running = true;&#10;};&#10;&#10;&#10;/** Function is called by client when data has been received over the connection.&#10; *   This has been refactored out of exports.connect to facilitate overriding by an&#10; *   extending accessor.&#10; */&#10;exports.dataReceivedHandler = function (data) {&#10;    // console.log('TCPSocketClient.js: dataReceiveHandler() data: ' + data);&#10;    this.send('received', data);&#10;};&#10;&#10;/** Initiate a connection to the server using the current parameter values,&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server, and set up a handler for inputs&#10; *  on the toSend() input port.&#10; */&#10;exports.connect = function () {&#10;    // console.log('TCPSocketClient.js: connect()');&#10;    // Note that if 'host' and 'port' both receive new data in the same&#10;    // reaction, then this will be invoked twice. But we only want to open&#10;    // the socket once.  This is fairly tricky.&#10;&#10;    var portValue = this.get('port');&#10;    if (portValue &lt; 0) {&#10;        // No port is specified. This could be a signal to close a previously&#10;        // open socket.&#10;        if (client &amp;&amp; exports.isOpen()) {&#10;            client.close();&#10;        }&#10;        previousPort = null;&#10;        previousHost = null;&#10;        return;&#10;    }&#10;&#10;    var hostValue = this.get('host');&#10;    if (previousHost === hostValue &amp;&amp; previousPort === portValue) {&#10;        // A request to open a client for this host/port pair has already&#10;        // been made and has not yet been closed or failed with an error.&#10;        return;&#10;    }&#10;    // Record the host/port pair that we are now opening.&#10;    previousHost = hostValue;&#10;    previousPort = portValue;&#10;&#10;    if (client &amp;&amp; exports.isOpen()) {&#10;        // Either the host or the port has changed. Close the previous socket.&#10;        client.close();&#10;    }&#10;    // Create a new SocketClient.&#10;    client = new socket.SocketClient(portValue, hostValue, {&#10;        'connectTimeout': this.getParameter('connectTimeout'),&#10;        'discardMessagesBeforeOpen': this.getParameter('discardMessagesBeforeOpen'),&#10;        'idleTimeout': this.getParameter('idleTimeout'),&#10;        'keepAlive': this.getParameter('keepAlive'),&#10;        'maxUnsentMessages': this.getParameter('maxUnsentMessages'),&#10;        'noDelay': this.getParameter('noDelay'),&#10;        'pfxKeyCertPassword': this.getParameter('pfxKeyCertPassword'),&#10;        'pfxKeyCertPath': this.getParameter('pfxKeyCertPath'),&#10;        'rawBytes': this.getParameter('rawBytes'),&#10;        'receiveBufferSize': this.getParameter('receiveBufferSize'),&#10;        'receiveType': this.getParameter('receiveType'),&#10;        'reconnectAttempts': this.getParameter('reconnectAttempts'),&#10;        'reconnectInterval': this.getParameter('reconnectInterval'),&#10;        'sendBufferSize': this.getParameter('sendBufferSize'),&#10;        'sendType': this.getParameter('sendType'),&#10;        'sslTls': this.getParameter('sslTls'),&#10;        'trustAll': this.getParameter('trustAll'),&#10;        'trustedCACertPath': this.getParameter('trustedCACertPath')&#10;    });&#10;&#10;    var self = this;&#10;&#10;    client.on('open', function () {&#10;        // console.log('TCPSocketClient: open: Connection established');&#10;        self.send('connected', true);&#10;&#10;        // If there are pending sends, send them now.&#10;        // Note this implementation requires that the host invoke&#10;        // this callback function atomically w.r.t. the input handler&#10;        // that adds messages to the pendingSends queue.&#10;        for (var i = 0; i &lt; pendingSends.length; i++) {&#10;            client.send(pendingSends[i]);&#10;        }&#10;        pendingSends = [];&#10;        openSocket = true; //Update state variable&#10;    });&#10;    client.on('data', self.exports.dataReceivedHandler.bind(self));&#10;    client.on('close', function () {&#10;        // console.log('TCPSocketClient: close');&#10;        previousHost = null;&#10;        previousPort = null;&#10;        // console.log('Connection closed.');&#10;        // NOTE: Even if running is true, it can occur that it is too late&#10;        // to send the message (the wrapup process has been started), in which case&#10;        // the message may not be received.&#10;        if (running) {&#10;            self.send('connected', false);&#10;        }&#10;        openSocket = false; //Update state variable&#10;    });&#10;    client.on('error', function (message) {&#10;        // console.log('TCPSocketClient: error: ' + error);&#10;        previousHost = null;&#10;        previousPort = null;&#10;        self.error(message);&#10;    });&#10;&#10;    client.open();&#10;    // console.log('TCPSocketClient.js: connect() end');&#10;};&#10;&#10;/** Return true if this client has an open connection to the server. */&#10;exports.isOpen = function () {&#10;    // console.log('TCPSocketClient.js: isOpen()');&#10;    return openSocket;&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    // console.log('TCPSocketClient.js: wrapup()');&#10;    running = false;&#10;    if (client) {&#10;        client.close();&#10;        // console.log('Status: Connection closed in wrapup.');&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/TCPSocketClient.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="number">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-70.0, 10.0}">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a TCP socket at&#10; the specified host and port. If the value of the &lt;code&gt;port&lt;/code&gt; input is initially&#10; negative, then this accessor waits until it receives a non-negative &lt;code&gt;port&lt;/code&gt;&#10; input before making a connection. Otherwise,&#10; upon initialization, it initiates a connection to the&#10; specified server. If at any time during execution it receives&#10; a 'port' input, then it will close any open socket and, if the new&#10; 'port' value is non-negative, open&#10; a new socket to the current 'host' and 'port'.&lt;/p&gt;&#10;&lt;p&gt; When the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output. If the connection is broken during execution, then a &lt;code&gt;false&lt;/code&gt;&#10; boolean is sent to the &lt;code&gt;connected&lt;/code&gt; output. The swarmlet could respond to this by&#10; retrying to connect (send an event to either the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt; input).&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt; input,&#10; the data on that input is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when a socket next opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;received&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  connection.&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3&quot;&gt;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array all at once by providing an&#10; array to the &lt;code&gt;toSend&lt;/code&gt; input port.&#10; The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item provided on &lt;code&gt;toSend&lt;/code&gt;,&#10; of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'socket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim, Contributor: Matt Weber">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="host (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to 4000.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time to wait (in milliseconds) before declaring&#10;   a connection attempt to have failed. This defaults to 6000.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any messages&#10;   passed to SocketClient.send() before the socket is opened. If false,&#10;   then queue the messages to be sent when the socket opens. This&#10;   defaults to false.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="maxUnsentMessages (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The maximum number of unsent messages to queue before&#10;   further calls to this.send() will fail. A value of 0 means no limit.&#10;   This defaults to 100.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available (the default).&#10;   If false, data may be accumulated until a reasonable packet size is formed&#10;   in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="reconnectAttempts (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The number of times to try to reconnect.&#10;   If this is greater than 0, then a failure to attempt will trigger&#10;   additional attempts. This defaults to 10.">
            </property>
            <property name="reconnectInterval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time between reconnect attempts, in&#10;   milliseconds. This defaults to 1000 (1 second).">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then if the connection is closed&#10;   before this accessor is wrapped up, then attempt to reconnect.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to trust servers. This defaults to false.&#10;   Setting it to true means that if sslTls is set to true, then&#10;   any certificate provided by the server will be trusted.&#10;   FIXME: Need to provide a trusted list if this is false.">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the password for the pfx key-cert&#10;   file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the fully qualified filename for&#10;   the file that stores the private key and certificate that this client will use to authenticate&#10;   itself to the server. This path can be any of those understood by the Ptolemy host,&#10;   e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and trustAll is&#10;   set to false, then this option needs to specify the fully qualified filename&#10;   for the file that stores the certificate of a certificate authority (CA) that&#10;   this client will use to verify server certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
            <property name="host (port)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (port)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to -1, which means&#10;  wait for a non-negative input before connecting.">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="host" class="ptolemy.actor.parameters.PortParameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.actor.parameters.PortParameter" value="-1">
        </property>
        <property name="connectTimeout" class="ptolemy.data.expr.Parameter" value="500">
        </property>
        <property name="reconnectInterval" class="ptolemy.data.expr.Parameter" value="200">
        </property>
        <port name="host" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="port" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="MicrostepDelay" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-75.0, 110.0}">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="DownSample" class="ptolemy.domains.sdf.lib.DownSample">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[230.0, 295.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="MicrostepDelay2" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[-40.0, 295.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="TrainableTest" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2016-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;/** Compare the input with a known good input.&#10; *  If you set ''trainingMode'' to true and provide inputs, then the&#10; *  inputs will be recorded in the ''correctValues'' parameters.&#10; *  Otherwise, the inputs will be compared against those in the&#10; *  ''correctValue'' parameter.&#10; *&#10; *  @accessor test/TrainableTest&#10; *  @input input The input value.&#10; *  @output output False as long as there is data to compare against the input&#10; *  @param correctValues a JSON array of the correct values.&#10; *  @param trainingMode true if the input is being trained.&#10; *  @author Christopher Brooks based on the Ptolemy NonStrictTest actor by Paul Whitaker, Christopher Hylands, Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, exports*/&#10;/*jshint globalstrict: true*/&#10;/*jslint plusplus: true */&#10;'use strict';&#10;&#10;exports.setup = function () {&#10;    this.parameter('correctValues', {&#10;        'value': [0]&#10;    });&#10;    this.input('input');&#10;    this.output('output', {&#10;        'type': 'boolean'&#10;    });&#10;    this.parameter('tolerance', {&#10;        'type': 'number',&#10;        'value': 0.000000001&#10;    });&#10;    this.parameter('trainingMode', {&#10;        'type': 'boolean',&#10;        'value': false&#10;    });&#10;};&#10;&#10;// Input, parameter and variable names match those in $PTII/ptolemy/actor/lib/NonStrictTest.java&#10;&#10;// Set to true if an input is handled.  If no inputs are handled, then&#10;// throw an exception in wrapup().&#10;var inputHandled = false;&#10;&#10;// Set to true when initialize() is called.&#10;var initialized = false;&#10;&#10;// The number of input tokens that have been read in.&#10;var numberOfInputTokensSeen = 0;&#10;&#10;// If trainingMode is true, then inputs that have been seen so far.&#10;var trainingTokens = [];&#10;&#10;// Set to false in initialize() and true at the end of wrapup().&#10;// FIXME: We should have an exit hook that checks that wrapup() is called for all the actors.&#10;var wrappedUp = false;&#10;&#10;// So we can test this in hosts/node/test/mocha/testMain.js to test that wrapup was called.&#10;exports.wrappedUp = wrappedUp;&#10;&#10;// Return true if the object has the same properties, in any order.&#10;// Based on http://procbits.com/2012/01/19/comparing-two-javascript-objects&#10;var objectPropertiesEqual = function(object1, object2) {&#10;    var property;&#10;&#10;    // Check that all the properties in object2 are present in object.&#10;    for ( property in object2) {&#10;        if (typeof object1[property] === 'undefined') {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    // Check that all the properties in object1 are preset in object2.&#10;    for (property in object1) {&#10;        if (typeof object2[property] === 'undefined') {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    // If a property is an object1, the recursively call this function.&#10;    // If a property is a function, then do a string comparison.&#10;    for (property in object2) {&#10;        if (object2[property]) {&#10;            switch (typeof object2[property]) {&#10;            case 'object1':&#10;                // Here's the recursive bit&#10;                if (!objectPropertiesEqual(object1[property], object2[property])) {&#10;                    return false;&#10;                }&#10;                break;&#10;            case 'function':&#10;                if (typeof object1[property] ==='undefined' ||&#10;                    (property != 'object1PropertiesEqual' &amp;&amp;&#10;                     object2[property].toString() != object1[property].toString())) {&#10;                    return false;&#10;                }&#10;                break;&#10;            default:&#10;                if (object2[property] !== object1[property]) {&#10;                    return false;&#10;                }&#10;            }&#10;        } else {&#10;            // FIXME: I'm not sure if this case is ever used, but it was in &#10;            // http://procbits.com/2012/01/19/comparing-two-javascript-objects&#10;            if (object1[property]) {&#10;                return false;&#10;            }&#10;        }&#10;    }&#10;&#10;    return true;&#10;};&#10;&#10;/** Create an input handler to compare the input with the appropriate element(s)&#10; *  from correctValues.&#10; */&#10;exports.initialize = function () {&#10;    //console.log(&quot;Test initialize(): typeof correctValues: &quot; + typeof this.getParameter('correctValues'))&#10;    var inputValueValue,&#10;        self = this;&#10;&#10;    trainingTokens = [];&#10;    exports.wrappedUp = false;&#10;    numberOfInputTokensSeen = 0;&#10;&#10;    this.addInputHandler('input', function () {&#10;        var cache = [],&#10;            inputValue = self.get('input'),&#10;            inputValueValue;&#10;        inputHandled = true;&#10;&#10;        // If the input is not connected, then inputValue will be null.&#10;        if (self.getParameter('trainingMode')) {&#10;            trainingTokens.push(inputValue);&#10;            self.send('output', false);&#10;            return;&#10;        }&#10;        var correctValuesValues = self.getParameter('correctValues');&#10;&#10;        if (numberOfInputTokensSeen &lt; correctValuesValues.length) {&#10;            var referenceToken = correctValuesValues[numberOfInputTokensSeen];&#10;            //console.log(&quot;Test: &quot; + numberOfInputTokensSeen + &quot;, input: &quot; + inputValue&#10;            //+ &quot;, referenceToken: &quot; + referenceToken);&#10;            if (typeof inputValue !== 'boolean' &amp;&amp;&#10;                typeof inputValue !== 'number' &amp;&amp;&#10;                typeof inputValue !== 'object' &amp;&amp;&#10;                typeof inputValue !== 'string') {&#10;                if (inputValue === null) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the value of the input was null?  ' +&#10;                                    'Perhaps the input is not connected?'&#10;                                   );&#10;                }&#10;                cache = [];&#10;                inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                    if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                        if (cache.indexOf(value) !== -1) {&#10;                            // Circular reference found, discard key&#10;                            return;&#10;                        }&#10;                        // Store value in our collection&#10;                        cache.push(value);&#10;                    }&#10;                    return value;&#10;                });&#10;                if (inputValueValue.length &gt; 100) {&#10;                    inputValueValue = inputValueValue.substring(0, 100) + '...';&#10;                }&#10;                cache = null; // Enable garbage collection&#10;&#10;&#10;                throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                ' tokens, the input &quot;' + inputValue +&#10;                                '&quot; is neither a number nor a string, it is a ' +&#10;                                typeof inputValue + ' with value ' + inputValueValue);&#10;            }&#10;            if (typeof referenceToken === 'boolean') {&#10;                // If the input not a boolean, then throw an error.&#10;                if (typeof inputValue !== 'boolean') {&#10;                    inputValueValue = inputValue;&#10;                    if (typeof inputValue === 'object') {&#10;                        inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                            if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                                if (cache.indexOf(value) !== -1) {&#10;                                    // Circular reference found, discard key&#10;                                    return;&#10;                                }&#10;                                // Store value in our collection&#10;                                cache.push(value);&#10;                            }&#10;                            return value;&#10;                        });&#10;                    }&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValueValue +&#10;                                    '&quot; is not a boolean, it is a ' +&#10;                                    typeof inputValue + '.  The expected value was &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;                if (inputValue !== referenceToken) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValue + '&quot; is not equal to &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;            } else if (typeof referenceToken === 'number') {&#10;                // If the input not a number, then throw an error.&#10;                if (typeof inputValue !== 'number') {&#10;                    inputValueValue = inputValue;&#10;                    if (typeof inputValue === 'object') {&#10;                        inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                            if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                                if (cache.indexOf(value) !== -1) {&#10;                                    // Circular reference found, discard key&#10;                                    return;&#10;                                }&#10;                                // Store value in our collection&#10;                                cache.push(value);&#10;                            }&#10;                            return value;&#10;                        });&#10;                    }&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValueValue +&#10;                                    '&quot; is not a number, it is a ' +&#10;                                    typeof inputValue + '.  The expected value was &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;&#10;                var difference = Math.abs(inputValue - referenceToken);&#10;                if (isNaN(difference)) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the absolute value of the input &quot;' +&#10;                                    inputValue + '&quot; - the referenceToken &quot;' +&#10;                                    referenceToken + '&quot; is NaN?  It should be less than ' +&#10;                                    self.getParameter('tolerance'));&#10;                }&#10;                if (difference &gt; self.getParameter('tolerance')) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValue + '&quot; is not within &quot;' +&#10;                                    self.getParameter('tolerance') +&#10;                                    '&quot; of the expected value &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;            } else if (typeof referenceToken === 'string') {&#10;                if (inputValue !== referenceToken) {&#10;                    // devices/test/auto/WatchEmulator.js needs this test for object because&#10;                    // if we receive a JSON object, then we should try to stringify it.&#10;                    if (typeof inputValue === 'object') {&#10;                        inputValueValue = null;&#10;                        try {&#10;                            inputValueValue = JSON.stringify(inputValue);&#10;                        } catch (err) {&#10;                            throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                            ' tokens, the input &quot;' + inputValue + '&quot; is !== ' +&#10;                                            ' to the expected value &quot;' +&#10;                                            referenceToken + '&quot;.  The input was an object, and a string was expected.');&#10;                        }&#10;                        if (inputValueValue !== referenceToken) {&#10;                            throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                            ' tokens, the input &quot;' + inputValueValue + '&quot; is !== ' +&#10;                                            ' to the expected value &quot;' +&#10;                                            referenceToken +&#10;                                            '&quot;.  The input was an object and JSON.stringify() did not throw an exception.' +&#10;                                            'A string was expected.');&#10;                        }&#10;                    }&#10;                }&#10;            } else if (typeof referenceToken === 'object') {&#10;                // Sadly, in JavaScript, objects that have the same&#10;                // properties, but in a different order are not&#10;                // consider equal in that Object.is() will return&#10;                // false.  However, Ptolemy RecordTokens are by&#10;                // default unordered (unless they are&#10;                // OrderedRecordTokens), So, we have a function that&#10;                // does a deep comparison and ignores differences in&#10;                // property order.&#10;                if (objectPropertiesEqual(inputValue, referenceToken)) {&#10;                    // The objects are not the same.&#10;&#10;                    // Generate string representations of the values&#10;                    // so that the user can possibly tell what went&#10;                    // wrong.&#10;                    cache = [];&#10;                    inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                        if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                            if (cache.indexOf(value) !== -1) {&#10;                                // Circular reference found, discard key&#10;                                return;&#10;                            }&#10;                            // Store value in our collection&#10;                            cache.push(value);&#10;                        }&#10;                        return value;&#10;                    });&#10;                    cache = [];&#10;                    var referenceTokenValue = JSON.stringify(referenceToken, function (key, value) {&#10;                        if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                            if (cache.indexOf(value) !== -1) {&#10;                                // Circular reference found, discard key&#10;                                return;&#10;                            }&#10;                            // Store value in our collection&#10;                            cache.push(value);&#10;                        }&#10;                        return value;&#10;                    });&#10;&#10;                    cache = null; // Enable garbage collection&#10;&#10;                    // If we are comparing longs from CapeCode, then the values will be like &quot;1L&quot;,&#10;                    // and stringify will return undefined.&#10;                    if (inputValueValue === undefined) {&#10;                        inputValueValue = inputValue;&#10;                    }&#10;                    if (referenceTokenValue === undefined) {&#10;                        referenceTokenValue = referenceToken;&#10;                    }&#10;&#10;                    if (inputValueValue !== referenceTokenValue) {&#10;                        // inputValueValue could still be undefined here if inputValue&#10;                        // was undefined.&#10;                        if (inputValueValue !== undefined &amp;&amp; inputValueValue.length &gt; 100) {&#10;                            inputValueValue = inputValueValue.substring(0, 100) + '...';&#10;                        }&#10;                        if (referenceTokenValue !== undefined &amp;&amp; referenceTokenValue.length &gt; 100) {&#10;                            referenceTokenValue = referenceTokenValue.substring(0, 100) + '...';&#10;                        }&#10;                        // Deal with referenceTokens with value 1L.&#10;                        if (typeof inputValueValue !== 'object' || typeof referenceTokenValue !== 'object' &amp;&amp;&#10;                            inputValueValue.toString() !== referenceTokenValue.toString) {&#10;                            throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                            ' tokens, the input Object \n&quot;' + inputValueValue +&#10;                                            '&quot; is !== to the expected value Object\n&quot;' +&#10;                                            referenceTokenValue);&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                ' tokens, the referenceToken &quot;' + referenceToken +&#10;                                '&quot; is not a number, it is a ' +&#10;                                typeof referenceToken);&#10;            }&#10;            numberOfInputTokensSeen += 1;&#10;            // If we are past the end of the expected inputs, then read&#10;            if (numberOfInputTokensSeen &gt;= correctValuesValues.length) {&#10;                self.send('output', true);&#10;            } else {&#10;                self.send('output', false);&#10;            }&#10;        } else {&#10;            self.send('output', true);&#10;        }&#10;    });&#10;    initialized = true;&#10;};&#10;&#10;/** If trainingMode is true, then updated the correctValues. */&#10;exports.wrapup = function () {&#10;    if (this.getParameter('trainingMode')) {&#10;        this.setParameter('correctValues', trainingTokens);&#10;    } else {&#10;        if (initialized) {&#10;            if (!inputHandled) {&#10;                initialized = false;&#10;                throw new Error(this.accessorName + ': The input handler of this accessor was never invoked. ' +&#10;                                'Usually, this is an error indicating that ' +&#10;                                'starvation is occurring.');&#10;            }&#10;            var correctValuesValues = this.getParameter('correctValues');&#10;            if (numberOfInputTokensSeen &lt; correctValuesValues.length) {&#10;                throw new Error(this.accessorName + ': The test produced only ' +&#10;                                numberOfInputTokensSeen +&#10;                                ' tokens, yet the correctValues parameter was ' +&#10;                                'expecting ' +&#10;                                correctValuesValues.length +&#10;                                ' tokens');&#10;            }&#10;        }&#10;        initialized = false;&#10;    }&#10;    var name = this.accessorName;&#10;&#10;    // FIXME: Should we check to see if the name has no dots in and if&#10;    // it does not, add the container name?&#10;&#10;    //if (this.container) {&#10;    //    name = this.container.accessorName + &quot;.&quot; + name;&#10;    //}&#10;&#10;    //&#10;    exports.wrappedUp = true;&#10;    // console.log(&quot;TrainableTest.js: wrapup() finished: &quot; + name + &quot;, exports.wrappedUp: &quot; + exports.wrappedUp);&#10;&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/test/TrainableTest.js">
        </property>
        <property name="checkoutOrUpdateAccessorsRepository" class="ptolemy.actor.parameters.SharedParameter" value="true">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Compare the input with a known good input.&#10; If you set ''trainingMode'' to true and provide inputs, then the&#10; inputs will be recorded in the ''correctValues'' parameters.&#10; Otherwise, the inputs will be compared against those in the&#10; ''correctValue'' parameter.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Christopher Brooks based on the Ptolemy NonStrictTest actor by Paul Whitaker, Christopher Hylands, Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="The input value.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="False as long as there is data to compare against the input">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[80.0, 75.0]">
        </property>
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{1, 3}">
        </property>
        <property name="trainingMode" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TrainableTest2" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2016-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;/** Compare the input with a known good input.&#10; *  If you set ''trainingMode'' to true and provide inputs, then the&#10; *  inputs will be recorded in the ''correctValues'' parameters.&#10; *  Otherwise, the inputs will be compared against those in the&#10; *  ''correctValue'' parameter.&#10; *&#10; *  @accessor test/TrainableTest&#10; *  @input input The input value.&#10; *  @output output False as long as there is data to compare against the input&#10; *  @param correctValues a JSON array of the correct values.&#10; *  @param trainingMode true if the input is being trained.&#10; *  @author Christopher Brooks based on the Ptolemy NonStrictTest actor by Paul Whitaker, Christopher Hylands, Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, exports*/&#10;/*jshint globalstrict: true*/&#10;/*jslint plusplus: true */&#10;'use strict';&#10;&#10;exports.setup = function () {&#10;    this.parameter('correctValues', {&#10;        'value': [0]&#10;    });&#10;    this.input('input');&#10;    this.output('output', {&#10;        'type': 'boolean'&#10;    });&#10;    this.parameter('tolerance', {&#10;        'type': 'number',&#10;        'value': 0.000000001&#10;    });&#10;    this.parameter('trainingMode', {&#10;        'type': 'boolean',&#10;        'value': false&#10;    });&#10;};&#10;&#10;// Input, parameter and variable names match those in $PTII/ptolemy/actor/lib/NonStrictTest.java&#10;&#10;// Set to true if an input is handled.  If no inputs are handled, then&#10;// throw an exception in wrapup().&#10;var inputHandled = false;&#10;&#10;// Set to true when initialize() is called.&#10;var initialized = false;&#10;&#10;// The number of input tokens that have been read in.&#10;var numberOfInputTokensSeen = 0;&#10;&#10;// If trainingMode is true, then inputs that have been seen so far.&#10;var trainingTokens = [];&#10;&#10;// Set to false in initialize() and true at the end of wrapup().&#10;// FIXME: We should have an exit hook that checks that wrapup() is called for all the actors.&#10;var wrappedUp = false;&#10;&#10;// So we can test this in hosts/node/test/mocha/testMain.js to test that wrapup was called.&#10;exports.wrappedUp = wrappedUp;&#10;&#10;// Return true if the object has the same properties, in any order.&#10;// Based on http://procbits.com/2012/01/19/comparing-two-javascript-objects&#10;var objectPropertiesEqual = function(object1, object2) {&#10;    var property;&#10;&#10;    // Check that all the properties in object2 are present in object.&#10;    for ( property in object2) {&#10;        if (typeof object1[property] === 'undefined') {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    // Check that all the properties in object1 are preset in object2.&#10;    for (property in object1) {&#10;        if (typeof object2[property] === 'undefined') {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    // If a property is an object1, the recursively call this function.&#10;    // If a property is a function, then do a string comparison.&#10;    for (property in object2) {&#10;        if (object2[property]) {&#10;            switch (typeof object2[property]) {&#10;            case 'object1':&#10;                // Here's the recursive bit&#10;                if (!objectPropertiesEqual(object1[property], object2[property])) {&#10;                    return false;&#10;                }&#10;                break;&#10;            case 'function':&#10;                if (typeof object1[property] ==='undefined' ||&#10;                    (property != 'object1PropertiesEqual' &amp;&amp;&#10;                     object2[property].toString() != object1[property].toString())) {&#10;                    return false;&#10;                }&#10;                break;&#10;            default:&#10;                if (object2[property] !== object1[property]) {&#10;                    return false;&#10;                }&#10;            }&#10;        } else {&#10;            // FIXME: I'm not sure if this case is ever used, but it was in &#10;            // http://procbits.com/2012/01/19/comparing-two-javascript-objects&#10;            if (object1[property]) {&#10;                return false;&#10;            }&#10;        }&#10;    }&#10;&#10;    return true;&#10;};&#10;&#10;/** Create an input handler to compare the input with the appropriate element(s)&#10; *  from correctValues.&#10; */&#10;exports.initialize = function () {&#10;    //console.log(&quot;Test initialize(): typeof correctValues: &quot; + typeof this.getParameter('correctValues'))&#10;    var inputValueValue,&#10;        self = this;&#10;&#10;    trainingTokens = [];&#10;    exports.wrappedUp = false;&#10;    numberOfInputTokensSeen = 0;&#10;&#10;    this.addInputHandler('input', function () {&#10;        var cache = [],&#10;            inputValue = self.get('input'),&#10;            inputValueValue;&#10;        inputHandled = true;&#10;&#10;        // If the input is not connected, then inputValue will be null.&#10;        if (self.getParameter('trainingMode')) {&#10;            trainingTokens.push(inputValue);&#10;            self.send('output', false);&#10;            return;&#10;        }&#10;        var correctValuesValues = self.getParameter('correctValues');&#10;&#10;        if (numberOfInputTokensSeen &lt; correctValuesValues.length) {&#10;            var referenceToken = correctValuesValues[numberOfInputTokensSeen];&#10;            //console.log(&quot;Test: &quot; + numberOfInputTokensSeen + &quot;, input: &quot; + inputValue&#10;            //+ &quot;, referenceToken: &quot; + referenceToken);&#10;            if (typeof inputValue !== 'boolean' &amp;&amp;&#10;                typeof inputValue !== 'number' &amp;&amp;&#10;                typeof inputValue !== 'object' &amp;&amp;&#10;                typeof inputValue !== 'string') {&#10;                if (inputValue === null) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the value of the input was null?  ' +&#10;                                    'Perhaps the input is not connected?'&#10;                                   );&#10;                }&#10;                cache = [];&#10;                inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                    if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                        if (cache.indexOf(value) !== -1) {&#10;                            // Circular reference found, discard key&#10;                            return;&#10;                        }&#10;                        // Store value in our collection&#10;                        cache.push(value);&#10;                    }&#10;                    return value;&#10;                });&#10;                if (inputValueValue.length &gt; 100) {&#10;                    inputValueValue = inputValueValue.substring(0, 100) + '...';&#10;                }&#10;                cache = null; // Enable garbage collection&#10;&#10;&#10;                throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                ' tokens, the input &quot;' + inputValue +&#10;                                '&quot; is neither a number nor a string, it is a ' +&#10;                                typeof inputValue + ' with value ' + inputValueValue);&#10;            }&#10;            if (typeof referenceToken === 'boolean') {&#10;                // If the input not a boolean, then throw an error.&#10;                if (typeof inputValue !== 'boolean') {&#10;                    inputValueValue = inputValue;&#10;                    if (typeof inputValue === 'object') {&#10;                        inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                            if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                                if (cache.indexOf(value) !== -1) {&#10;                                    // Circular reference found, discard key&#10;                                    return;&#10;                                }&#10;                                // Store value in our collection&#10;                                cache.push(value);&#10;                            }&#10;                            return value;&#10;                        });&#10;                    }&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValueValue +&#10;                                    '&quot; is not a boolean, it is a ' +&#10;                                    typeof inputValue + '.  The expected value was &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;                if (inputValue !== referenceToken) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValue + '&quot; is not equal to &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;            } else if (typeof referenceToken === 'number') {&#10;                // If the input not a number, then throw an error.&#10;                if (typeof inputValue !== 'number') {&#10;                    inputValueValue = inputValue;&#10;                    if (typeof inputValue === 'object') {&#10;                        inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                            if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                                if (cache.indexOf(value) !== -1) {&#10;                                    // Circular reference found, discard key&#10;                                    return;&#10;                                }&#10;                                // Store value in our collection&#10;                                cache.push(value);&#10;                            }&#10;                            return value;&#10;                        });&#10;                    }&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValueValue +&#10;                                    '&quot; is not a number, it is a ' +&#10;                                    typeof inputValue + '.  The expected value was &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;&#10;                var difference = Math.abs(inputValue - referenceToken);&#10;                if (isNaN(difference)) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the absolute value of the input &quot;' +&#10;                                    inputValue + '&quot; - the referenceToken &quot;' +&#10;                                    referenceToken + '&quot; is NaN?  It should be less than ' +&#10;                                    self.getParameter('tolerance'));&#10;                }&#10;                if (difference &gt; self.getParameter('tolerance')) {&#10;                    throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                    ' tokens, the input &quot;' + inputValue + '&quot; is not within &quot;' +&#10;                                    self.getParameter('tolerance') +&#10;                                    '&quot; of the expected value &quot;' +&#10;                                    referenceToken + '&quot;');&#10;                }&#10;            } else if (typeof referenceToken === 'string') {&#10;                if (inputValue !== referenceToken) {&#10;                    // devices/test/auto/WatchEmulator.js needs this test for object because&#10;                    // if we receive a JSON object, then we should try to stringify it.&#10;                    if (typeof inputValue === 'object') {&#10;                        inputValueValue = null;&#10;                        try {&#10;                            inputValueValue = JSON.stringify(inputValue);&#10;                        } catch (err) {&#10;                            throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                            ' tokens, the input &quot;' + inputValue + '&quot; is !== ' +&#10;                                            ' to the expected value &quot;' +&#10;                                            referenceToken + '&quot;.  The input was an object, and a string was expected.');&#10;                        }&#10;                        if (inputValueValue !== referenceToken) {&#10;                            throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                            ' tokens, the input &quot;' + inputValueValue + '&quot; is !== ' +&#10;                                            ' to the expected value &quot;' +&#10;                                            referenceToken +&#10;                                            '&quot;.  The input was an object and JSON.stringify() did not throw an exception.' +&#10;                                            'A string was expected.');&#10;                        }&#10;                    }&#10;                }&#10;            } else if (typeof referenceToken === 'object') {&#10;                // Sadly, in JavaScript, objects that have the same&#10;                // properties, but in a different order are not&#10;                // consider equal in that Object.is() will return&#10;                // false.  However, Ptolemy RecordTokens are by&#10;                // default unordered (unless they are&#10;                // OrderedRecordTokens), So, we have a function that&#10;                // does a deep comparison and ignores differences in&#10;                // property order.&#10;                if (objectPropertiesEqual(inputValue, referenceToken)) {&#10;                    // The objects are not the same.&#10;&#10;                    // Generate string representations of the values&#10;                    // so that the user can possibly tell what went&#10;                    // wrong.&#10;                    cache = [];&#10;                    inputValueValue = JSON.stringify(inputValue, function (key, value) {&#10;                        if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                            if (cache.indexOf(value) !== -1) {&#10;                                // Circular reference found, discard key&#10;                                return;&#10;                            }&#10;                            // Store value in our collection&#10;                            cache.push(value);&#10;                        }&#10;                        return value;&#10;                    });&#10;                    cache = [];&#10;                    var referenceTokenValue = JSON.stringify(referenceToken, function (key, value) {&#10;                        if (typeof value === 'object' &amp;&amp; value !== null) {&#10;                            if (cache.indexOf(value) !== -1) {&#10;                                // Circular reference found, discard key&#10;                                return;&#10;                            }&#10;                            // Store value in our collection&#10;                            cache.push(value);&#10;                        }&#10;                        return value;&#10;                    });&#10;&#10;                    cache = null; // Enable garbage collection&#10;&#10;                    // If we are comparing longs from CapeCode, then the values will be like &quot;1L&quot;,&#10;                    // and stringify will return undefined.&#10;                    if (inputValueValue === undefined) {&#10;                        inputValueValue = inputValue;&#10;                    }&#10;                    if (referenceTokenValue === undefined) {&#10;                        referenceTokenValue = referenceToken;&#10;                    }&#10;&#10;                    if (inputValueValue !== referenceTokenValue) {&#10;                        // inputValueValue could still be undefined here if inputValue&#10;                        // was undefined.&#10;                        if (inputValueValue !== undefined &amp;&amp; inputValueValue.length &gt; 100) {&#10;                            inputValueValue = inputValueValue.substring(0, 100) + '...';&#10;                        }&#10;                        if (referenceTokenValue !== undefined &amp;&amp; referenceTokenValue.length &gt; 100) {&#10;                            referenceTokenValue = referenceTokenValue.substring(0, 100) + '...';&#10;                        }&#10;                        // Deal with referenceTokens with value 1L.&#10;                        if (typeof inputValueValue !== 'object' || typeof referenceTokenValue !== 'object' &amp;&amp;&#10;                            inputValueValue.toString() !== referenceTokenValue.toString) {&#10;                            throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                            ' tokens, the input Object \n&quot;' + inputValueValue +&#10;                                            '&quot; is !== to the expected value Object\n&quot;' +&#10;                                            referenceTokenValue);&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                throw new Error(self.accessorName + ': After seeing ' + numberOfInputTokensSeen +&#10;                                ' tokens, the referenceToken &quot;' + referenceToken +&#10;                                '&quot; is not a number, it is a ' +&#10;                                typeof referenceToken);&#10;            }&#10;            numberOfInputTokensSeen += 1;&#10;            // If we are past the end of the expected inputs, then read&#10;            if (numberOfInputTokensSeen &gt;= correctValuesValues.length) {&#10;                self.send('output', true);&#10;            } else {&#10;                self.send('output', false);&#10;            }&#10;        } else {&#10;            self.send('output', true);&#10;        }&#10;    });&#10;    initialized = true;&#10;};&#10;&#10;/** If trainingMode is true, then updated the correctValues. */&#10;exports.wrapup = function () {&#10;    if (this.getParameter('trainingMode')) {&#10;        this.setParameter('correctValues', trainingTokens);&#10;    } else {&#10;        if (initialized) {&#10;            if (!inputHandled) {&#10;                initialized = false;&#10;                throw new Error(this.accessorName + ': The input handler of this accessor was never invoked. ' +&#10;                                'Usually, this is an error indicating that ' +&#10;                                'starvation is occurring.');&#10;            }&#10;            var correctValuesValues = this.getParameter('correctValues');&#10;            if (numberOfInputTokensSeen &lt; correctValuesValues.length) {&#10;                throw new Error(this.accessorName + ': The test produced only ' +&#10;                                numberOfInputTokensSeen +&#10;                                ' tokens, yet the correctValues parameter was ' +&#10;                                'expecting ' +&#10;                                correctValuesValues.length +&#10;                                ' tokens');&#10;            }&#10;        }&#10;        initialized = false;&#10;    }&#10;    var name = this.accessorName;&#10;&#10;    // FIXME: Should we check to see if the name has no dots in and if&#10;    // it does not, add the container name?&#10;&#10;    //if (this.container) {&#10;    //    name = this.container.accessorName + &quot;.&quot; + name;&#10;    //}&#10;&#10;    //&#10;    exports.wrappedUp = true;&#10;    // console.log(&quot;TrainableTest.js: wrapup() finished: &quot; + name + &quot;, exports.wrappedUp: &quot; + exports.wrappedUp);&#10;&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/test/TrainableTest.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Compare the input with a known good input.&#10; If you set ''trainingMode'' to true and provide inputs, then the&#10; inputs will be recorded in the ''correctValues'' parameters.&#10; Otherwise, the inputs will be compared against those in the&#10; ''correctValue'' parameter.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Christopher Brooks based on the Ptolemy NonStrictTest actor by Paul Whitaker, Christopher Hylands, Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="The input value.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="False as long as there is data to compare against the input">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[380.0, 85.0]">
        </property>
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{0, 2}">
        </property>
        <property name="trainingMode" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TextDisplayClient2Received" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={22, 461, 505, 137}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[505, 93]">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Display text.&#10;//&#10;// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Display data using util.inspect() to render a more human-readable form.&#10; *  Any data accepted by util.inspect() can be displayed.&#10; *  The title may be used by the host to label the output in some way, either&#10; *  by labeling a display window or prepending the printed text with the title.&#10; *  The resulting text is passed through to the output in case a model wishes to ensure&#10; *  that the image has been displayed before something else happens or the model&#10; *  wishes to use the rendered text in some way.&#10; *&#10; *  @accessor utilities/TextDisplay&#10; *  @input input The text to display.&#10; *  @output output The text to display.&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var textDisplay = require('@accessors-modules/text-display');&#10;var util = require('util');&#10;var display = null;&#10;&#10;exports.setup = function () {&#10;    this.input('input');&#10;    this.output('output', {'type':'string'});&#10;    this.parameter('title', {&#10;        'type':'string',&#10;        'value':'TextDisplay'&#10;    });&#10;};&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    if (display === null) {&#10;        display = new textDisplay.TextDisplay(this.getParameter('title'));&#10;    }&#10;&#10;    this.addInputHandler('input', function () {&#10;        var inputValue = self.get('input');&#10;        var text = util.inspect(inputValue);&#10;        display.appendText(text);&#10;        this.send('output', text);&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/TextDisplay.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Display data using util.inspect() to render a more human-readable form.&#10; Any data accepted by util.inspect() can be displayed.&#10; The title may be used by the host to label the output in some way, either&#10; by labeling a display window or prepending the printed text with the title.&#10; The resulting text is passed through to the output in case a model wishes to ensure&#10; that the image has been displayed before something else happens or the model&#10; wishes to use the rendered text in some way.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[81.58805847167969, -16.431884765625]">
        </property>
        <property name="title" class="ptolemy.data.expr.Parameter" value="TextDisplayClient2Received">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TextDisplayClient1Received" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={528, 460, 499, 139}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 95]">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Display text.&#10;//&#10;// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Display data using util.inspect() to render a more human-readable form.&#10; *  Any data accepted by util.inspect() can be displayed.&#10; *  The title may be used by the host to label the output in some way, either&#10; *  by labeling a display window or prepending the printed text with the title.&#10; *  The resulting text is passed through to the output in case a model wishes to ensure&#10; *  that the image has been displayed before something else happens or the model&#10; *  wishes to use the rendered text in some way.&#10; *&#10; *  @accessor utilities/TextDisplay&#10; *  @input input The text to display.&#10; *  @output output The text to display.&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var textDisplay = require('@accessors-modules/text-display');&#10;var util = require('util');&#10;var display = null;&#10;&#10;exports.setup = function () {&#10;    this.input('input');&#10;    this.output('output', {'type':'string'});&#10;    this.parameter('title', {&#10;        'type':'string',&#10;        'value':'TextDisplay'&#10;    });&#10;};&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    if (display === null) {&#10;        display = new textDisplay.TextDisplay(this.getParameter('title'));&#10;    }&#10;&#10;    this.addInputHandler('input', function () {&#10;        var inputValue = self.get('input');&#10;        var text = util.inspect(inputValue);&#10;        display.appendText(text);&#10;        this.send('output', text);&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/TextDisplay.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Display data using util.inspect() to render a more human-readable form.&#10; Any data accepted by util.inspect() can be displayed.&#10; The title may be used by the host to label the output in some way, either&#10; by labeling a display window or prepending the printed text with the title.&#10; The resulting text is passed through to the output in case a model wishes to ensure&#10; that the image has been displayed before something else happens or the model&#10; wishes to use the rendered text in some way.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[380.0, 5.0]">
        </property>
        <property name="title" class="ptolemy.data.expr.Parameter" value="TextDisplayClient1Received">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TextDisplayServerConnected" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={529, 603, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Display text.&#10;//&#10;// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Display data using util.inspect() to render a more human-readable form.&#10; *  Any data accepted by util.inspect() can be displayed.&#10; *  The title may be used by the host to label the output in some way, either&#10; *  by labeling a display window or prepending the printed text with the title.&#10; *  The resulting text is passed through to the output in case a model wishes to ensure&#10; *  that the image has been displayed before something else happens or the model&#10; *  wishes to use the rendered text in some way.&#10; *&#10; *  @accessor utilities/TextDisplay&#10; *  @input input The text to display.&#10; *  @output output The text to display.&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var textDisplay = require('@accessors-modules/text-display');&#10;var util = require('util');&#10;var display = null;&#10;&#10;exports.setup = function () {&#10;    this.input('input');&#10;    this.output('output', {'type':'string'});&#10;    this.parameter('title', {&#10;        'type':'string',&#10;        'value':'TextDisplay'&#10;    });&#10;};&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    if (display === null) {&#10;        display = new textDisplay.TextDisplay(this.getParameter('title'));&#10;    }&#10;&#10;    this.addInputHandler('input', function () {&#10;        var inputValue = self.get('input');&#10;        var text = util.inspect(inputValue);&#10;        display.appendText(text);&#10;        this.send('output', text);&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/TextDisplay.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Display data using util.inspect() to render a more human-readable form.&#10; Any data accepted by util.inspect() can be displayed.&#10; The title may be used by the host to label the output in some way, either&#10; by labeling a display window or prepending the printed text with the title.&#10; The resulting text is passed through to the output in case a model wishes to ensure&#10; that the image has been displayed before something else happens or the model&#10; wishes to use the rendered text in some way.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[460.0, 170.0]">
        </property>
        <property name="title" class="ptolemy.data.expr.Parameter" value="TextDisplayServerConnected">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="JavaScriptRamp" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="/** Output a sequence with a given step in values.&#10; *&#10; *  @accessor test/TestRamp&#10; *  @param init The value produced on its first iteration.  The&#10; *  initial default is 0.&#10; *  @input trigger The trigger&#10; *  @output output The output&#10; *  @param step The amount by which the output is incremented. The&#10; *  default is 1.&#10; *  @author Christopher Brooks&#10; *  @version $$Id$$&#10; */&#10;exports.setup = function() {&#10;    // FIXME: this only supports numbers, unlike the Cape Code Ramp&#10;    // actor, which supports many types.&#10;    this.parameter('init', {'type':'number', 'value':0});&#10;    this.input('trigger');&#10;    this.output('output', {'type':'number'});&#10;    this.parameter('step', {'type':'number', 'value':1});&#10;};&#10;&#10;var _lastValue = 0;&#10;&#10;exports.initialize = function() {&#10;    _lastValue = this.getParameter('init');&#10;}&#10;exports.fire = function() {&#10;    this.send('output', _lastValue);&#10;    _lastValue += this.getParameter('step');&#10;};">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[115.0, 220.0]">
        </property>
        <property name="init" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="step" class="ptolemy.data.expr.Parameter" value="1">
        </property>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="JavaScriptDiscreteClock" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="/** Generate discrete events at prespecified time instants.    &#10; *&#10; *  @accessor JavaScriptDiscreteClock&#10; *  @param offsets The offsets at which the specified values will be produced.                                                                                         &#10; * 	This parameter must contain an array of doubles, and it defaults                                                                                    &#10; *  to [0.0]. &#10; *  @param period The period of the output waveform.                                                                                                                  &#10; *  This is a double that defaults to 1.0.&#10; *  @input start  A port that, if connected, is used to specify when the clock                                                                                        &#10; *  starts. This port accepts any type. The arrival of an event                                                                                         &#10; *  is what starts the clock. Upon arrival of such an event,                                                                                            &#10; *  the clock starts as if just initialized. The clock will not                                                                                         &#10; *  start until such an event is provided, unless the port is                                                                                           &#10; *  left unconnected, in which case the actor starts immediately.                                                                                       &#10; *  Note that when the clock starts, the period will be set to                                                                                          &#10; *  its initial value. If an input period arrives before a                                                                                              &#10; *  start input, then that arrived value will be ignored.&#10; *  @input stop A port that, if connected, is used to specify when the clock                                                                                        &#10; *  stops. This port accepts any type. The arrival of an event                                                                                          &#10; *  is what stops the clock.&#10; *  @param values The values that will be produced at the specified offsets.                                                                                          &#10; *  This parameter must contain an ArrayToken, and it defaults to [1].&#10; *  @input trigger The trigger&#10; *  @output output The output&#10; *  @author Christopher Brooks&#10; *  @version $$Id$$&#10; */&#10;exports.setup = function() {&#10;    // FIXME: this only supports numbers, unlike the Cape Code Ramp&#10;    // actor, which supports many types.&#10;    this.parameter('offsets', {'value': [0.0]});&#10;    this.parameter('period', {'type':'number', 'value': 1.0});&#10;    this.input('start');&#10;    this.input('stop');&#10;    this.input('trigger');&#10;    this.output('output', {'type':'int'});&#10;    this.parameter('values', {'value': [1]});&#10;};&#10;&#10;var _handle = null;&#10;var _phase = 0;&#10;var _enabled = true; &#10;&#10;exports.initialize = function() {&#10;    _phase = 0;&#10;    _enabled = true;&#10;	// FIXME: Need to check to see if start is connected.  How?&#10;    var self = this;&#10;    this.addInputHandler(&quot;start&quot;, function () {&#10;    	self._enabled = true&#10; 	 });&#10;    this.addInputHandler(&quot;stop&quot;, function () {&#10;    	self._enabled = false&#10; 	 });&#10;}&#10;&#10;exports.fire = function() {&#10;	if (_enabled) {&#10;    	this.send('output', this.getParameter('values')[_phase]);&#10;    	_phase += 1;&#10;    	if (_phase &gt;= this.getParameter('offsets').length) {&#10;    		// FIXME: do something with period?&#10;    		_phase = 0;&#10;    	}&#10;    	&#10;    	var periodValue = this.getParameter('period');&#10;    	var offsetValue = this.getParameter('offsets')[_phase];&#10;    	if (offsetValue &gt; periodValue) {&#10;    		throw new Error(&quot;Offset of &quot; + offsetValue + &#10;                  &quot; is greater than the period &quot; + periodValue);&#10;    	}&#10;    	&#10;    	var self = this;&#10;    	_handle = setTimeout(function () {&#10;			self.fire()&#10;        }, offsetValue * 1000.0);&#10;    }&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (_handle) {&#10;        clearInterval(_handle);&#10;        _handle = null;&#10;    }&#10;};">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{-60.0, 190.0}">
        </property>
        <property name="offsets" class="ptolemy.data.expr.Parameter" value="{1.0, 2.0}">
        </property>
        <property name="period" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="values" class="ptolemy.data.expr.Parameter" value="{1, 2}">
        </property>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="start" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="stop" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="TextDisplayServerConnected2" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={25, 604, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Display text.&#10;//&#10;// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Display data using util.inspect() to render a more human-readable form.&#10; *  Any data accepted by util.inspect() can be displayed.&#10; *  The title may be used by the host to label the output in some way, either&#10; *  by labeling a display window or prepending the printed text with the title.&#10; *  The resulting text is passed through to the output in case a model wishes to ensure&#10; *  that the image has been displayed before something else happens or the model&#10; *  wishes to use the rendered text in some way.&#10; *&#10; *  @accessor utilities/TextDisplay&#10; *  @input input The text to display.&#10; *  @output output The text to display.&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var textDisplay = require('@accessors-modules/text-display');&#10;var util = require('util');&#10;var display = null;&#10;&#10;exports.setup = function () {&#10;    this.input('input');&#10;    this.output('output', {'type':'string'});&#10;    this.parameter('title', {&#10;        'type':'string',&#10;        'value':'TextDisplay'&#10;    });&#10;};&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    if (display === null) {&#10;        display = new textDisplay.TextDisplay(this.getParameter('title'));&#10;    }&#10;&#10;    this.addInputHandler('input', function () {&#10;        var inputValue = self.get('input');&#10;        var text = util.inspect(inputValue);&#10;        display.appendText(text);&#10;        this.send('output', text);&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/TextDisplay.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Display data using util.inspect() to render a more human-readable form.&#10; Any data accepted by util.inspect() can be displayed.&#10; The title may be used by the host to label the output in some way, either&#10; by labeling a display window or prepending the printed text with the title.&#10; The resulting text is passed through to the output in case a model wishes to ensure&#10; that the image has been displayed before something else happens or the model&#10; wishes to use the rendered text in some way.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="The text to display.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{65.28781512605042, 265.17632287289916}">
        </property>
        <property name="title" class="ptolemy.data.expr.Parameter" value="TextDisplayServerConnected2">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Stop" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Accessor that stops execution of the enclosing swarmlet.&#10;//&#10;// Copyright (c) 2016-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Accessor that stops execution of the enclosing swarmlet when it&#10; *  receives an input with value true. It does this by identifying&#10; *  the top-level enclosing composite accessor and invoking wrapup&#10; *  on it.&#10; *&#10; *  @accessor utilities/Stop&#10; *  @input {boolean} stop A signal with value true to stop the swarmlet.&#10; *  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should be no&#10;// space between the / and the * and global. See https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*global  exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;exports.setup = function () {&#10;    this.input('stop', {&#10;        'type': 'boolean'&#10;    });&#10;};&#10;&#10;exports.initialize = function () {&#10;    this.addInputHandler('stop', function () {&#10;        var stop = this.get('stop');&#10;        if (stop) {&#10;            this.stop();&#10;        }&#10;    });&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/Stop.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor that stops execution of the enclosing swarmlet when it&#10; receives an input with value true. It does this by identifying&#10; the top-level enclosing composite accessor and invoking wrapup&#10; on it.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="stop (port)" class="ptolemy.kernel.util.StringAttribute" value="A signal with value true to stop the swarmlet.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[595.0, 95.0]">
        </property>
        <port name="stop" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="JavaScriptBarrier" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// After inputs appear on both inputs, generate a true output.&#10;var sawInput1 = false;&#10;var sawInput2 = false;&#10;&#10;exports.setup = function() {&#10;    this.input('input1');   &#10;    this.input('input2'); &#10;    this.output('output', {&#10;    	'type': 'boolean'&#10;    });&#10;    this.parameter('timeout');&#10;    &#10;    var self = this;&#10;    self.addInputHandler('input1', function() {&#10;    	self.sawInput1 = true;&#10;    	if (self.sawInput1 == true &amp;&amp; self.sawInput2 === true &amp;&amp; self.sawInput3 === true) {&#10;    		self.send('output', true);&#10;    	}&#10;    });&#10;    self.addInputHandler('input2', function() {&#10;		self.sawInput2 = true;&#10; 		if (self.sawInput1 == true &amp;&amp; self.sawInput2 === true &amp;&amp; self.sawInput3 === true) {&#10;    		self.send('output', true);&#10;    	}&#10;    });&#10;}&#10;&#10;exports.initialize = function() {&#10;	var self = this;&#10;	setTimeout(function () {&#10;		console.log('JavaScriptBarrier: sending true after timeout.');&#10;		self.send('output', true);&#10;	}, this.getParameter('timeout'));&#10;}">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[485.0, 95.0]">
        </property>
        <property name="timeout" class="ptolemy.data.expr.Parameter" value="50000">
        </property>
        <port name="input1" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="input2" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[10.0, 20.0]">
        </vertex>
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[320.0, 20.0]">
        </vertex>
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[170.0, 110.0]">
        </vertex>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[55.0, 170.0]">
        </vertex>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[365.0, 170.0]">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation12" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="TCPSocketClient1.port" relation="relation7"/>
    <link port="TCPSocketClient1.received" relation="relation5"/>
    <link port="TCPSocketServer.toSendID" relation="relation8"/>
    <link port="TCPSocketServer.toSend" relation="relation2"/>
    <link port="TCPSocketServer.listening" relation="relation7"/>
    <link port="TCPSocketServer.connection" relation="relation4"/>
    <link port="TCPSocketClient2.port" relation="relation"/>
    <link port="TCPSocketClient2.received" relation="relation6"/>
    <link port="MicrostepDelay.input" relation="relation7"/>
    <link port="MicrostepDelay.output" relation="relation"/>
    <link port="DownSample.input" relation="relation4"/>
    <link port="DownSample.output" relation="relation3"/>
    <link port="MicrostepDelay2.input" relation="relation3"/>
    <link port="MicrostepDelay2.output" relation="relation9"/>
    <link port="TrainableTest.input" relation="relation6"/>
    <link port="TrainableTest.output" relation="relation12"/>
    <link port="TrainableTest2.input" relation="relation5"/>
    <link port="TrainableTest2.output" relation="relation10"/>
    <link port="TextDisplayClient2Received.input" relation="relation6"/>
    <link port="TextDisplayClient1Received.input" relation="relation5"/>
    <link port="TextDisplayServerConnected.input" relation="relation4"/>
    <link port="JavaScriptRamp.trigger" relation="relation8"/>
    <link port="JavaScriptRamp.output" relation="relation2"/>
    <link port="JavaScriptDiscreteClock.output" relation="relation8"/>
    <link port="JavaScriptDiscreteClock.start" relation="relation9"/>
    <link port="TextDisplayServerConnected2.input" relation="relation8"/>
    <link port="Stop.stop" relation="relation11"/>
    <link port="JavaScriptBarrier.input1" relation="relation10"/>
    <link port="JavaScriptBarrier.input2" relation="relation12"/>
    <link port="JavaScriptBarrier.output" relation="relation11"/>
</entity>
