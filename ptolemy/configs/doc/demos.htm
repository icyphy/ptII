<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!-- $Id$ -->
    <!--
	demosPtiny.htm is derived from this file by including
	anything between the tags vergilDoc and /vergilDoc.
	The vergilDoc tags are used by $PTII/doc/javahtml.awk
	to generate demosPtiny.htm.
      -->
    <link href="../../../doc/default.css" rel="stylesheet" type="text/css">
  </head>

  <body>
    <!--vergilDocs-->
    <!--ptinyKeplerDocs-->
    <!--bcvtbDocs-->
    <h1> Tour of Ptolemy II </h1>

    <!--
	Note:  demos should go with in the directory of their respective
	domains. Demo xml files should usually be upper case, and have the
	same name as the directory they reside in; so we should
	have sdf/demo/Foo/Foo.xml.
	The reason that the xml files are upcased is so that if
	we do code generation, we get Foo.java instead of foo.java
      -->

    If you are viewing this from within Vergil, the graphical
    editor for Ptolemy II, then
    many of the following links will open models that highlight the
    key features of Ptolemy II. If you are using an ordinary
    web browser, then you will see the XML definition of the models.
    To run the models in Vergil,
    click on the red triangle in the toolbar. The
    diagrams are fully editable, so feel free to explore.
    You can also access the <a href="completeDemos.htm">complete list of demos</a>
    <!-- whatNew.htm links to whatsNew4.0.htm, which has many of features
	 not present in ptiny -->
    <!--/vergilDocs-->
    and the summary of
    <a href="whatsNew.htm">new capabilities</a>
    <!--vergilDocs-->
    . Contents:
    <ul>
      <li> <a href="#domain">Application Domain-Specific Modeling</a>: Application Domain-specific modeling and design.
      </li>

      <li> <a href="#heterogeneous">Heterogeneous Modeling</a>: Mixing models of computation.
      </li>

      <li> <a href="#basic">Basic Modeling Capabilities</a>: Commonly used models of computation.
      </li>

      <li> <a href="#infrastructure">Modeling Infrastructure</a>: Capabilities shared by all uses of Ptolemy II.
      </li>

      <li> <a href="#libraries">Actor Libraries</a>: Useful libraries of actors.
	<!--/vergilDocs-->
	<!--experimental features do not get included in demosPtiny.htm -->
      </li>

      <li> <a href="#experimental">Experimental</a>: Demonstrations of less mature capabilities.
	<!--vergilDocs-->
      </li>

    </ul>



    <h2>
      <a name="domain">Application Domain-Specific Modeling</a>
    </h2>


    Ptolemy II can be used to build sophisticated application domain-specific modeling capabilities
    and frameworks. These frameworks can be packaged as separate executable
    applications (e.g. HyVisual or VisualSense)
    or accessed from within Ptolemy II. Here, we illustrate some such frameworks.
    <ul>



      <!--/vergilDocs-->

      <li><i>Modeling of wireless networks</i>: <a href="../../domains/wireless/demo/WirelessSoundDetection/WirelessSoundDetection.xml">WirelessSoundDetection</a>
	<!--/ptinyKeplerDocs-->
	<!--/bcvtbDocs-->
	(see also
	<a href="../visualsense/intro.htm">VisualSense introduction</a>).
	<!--ptinyKeplerDocs-->
	<br>

	The wireless domain in Ptolemy II
	provides discrete-event modeling of wireless communication systems.
	It is useful for modeling and design of communication protocols,
	networking strategies, and applications such as sensor networks.
	<!--/ptinyKeplerDocs-->
	The <a href="../visualsense/intro.htm">VisualSense</a> package
	is a subset of Ptolemy II that includes the wireless domain and channel models
	plus domains that support the design of nodes in a wireless network.
	<!--ptinyKeplerDocs-->
	The <a href="../../domains/wireless/demo/WirelessSoundDetection/WirelessSoundDetection.xml">WirelessSoundDetection</a>
	example models a sound localization problem, where single sound source
	moves through a field of sound sensors. In the example, sound sensors detect the sound
	and communicate via a radio channel to a sensor fusion component that
	localizes the sound by triangulation. Two distinct channel models are used,
	one that models sound propagation and one that models radio communication.

	<br>



	<!--/ptinyKeplerDocs-->
      </li>

      <!--ptinyKeplerDocs-->
      <!--bcvtbDocs-->
      <li>
	<i>Modeling of hybrid systems</i>:
	<!-- GR does not get included in demosPtiny.htm -->
	<a href="../../domains/continuous/demo/StickyMasses/StickyMasses.xml">StickyMasses</a>
	(see also
	<a href="../../domains/continuous/demo/BouncingBall/BouncingBall.xml">BouncingBall</a>,
	<a href="../../domains/continuous/demo/FurutaPendulum/FurutaPendulum.xml">FurutaPendulum</a>,
	<a href="../../domains/continuous/demo/NewtonsCradle/NewtonsCradleAnimated.xml">NewtonsCradleAnimated</a>,
	and
	<a href="../../domains/continuous/demo/HybridPlant/RandomHybridPlant.xml">Hybrid Plant</a>).

	<!--/ptinyKeplerDocs-->

	<i>Hybrid systems</i> are a special case of modal models
	where finite-state machines (FSMs) are combined with the continuous-time models
	to get mixed continuous-time and discrete-event models.
	<!--ptinyKeplerDocs-->
	<!-- GR does not get included in demosPtiny.htm -->
	The <a href="../../domains/continuous/demo/StickyMasses/StickyMasses.xml">StickyMasses</a>
	example models a physical system consisting of two point masses
	on springs that stick together when they collide.
	<!--vergilDocs-->

	<br>


      </li>

      <li>
	<i>Stochastic hybrid systems</i>:
	<a href="../../domains/continuous/demo/Noise/Noise.xml">Noise</a>
	(see also
	<a href="../../domains/continuous/demo/Poisson/IncreasingRatePoisson.xml">IncreasingRatePoisson</a>,
	<a href="../../domains/continuous/demo/Hysteresis/HysteresisWithRandomDelay.xml">HysteresisWithRandomDelay</a>,
	<a href="../../domains/continuous/demo/Brownian/Brownian.xml">Brownian</a>
	).
	<br>


	Stochastic hybrid systems add random behavior to continuous-time models mixed
	with discrete events. The
	<a href="../../domains/continuous/demo/Noise/Noise.xml">Noise</a>
	<!--/bcvtbDocs-->
	<!-- NoiseSpectrum uses DEDirector, which is not shipped with bcvtb -->
	(and <a
		href="../../domains/continuous/demo/Noise/NoiseSpectrum.xml">Noise
	  Spectrum</a>

	<!-- SinusoidInNoise includes continuous.lib.ContinuousSpectrum, which -->
	<!-- uses DEDirectory, which is not shipped with BCVTB -->
	,
	<a
	   href="../../domains/continuous/demo/Noise/SinusoidInNoise.xml">Sinusoid
	  In Noise</a>
	<!--bcvtbDocs-->
	) models
	show bandlimited Gaussian noise processe.
	<a href="../../domains/continuous/demo/Poisson/IncreasingRatePoisson.xml">IncreasingRatePoisson</a>
	models spontaneous mode transitions governed by a Poisson process.
	The <a href="../../domains/continuous/demo/Hysteresis/HysteresisWithRandomDelay.xml">HysteresisWithRandomDelay</a>
	example uses similar spontaneous mode transitions to model random delay in mode transitions.
	The <a href="../../domains/continuous/demo/Brownian/Brownian.xml">Brownian</a> example
	models a stochastic differential equation describing a random walk process.

	<!--vergilDocs-->

	<br>



      </li>

      <li><i>Signal Processing</i>:
	<a href="../../domains/sdf/demo/MaximumEntropySpectrum/MaximumEntropySpectrum.xml">MaximumEntropySpectrum</a>
	(See also
	<a href="../../domains/sdf/demo/LMSAdaptive/LMSAdaptive.xml">LMSAdaptive</a>,
	<a href="../../domains/sdf/demo/SynthesizedVoice/SynthesizedVoice.xml">SynthesizedVoice</a>,
	<a href="../../domains/sdf/demo/FourierSeries/FourierSeries.xml">FourierSeries</a>, and
	<a href="../../domains/sdf/demo/SoundSpectrum/SoundSpectrum.xml">SoundSpectrum</a>)
	<br>


	Ptolemy II includes an extensive library and models of computation suitable for
	digital signal processing, communication systems design, and image and video processing.
	The <a href="../../domains/sdf/demo/MaximumEntropySpectrum/MaximumEntropySpectrum.xml">MaximumEntropySpectrum</a>
	example shows spectral estimation of sinusoids in noise.
	It illustrates models the use of synchronous dataflow (SDF) for signal
	processing, and also shows many basic capabilities like
	hierarchical models,
	the Expression actor, and the signal processing actor library.


      </li>

    </ul>


    <h2>
      <a name="heterogeneous">Heterogeneous Models</a>
    </h2>


    A particular capability of Ptolemy II is the ability to mix models of computation.
    These examples illustrate some of these capabilities.
    <ul>


      <!--/bcvtbDocs-->
      <li><i>Modal Models</i>:
	<a href="../../domains/de/demo/ModalModel/ModalModel.xml">ModalModel</a>
	<br>


	A modal model is one whose behavior depends on its "mode"
	of operation. A modal model in Ptolemy II heterogeneously combines the
	<i>finite state machine</i> (FSM) domain
	combined hierarchically with other models. A state in the FSM represents
	a mode of operation, and can have a refinement that gives the behavior
	in that mode.
	The refinement can be another FSM or some other model using some other
	Ptolemy domain. The <a href="../../domains/de/demo/ModalModel/ModalModel.xml">ModalModel</a> example combines DE, FSM, and SDF to model a
	system where regularly sampled signals are perturbed by irregular
	events in time.


	<br>



      </li>
      
      <!--bcvtbDocs-->
      <li><i>Mixed-Signal Modeling</i>:
	<!--/bcvtbDocs-->
	<!-- SigmaDelta uses DEDirector, which is not in bcvtb -->
	<a href="../../domains/continuous/demo/SigmaDelta/SigmaDelta.xml">SigmaDelta</a>
	<br>
	This example shows how to combine continuous-time modeling
	with discrete-event modeling to get mixed-signal modeling.
	The example models a MEMS accelerometer where a digital circuit
	implements feedback control and A/D conversion (a design due to
	Mark Lemkin).

	(see also
	<!--bcvtbDocs-->
	<a href="../../domains/continuous/demo/Switch/Switch.xml">Switching Continuous</a>
	<!--/bcvtbDocs-->
	)
	<!--bcvtbDocs-->
      </li>

    </ul>


    <h2>
      <a name="basic">Basic Modeling Capabilities</a>
    </h2>


    Many common models of computation have been implemented in
    Ptolemy II.  This section illustrates some of them.
    <ul>



      <li><i>Synchronous Dataflow</i>:
	<a href="../../domains/sdf/demo/Spectrum/Spectrum.xml">Spectrum</a> (See also
	<a href="../../domains/sdf/demo/MaximumEntropySpectrum/MaximumEntropySpectrum.xml">MaximumEntropySpectrum</a>,
	<a href="../../domains/sdf/demo/FourierSeries/FourierSeries.xml">FourierSeries</a>, and
	<a href="../../domains/sdf/demo/SoundSpectrum/SoundSpectrum.xml">SoundSpectrum</a>)
	<br>

	This example shows simple spectral estimation of the product
	of two sinusoids in noise.  It illustrates models the use of synchronous dataflow (SDF) for signal
	processing, and also shows many basic capabilities like
	hierarchical models,
	the Expression actor, and the signal processing actor library.
	In SDF, the firing of actors is statically scheduled, and at the start of execution,
	boundedness and deadlock conditions are checked.


	<br>



      </li>

      <li><i>Continuous-Time Modeling</i>:
	<a href="../../domains/continuous/demo/Lorenz/Lorenz.xml">Lorenz</a> (see also
	<a href="../../domains/continuous/demo/Lorenz/LorenzDifferentialSystem.xml">Lorenz with DifferentialSystem</a>,
	<a href="../../domains/continuous/demo/SquareWave/SquareWave.xml">SquareWave</a>,
	<a href="../../domains/continuous/demo/Sinusoid/Sinusoid.xml">Sinusoid</a>)
	<br>

	This example shows a continuous-time
	nonlinear feedback system that exhibits
	chaotic behavior (this system is called a Lorenz attractor).
	It illustrates the <i>continuous</i> domain,
	which uses an underlying solver for ordinary differential equations
	and cleanly supports mixtures of discrete events and continuous-time
	signals.


	<br>



      </li>
      <!--/bcvtbDocs-->
      <li><i>Discrete-Event Modeling</i>:
	<a href="../../domains/de/demo/Inspection/Inspection.xml">Inspection</a>
	(see also

	<!--/ptinyKeplerDocs-->
	<!-- QueueAndServer uses Colt, which is not part of Kepler -->
	<a href="../../domains/de/demo/QueueAndServer/QueueAndServer.xml">QueueAndServer</a>,
	<!--bcvtbDocs-->
	<!--ptinyKeplerDocs-->
	<!--/bcvtbDocs-->
	<!-- Router uses DEDirector, which is not in bcvtb -->
	<a href="../../data/type/demo/Router/Router.xml">Router</a>,
	and <a href="../../domains/de/demo/TimingParadox/TimingParadox.xml">TimingParadox</a>
	).

	<br>

	This example shows
	a famous paradox in probability called the inspection paradox.
	It illustrates use of the <i>discrete-event</i> (DE) domain, where
	events occur on a time line and are processed chronologically.
	In this example, random
	data stimulates a model and statistics are collected and reported
	in various ways.


	<br>
	<!--/bcvtbDocs-->


      </li>
      <!-- Ptiny does not include Ptera -->
      <!--/vergilDocs-->
      <!--/ptinyKeplerDocs-->
      <!--/bcvtbDocs-->
      <li><i>Event-Oriented Modeling with Ptera</i>:
	<a href="../../domains/ptera/demo/AdaptiveCarWash/AdaptiveCarWashFSM.xml">CarWash</a> with DE, Ptera and FSM
	
	(See also <a href="../../actor/gt/demo/GameOfLife/GameOfLife.xml">GameOfLife</a>, <a href="../../domains/ptera/demo/TrafficLight/TrafficLight.xml">TrafficLight</a>).
	<br>

	The Ptera (Ptolemy Event Relationship Actor) domain is a discrete-event model
	of computation. A model in Ptera is represented with a graph of nodes and edges,
	where nodes represent events and directed edges between events represent
	scheduling relation. One or more events can be selected as initial events, which
	are scheduled at model time 0.0. When an event is fired, it possibly performs
	certain actions, and if there are outgoing edges from that event, the events at
	the end points of those edges are scheduled after non-negative delays. One or
	more events can also be selected as final events. The firing of final events
	causes the event queue to be emptied after their actions are performed, and
	therefore no more events can be processed.


	<br>



      </li>
      <!--ptinyKeplerDocs-->
      <!--/bcvtbDocs-->
      <!--vergilDocs-->


      <li><i>Process Networks</i>:
	<a href="../../domains/pn/demo/OrderedMerge/OrderedMerge.xml">OrderedMerge</a> (see also
	<a href="../../domains/pn/demo/NondeterministicMerge/NondeterministicMerge.xml">NondeterministicMerge</a>,
	<a href="../../domains/pn/demo/QR/QR.xml">QR</a>).
	<br>


	The process networks (PN) domain follows the semantics given by Kahn and MacQueen in 1977
	to get processes with their own threads of control that send messages to one another
	and achieve deterministic computation.
	The <a href="../../domains/pn/demo/OrderedMerge/OrderedMerge.xml">OrderedMerge</a> example implements an example given by Kahn and MacQueen
	that calculates numbers whose prime
	factors are 2, 3, and 5, only, and produces
	them in an ordered sequence.
	As of version 5.0, we have extended this model of computation with a
	nondeterministic merge actor, illustrated in
	<a href="../../domains/pn/demo/NondeterministicMerge/NondeterministicMerge.xml">NondeterministicMerge</a>.

	<br>



	<!--/ptinyKeplerDocs-->
      </li>

      <li><i>Rendezvous</i>:
	<a href="../../domains/rendezvous/demo/Barrier/Barrier.xml">Barrier</a>
	(see also
	<a href="../../domains/rendezvous/demo/ResourcePool/ResourcePool.xml">ResourcePool</a>,
	<a href="../../domains/rendezvous/demo/Sequencing/Sequencing.xml">ResourcePool</a>,
	<a href="../../domains/rendezvous/demo/WriteRegulator/WriteRegulator.xml">WriteRegulator</a>).
	<br>
	<!--ptinyKeplerDocs-->
	<!--/vergilDocs-->
	<!--Ptiny does not include csp -->
	The rendezvous domain implements the classic
	communicating sequential processes (CSP)
	semantics introduced by Tony Hoare, with some extensions. In the CSP domain,
	every actor executes in its own thread, and communication is by rendezvous.
	The rendezvous domain supports conditional rendezvous (where an actor communicates
	nondeterministically with one of several other actors) and multi-way rendezvous
	(where an actor communicates simultaneously with all of several other actors).
	The
	<a href="../../domains/csp/demo/Barrier/Barrier.xml">Barrier</a> example shows
	the use of multi-way rendezvous to achieve a classic concurrency design pattern
	called barrier synchronization.

	<!--Ptiny does not include ddf-->
	<br>


      </li>

      <li> <i>Dynamic Dataflow</i>:
	<a href="../../domains/ddf/demo/HanoiTower/HanoiTower.xml">HanoiTower</a>
	(see also
	<a href="../../domains/ddf/demo/Eratosthenes/Eratosthenes.xml">Eratosthenes</a>,
	<a href="../../domains/ddf/demo/IfThenElse/IfThenElse.xml">IfThenElse</a>,
	<a href="../../domains/ddf/demo/Loop/Loop.xml">Loop</a>,
	<a href="../../domains/ddf/demo/OrderedMerge/OrderedMerge.xml">OrderedMerge</a>,
	<a href="../../domains/ddf/demo/RandomWalk/RandomWalk.xml">RandomWalk</a>)
	<br>


	In dynamic dataflow (DDF) models, actors are fired in response to available
	input data. The schedule is dynamic and data dependent, and actors can
	change their production and consumption rates in each firing.
	Unlike synchronous dataflow, the DDF model of computation is Turing
	complete, and questions of deadlock and boundedness are undecidable.
	The <a href="../../domains/ddf/demo/HanoiTower/HanoiTower.xml">HanoiTower</a>
	example exploits this to give an algorithmic solution to the well-known
	towers of Hanoi problem.

	<br>


      </li>

      <li> <i>Heterochronous Dataflow</i>:
	<a href="../../domains/hdf/demo/Fibonacci/Fibonacci.xml">Fibonacci</a>
	(see also
	<a href="../../domains/hdf/demo/Merge/Merge.xml">Merge</a>).
	<br>


	Heterochronous dataflow (HDF) is an extension of synchronous dataflow
	(SDF) that permits dynamically changing production and consumption
	patterns without sacrificing static scheduling. In SDF, the production
	and consumption patterns of an actor are constant.
	In HDF they are allowed to change between iterations of the HDF schedule.
	Modal models can be used to change these patterns.
	Although HDF can express many data-dependent computations that cannot
	be represented by SDF, it is not Turing complete.  Consequently, deadlock
	and boundedness remain decidable.
	The <a href="../../domains/hdf/demo/Fibonacci/Fibonacci.xml">Fibonacci</a>
	example uses this mechanism in a clever way to extract a Fibonacci sequence
	from a counting sequence.

	<!--vergilDocs-->
	<br>



	<!--/ptinyKeplerDocs-->
      </li>

      <li><i>Synchronous/Reactive Modeling</i>:
	<a href="../../domains/sr/demo/TokenRing/TokenRing.xml">TokenRing</a> (see also
	<a href="../../domains/sr/demo/TrafficLight/TrafficLight.xml">TrafficLight</a> and
	<a href="../../domains/sr/demo/GuardedCount/GuardedCount.xml">GuardedCount</a>).
	<br>


	The synchronous/reactive (SR) domain,
	which is inspired by the synchronous languages Esterel, Lustre, and Signal,
	realizes a concurrency model where actors react instantaneously and simultaneously
	at ticks of a logical clock.
	The <a href="../../domains/sr/demo/TokenRing/TokenRing.xml">TokenRing</a>
	example uses the fixed-point semantics of SR to arbitrate access
	to a shared medium using a token-ring protocol.
	<!--ptinyKeplerDocs-->


      </li>

    </ul>

    <!--bcvtbDocs-->

    <h2>
      <a name="infrastructure">Modeling Infrastructure</a>
    </h2>


    Ptolemy II models are built on an underlying framework that provides a rich
    set of generic capabilities that are available in all models.
    This section illustrates that infrastructure.
    <ul>

      <!--/bcvtbDocs-->
      <li><i>The Type System</i>:
	<a href="../../data/type/demo/Router/Router.xml">Router</a>.
	<br>


	This model illustrates the very sophisticated type system
	of Ptolemy II, where type constraints propagate transparently,
	actors are polymorphic, and composite types such as records and
	arrays are supported.
	This example illustrates composite types, where records are
	constructed out of tokens with various types. Here, a record
	models a packet in a packet-switched network, where variable
	delays may result in out-of-order arrival of packets.

	<br>
	<!--bcvtbDocs-->



      </li>

      <li><i>Expression Language</i>:
	<a href="../../domains/continuous/demo/Transmission/Transmission.xml">Transmission</a>.
	<br>


	To simplify creating new components, Ptolemy II contains a functional
	expression language.  The expression language is integrated with the
	type system, allowing static type checking of polymorphic expressions
	with few type annotations.  The expression language also allows new,
	encapsulated functions, called function closures, to be defined and
	passed as data.  This model illustrates how function closures can be
	used to make models much more compact.

	<br>


	<!--/vergilDocs-->
	<!--We don't include hoc in Ptiny-->
      </li>
      
      <li><i>Model Transformation</i>:
	<a href="../../actor/gt/demo/SinewaveOptimization/SinewaveOptimization.xml">SinewaveOptimization</a>
	(see also
	<a href="../../domains/ptera/demo/AdaptiveCarWash/AdaptiveCarWash.xml">AdaptiveCarWash</a>,
	<a href="../../actor/gt/demo/ConstOptimization/ConstOptimization.xml">ConstOptimization</a>,
	<a href="../../actor/gt/demo/DiningPhilosophers/DiningPhilosophers.xml">DiningPhilosophers</a>,
	<a href="../../actor/gt/demo/GameOfLife/GameOfLife.xml">GameOfLife</a>,
	<a href="../../actor/gt/demo/MapReduce/MapReduce.xml">MapReduce</a>,
	<a href="../../actor/gt/demo/RegressionTest/RegressionTest.xml">RegressionTest</a>
	).
	<br>
	Model transformation is a technique to manipulate models as first-class citizens. An atomic transformation
	rule is defined in a TransformationRule actor. Inputs to a TransformationRule actor are tokens containing
	models to be transformed, and outputs are tokens containing the results. Multiple transformations can be
	programmed by a model to transform the input models step by step. Other actors that are commonly used in model
	transformation include ModelGenerator to generate initial models, and ModelView to show the contents of input
	models in new windows. In the <a href="../../actor/gt/demo/SinewaveOptimization/SinewaveOptimization.xml">SinewaveOptimization</a>
	demo, a transformation is repeatedly applied to the initial model (<a href="../../actor/gt/demo/SinewaveOptimization/Sinewave.xml">Sinewave</a>)
	to statically evaluate arithmetic operations in it, until no more simplification can be done.
	<br>
      </li>

      <li><i>Higher-Order Components</i>:
	<a href="../../actor/lib/hoc/demo/HocDE/HocDE.xml">HocDE</a>
	(see also
	<a href="../../actor/lib/hoc/demo/Case/Case.xml">Case</a>,
	<a href="../../actor/lib/hoc/demo/MobileFunction/MobileFunction.xml">MobileFunction</a>,
	<a href="../../domains/sdf/demo/MultipleRuns/MultipleRuns.xml">MultipleRuns</a>,
	<a href="../../actor/lib/hoc/demo/IterateOverArray/IterateOverArray.xml">IterateOverArray</a>,
	<a href="../../actor/lib/hoc/demo/DFTSubSet/DFTSubSet.xml">DFTSubSet</a>,
	<a href="../../actor/lib/hoc/demo/ApplyFFT/ApplyFFT.xml">ApplyFFT</a>
	).
	<br>

	Higher-order components are components that operate on components.
	The <a href="../../actor/lib/hoc/demo/HocDE/HocDE.xml">HocDE</a>
	example contains a component that is a composite actor that
	replicates itself some specified number of times to operate on
	multiple channels of input.  This capability was created by
	Zoltan Kemenczy and Sean Simmons, Research In Motion, Ltd.

	<br>


	<!--vergilDocs-->

      </li>

      <li><i>Interactive Signal Plotter</i>:
	<a href="../../domains/sdf/demo/Sketch/Sketch.xml">Sketch</a>
	(see also <a href="../../domains/sdf/demo/FourierSeries/FourierSeries.xml">FourierSeries</a>).
	<br>


	This model illustrates the use of plotter to provide input
	as well as rendering output from a model.  Right click and drag
	on the plot to trace out a new signal. The model runs each time you
	do this.

	<br>



      </li>

      <li><i>Matlab Integration</i>:
	<a href="../../matlab/demo/MatlabExpression/MatlabExpression.xml">MatlabExpression</a>
	(see also
	<a href="../../matlab/demo/MatlabContinuous/MatlabContinuous.xml">Matlab in Continuous</a>).

	<br>


	This example uses the Matlab interface created by
	Zoltan Kemenczy and Sean Simmons, of Research in Motion Ltd.,
	to plot a 3-D surface. This works only if Matlab is installed locally.

	<br>



      </li>

      <li>
	<i>Classes, subclasses, and inner classes</i>:
	<a href="ClassesIllustrated.xml">ClassesIllustrated</a> (see also
	<a href="../../domains/sdf/demo/NoisySinewave/NoisySinewave.xml">Noisy sinewaves</a>
	<!--/bcvtbDocs-->
	<!-- Rijndael includes domains.fsm, which is not shipped with bcvtb -->
	and
	<a href="../../domains/sdf/demo/RijndaelEncryption/RijndaelEncryption.xml">Rijndael Encryption</a>
	<!--bcvtbDocs-->  
	).
	<br>


	Actor-oriented classes, subclasses, and
	inner classes with inheritance are a special feature of Ptolemy II.
	They provide modularity mechanisms analogous to those of object-oriented
	design, but adapted to actor-oriented design. This capability permits, for
	example, defining a class of models that can have instances and subclasses.
	The instances and subclasses inherit all the features of the class, and
	track any changes that are made to the class.

	<br>



      </li>

      <li><i>Model Animations</i>:
	<!--/bcvtbDocs-->
	<!-- Bouncer uses DEDirector -->
	<a href="../../actor/parameters/demo/Bouncer/Bouncer.xml">Bouncer</a>
	(see also
	<!--bcvtbDocs-->
	<a href="../../vergil/kernel/attributes/demo/AnimateVergil/AnimateVergil.xml">AnimateVergil</a>
	<!--/vergilDocs-->
	<a href="../../domains/wireless/demo/WirelessSoundDetection/WirelessSoundDetection.xml">WirelessSoundDetection</a>
	<!--vergilDocs-->
	<!--/bcvtbDocs-->
	).
	<!--bcvtbDocs-->
	<br>


	Ptolemy II models can, while executing, control their visual rendition
	in Vergil, the visual editor for Ptolemy II.
	In this example, a model alters the position in the Vergil diagram
	of one of its own actors.

	<br>



	<!--/vergilDocs-->
	<!-- GR does not get included in demosPtiny.htm -->
      </li>

      <li><i>Three-Dimensional Graphics</i>:
	<a href="../../domains/gr/demo/Pendulum/Pendulum.xml">Pendulum</a> (see also
	<a href="../../domains/gr/demo/Helen/Helen.xml">Helen</a>,
	<a href="../../domains/sdf/demo/Gravitation/Gravitation.xml">Gravitation</a>,
	<a href="../../domains/gr/demo/SolarSystem/SolarSystem.xml">SolarSystem</a>,
	<a href="../../domains/continuous/demo/StickyMasses/StickyMasses.xml">Sticky Masses</a>
	and <a href="../../domains/continuous/demo/BouncingBall/BouncingBall.xml">Bouncing Ball</a>).
	<br>


	<font color="red">NOTE: These models require that you have
	  installed Java 3D from Sun
	  (see https://java3d.dev.java.net/).</font>
	The <a href="../../domains/gr/demo/Pendulum/Pendulum.xml">Pendulum</a> example shows a continuous-time physical model of pendulum
	animated in the <i>graphics</i> (GR) domain, in which graphical components
	can be assembled and dynamically manipulated.  Note that clicking
	and dragging in the graphics window rotates the model.
	For further details, see the
	<a href="../../domains/gr/doc/main.htm">GR domain</a>.

	<br>


	<!--vergilDocs-->

      </li>

      <li><i>Statically Checked Units System</i>:
	<a href="../../data/unit/demo/StaticUnits/StaticUnits.xml">StaticUnits</a>
	<!--/bcvtbDocs-->
	<!-- Units includes ct.lib.Integrator, which is not shipped with BCVTB -->
	(see also
	<a href="../../data/unit/demo/Units/Units.xml">Units</a>, the
	dynamically checked units system).
	<!--bcvtbDocs-->
	<br>


	This model illustrates the use of the statically
	checked units system. A unit system
	defines a set of interrelated dimensions and measures. For example, in
	the time dimension, we might have seconds, minutes, hours, days, weeks,
	and fortnights. Ptolemy II includes two experimental units systems,
	one that is statically checked and one that is dynamically checked.

	<br>



      </li>

      <li><i>Network Integration</i>:
	<a href="../../moml/demo/Networked/Networked.xml">Networked</a>.<br>


	This example illustrates that models may be defined in a networked,
	distributed fashion.
	This model contains a component that is defined on the Ptolemy project
	website.  When you open the model, you will be alerted to the fact
	that it requires loading a model definition from a remote source.
	If you agree to proceed, then you will have a model with a remotely
	defined component.  The component itself is at
	<a href="http://ptolemy.eecs.berkeley.edu/xml/models/Waveform.xml#in_browser" target="_top">http://ptolemy.eecs.berkeley.edu/xml/models/Waveform.xml</a>.
	You can open that definition by clicking on the hyperlink, or by
	using the "Open URL" command in the File menu.

	<br>



      </li>

      <li><i>Audio</i>:
	<a href="../../actor/lib/javasound/demo/KarplusStrong/KarplusStrong.xml">KarplusStrong</a> (see also <a href="../../domains/sdf/demo/SoundSpectrum/SoundSpectrum.xml">SoundSpectrum</a>).
	<br>


	Ptolemy II includes actors that interface to the audio system on
	the executing machine, assuming it has one.
	This example shows the Karplus-Strong algorithm, which synthesizes
	a musical sound that closely resembles a plucked string instrument.
	It illustrates the audio capabilities of Ptolemy II.

	<br>



	<!--/ptinyKeplerDocs-->
	<!--/bcvtbDocs-->
      </li>
      <li><i>Python Integration</i>:
	<a href="../../actor/lib/python/demo/Ptolemnizer/Ptolemnizer.xml">Ptolemnizer</a>
	(see also <a href="../../actor/lib/python/demo/PythonScale/PythonScale.xml">PythonScale</a>).
	<br>

	Python is a popular interpreted programming language that has
	been integrated into Ptolemy II using the jython Java implementation of Python.
	This example shows that use of Python to alter a string entered by the user
	to modify any word that begins with "t" so that it begins with "pt".
	This leverages the excellent string processing capabilities in Python.
	Python can also be used to prototype
	actors by defining their functionality in Python.
	<!--ptinyKeplerDocs-->
	<!--bcvtbDocs-->

	<!--/vergilDocs-->
	<!--Ptiny does not include JAI or JMF-->

	<br>



      </li>

      <li><i>Image and Video Processing</i>:
	<a href="../../actor/lib/jai/demo/AdaptiveMedian/AdaptiveMedian.xml">AdaptiveMedian</a>
	(see also
	<a href="../../actor/lib/jai/demo/ImageReconstruction/ImageReconstruction.xml">ImageReconstruction</a>,
	<a href="../../actor/lib/jai/demo/VQSequenceDisplay/VQSequenceDisplay.xml">VQSequenceDisplay</a>,
	<a href="../../actor/lib/jmf/demo/VideoCapture/VideoCapture.xml">VideoCapture</a>).
	<br>


	If you install the optional packages JAI (Java advanced imaging) and
	JMF (Java media framework), then you can use a library of actors
	that operates on images and video signals, including video captured
	from a video camera.
	<!--vergilDocs-->

	<br>


      </li>

      <li><i>Fixed-Point Arithmetic</i>:
	<a href="../../domains/sdf/demo/FixFIR/FixFIR.xml">FixFIR</a>
	(see also
	<a href="../../domains/sdf/demo/FixPoint/FixPoint.xml">FixPoint</a>)
	<br>


	Ptolemy II data types include a fixed-point data type, where
	a model can explicitly control the binary representation of numbers
	and the mechanisms used to handle overflow and rounding.

      </li>

    </ul>



    <h2>
      <a name="libraries">Actor Libraries</a>
    </h2>


    Ptolemy II includes several actor libraries that provide sophisticated
    functions. A few of those are illustrated by the models here.
    <ul>



      <li><a href="../../domains/sdf/demo/Array/Array.xml">Array</a>:
	Actors that operate on matrices and arrays.

      </li>
      <!--/ptinyKeplerDocs-->
      <!--/bcvtbDocs-->
      <li> <a href="../../actor/lib/colt/demo/ColtRandom/ColtRandom.xml">ColtRandom</a>:
	Random number generators (based on Colt).
	<!--ptinyKeplerDocs-->

	<!--/vergilDocs-->
	<!--Ptiny does not include the security actors-->
      </li>

      <li> <a href="../../actor/lib/security/demo/Signature/Signature.xml">Signature</a>:
	Security actors (encryption and digital signatures).
	<!--vergilDocs-->
      </li>

      <li> <a href="../../actor/lib/comm/demo/TrellisDecoder/TrellisDecoder.xml">TrellisDecoder</a>:
	Communication library.

      </li>

    </ul>



    <!--/vergilDocs-->
    <!--experimental features do not get included in demosPtiny.htm -->
    <h2>
      <a name="experimental">Experimental Capabililties</a>
    </h2>


    <p>
      Ptolemy II has a number of less well-developed experimental
      capabilities that may continue to evolve over time.
      These are illustrated in the following examples.

    </p>

    <ul>



      <li> <a href="../../domains/ci/demo/Router/Router.xml">Push/Pull Component Interaction</a>.
	<br>


	The CI (component interaction) domain models communication between
	components that uses a combination of push and pull. This model
	illustrates the use of these styles of communication to route packets
	through queues using some policy that depends on the queue sizes.

	<br>



      </li>

      <li>Cal: an interpreted actor definition language.
	<a href="../../caltrop/demo/FunctionClosures/FunctionClosures.xml">Function Closures</a>,
	<a href="../../caltrop/demo/FunctionDefinition/FunctionDefinition.xml">Function Definition</a>,
	<a href="../../caltrop/demo/Primes/Primes.xml">Primes</a>,
	<a href="../../caltrop/demo/SDFDDI/SDFDDI.xml">SDFDDI</a>

	<br>



      </li>

      <li><a href="../../domains/dt/demo/Eye/Eye.xml">Discrete-Time Models</a>.
	<br>

	This example shows a simple pulse-amplitude modulation, physical
	layer communication system.  It illustrates the <i>discrete-time</i> (DT)
	domain, live parameter editing and
	the scope-style plotter (which shows an eye diagram).
	Note that discrete-time models can also be represented using the
	SDF domain, which is not explicit about the passage of time.

	<br>



      </li>

      <li> <a href="../../../ptolemy/cg/README.html">Code Generation</a>
	<br>

	This release includes a limited prototype of our code generation facility.
	This example leads to more information about this capability.

	<br>



      </li>

      <li><a href="../../domains/tm/demo/Controllers/Controllers.xml">Timed Multitasking</a>.<br>


	This example illustrates the <i>timed multitasking</i> (TM) domain,
	which is inspired by the Giotto language, and has features of
	priority-driven real-time operating systems. In this example,
	two control systems share a computational resource. Depending
	on the scheduling strategy chosen (preemptive or nonpreemptive)
	and the priorities, the two control systems may be both stable,
	or one may be stable, or the other may be stable.&nbsp;<span style="font-family: Arial;" lang="EN-US"></span></li>
      <li><a href="../../verification/README.html">Correctness Checking using Formal Methods</a>.<br>
	<span style="font-family: Arial;" lang="EN-US">This is an
	  ongoing project which tries to equip Ptolemy II with abilities to test the correctness
	  of a system using formal verification. Currently we develop a code generator to
	  convert Ptolemy II models into files accepted by model checker NuSMV.<a href="http://nusmv.irst.itc.it/#in_browser" target="_blank" target="_top"><span class="SpellE"></span></a></span></li>

      
    </ul>


    <!--vergilDocs-->
  </body>
</html>
