# Makefile for Ptolemy II Java deep code generation
#
# @Authors: Steve Neuendorffer, Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1998-2003 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY

# Root of the Java directory
ROOT =		@ptII@

CLASSPATH = 	$(ROOT)$(CLASSPATHSEPARATOR)$(ROOT)/lib/diva.jar$(CLASSPATHSEPARATOR)$(SOOT_CLASSES)$(CLASSPATHSEPARATOR)$(ROOT)/vendors/sun/commapi/comm.jar$(AUXCLASSPATH)@extraClassPath@

# Get configuration info
CONFIG =	$(ROOT)/mk/ptII.mk
include $(CONFIG)

# Used to build jar files
PTPACKAGE = 	@modelName@
PTCLASSJAR = 	$(PTPACKAGE).jar

# Keep this list alphabetized.
CSRCS = 	@cFiles@

JSRCS = 

JCLASS = 	@javaClasses@

OTHER_FILES_TO_BE_JARED = \
	$(JSRCS)

EXTRA_SRCS =	$(JSRCS) $(OTHER_FILES_TO_BE_JARED)

# Sources that may or may not be present, but if they are present, we don't
# want make checkjunk to barf on them.
MISC_FILES =	$(DIRS)

# make checkjunk will not report OPTIONAL_FILES as trash
# make distclean removes OPTIONAL_FILES
OPTIONAL_FILES = \
	doc

JCLASS = $(JSRCS:%.java=%.class)

all: jclass
	@echo "To run the generated code, run 'make runDemo'"
	@echo "Other rules include:"
	@echo "  make treeShake"
	@echo "  make runTreeShake"
	@echo "  make treeShakeAll"
	@echo "  make obfuscate"

install: all $(PTCLASSJAR)

MODEL =			@modelName@
MODELPATH =		@modelPath@

# Location where we create code that we are generating
TARGETPACKAGE = 	@targetPackage@
TARGETPATH =		@outDir@

TARGETCLASS = $(TARGETPACKAGE).$(MODEL)

# Package that the decompiler creates classes in
DECOMPILERTARGETPACKAGE =	$(TARGETPACKAGE)
# Directory that the decompiler creates classes in
DECOMPILERTARGETPATH =		$(TARGETPATH)

JVMSIZE = -Xmx256m

# Flags to java when collecting memory usage information.  This should
# (hopefully) prevent the incremental GC from being called prior to
# the application finishing. Additionally, it will report every time
# the GC is run.
GCLOGFILE = gclog.txt
MEMORYJFLAGS = -Xmx256m -Xms256m -Xint -Xloggc:$(GCLOGFILE)

# Soot command line arguments for the user.  To list all the arguments, use
# make COMPILEOPTIONS=-h
COMPILEOPTIONS=

# Time that we should let code generation run before exiting in ms.
WATCHDOGTIMEOUT =     600000
# Number of Iterations to run the generated code for.
ITERATIONS =		1000
ITERATIONSPARAMETER =	,iterations:$(ITERATIONS)

# Directories that contain snapshots.
SNAPSHOTS=jimple1 jimple2 jimple3 jimple4

# The statistics file for running comparisons.
STATSFILE=runSnapShot.stats

# The prefix for treeshaken jar files.
TREESHAKE_PREFIX = $(TARGETPATH)/treeshake

# The place where treeshake scripts are.
TREESHAKE=$(ROOT)/util/testsuite/treeshake

# The rule run by the long nightly build test: $PTII/util/testsuite/codegen.tcl
demo: compareAll

# The rule run by the regular nightly build quick smoke test: 
# copernicus/java/test
smokeTest: treeShake runTreeShake

# Run the final generated code.
# Note that the tests use runDemo in ptII/util/testsuite/codegen.tcl 
runDemo:
	@echo "Run the deep model"
	"$(JAVA)" $(MEMORYJFLAGS) \
	-Xfuture -classpath "$(TARGETPATH)$(CLASSPATHSEPARATOR)$(CLASSPATH)" \
	$(TARGETPACKAGE).Main 

# Run a complete profiling and compare the outputs.
compareAll: treeShakeAll profileAll compareTreeShakeJars

# TreeShake all versions of the generated code.
treeShakeAll: treeShakeWithoutCodegen  \
		treeShakeSnapshots \
		treeShake \
	 	obfuscate

# Profile all versions of the generated code.
profileAll: profileTreeShakeWithoutCodegen \
	profileTreeShakeSnapshots \
	profileTreeShake \
        profileObfuscate \

######################################################
# Rules for dealing with final codegen version
treeShake:
	@echo "Create the minimal jar file from the final codegen version"
	@echo "  using the jarClassList.txt file"
	@"$(TREESHAKE)" "$(JAR)" $(TREESHAKE_PREFIX)_codegen.jar \
		-c $(TARGETPATH)jarClassList.txt \
		-main $(TARGETPACKAGE).Main \
		"$(JAVA)" \
			-classpath "$(TARGETPATH)$(CLASSPATHSEPARATOR)$(CLASSPATH)" \
			$(TARGETPACKAGE).Main | tail -1
	@ls -l $(TREESHAKE_PREFIX)_codegen.jar;
	@echo "Run 'make runTreeShake' to run the tree shaken version"

treeShakeByRunning:
	@echo "Create the minimal jar file from the final codegen version"
	@"$(TREESHAKE)" "$(JAR)" $(TREESHAKE_PREFIX)_codegen.jar \
		-main $(TARGETPACKAGE).Main \
		"$(JAVA)" \
			-classpath "$(TARGETPATH)$(CLASSPATHSEPARATOR)$(CLASSPATH)" \
			$(TARGETPACKAGE).Main | tail -1
	@ls -l $(TREESHAKE_PREFIX)_codegen.jar;
	@echo "Run 'make runTreeShake' to run the tree shaken version"

runTreeShake:
	@echo "Run the final codegen version"
	@echo "Note that you can run the codegen version by hand with"
	@echo "  java -jar $(TREESHAKE_PREFIX)_codegen.jar"
	"$(JAVA)" -classpath $(TREESHAKE_PREFIX)_codegen.jar \
			$(TARGETPACKAGE).Main

profileTreeShake:
	@echo "Profile the final codegen version"
	@echo "Note that you can run the codegen version by hand with"
	@echo "  java -jar $(TREESHAKE_PREFIX)_codegen.jar"
	@rm -f  $(STATSFILE)
	@for repeat in 1 2 3 4; \
	do \
		"$(JAVA)" $(MEMORYJFLAGS) \
			-classpath $(TREESHAKE_PREFIX)_codegen.jar \
			$(TARGETPACKAGE).Main | tail -1 | \
			tee -a $(STATSFILE); \
                "$(ROOT)/util/testsuite/gcstats" < "$(GCLOGFILE)" | tee -a $(STATSFILE); \
	done
	@"$(ROOT)/util/testsuite/memorystats" "$(MODEL) codegen" < $(STATSFILE);
	@rm -f $(STATSFILE)

######################################################
# Rules for dealing with original model
treeShakeWithoutCodegen:
	@echo "Treeshake $(MODEL) without codegen"
	@CLASSPATH="$(CLASSPATH)" \
		"$(TREESHAKE)" "$(JAR)" $(TREESHAKE_PREFIX).jar \
			-main ptolemy.copernicus.java.TestApplication \
			"$(JAVA)" \
			ptolemy.copernicus.java.TestApplication \
			"$(MODELPATH)" \
			| tail -1
	ls -l $(TREESHAKE_PREFIX).jar

runTreeShakeWithoutCodegen:
	@echo "Run the final codegen version"
	@echo "Note that you can run the original version by hand with"
	@echo "  java -jar $(TREESHAKE_PREFIX).jar"
	"$(JAVA)" -classpath $(TREESHAKE_PREFIX).jar \
			$(TARGETPACKAGE).Main

profileTreeShakeWithoutCodegen:
	@echo "Prorile without codegen with treeshake.jar"
	@rm -f  $(STATSFILE)
	@for repeat in 1 2 3 4; \
	do \
		"$(JAVA)" $(MEMORYJFLAGS) \
			-classpath $(TREESHAKE_PREFIX).jar \
			ptolemy.copernicus.java.TestApplication \
			$(MODELPATH) | tail -1 | \
			tee -a $(STATSFILE); \
                "$(ROOT)/util/testsuite/gcstats" < "$(GCLOGFILE)" |\
			tee -a $(STATSFILE); \
	done
	"$(ROOT)/util/testsuite/memorystats" "$(MODEL) interpreted" < $(STATSFILE)

######################################################
# Rules for dealing with snapshots
treeShakeAndProfileSnapshots: treeShakeSnapshots runTreeShakeSnapshots

treeShakeSnapshots:
	@echo "Treeshake $(MODEL) snapshots"
	for snapshot in $(SNAPSHOTS); \
	do \
		echo "Treeshake $$snapshot"; \
		"$(TREESHAKE)" "$(JAR)" $(TREESHAKE_PREFIX)_$${snapshot}.jar \
			-c $(TARGETPATH)/$${snapshot}/jarClassList.txt \
			-main $(TARGETPACKAGE).Main \
			"$(JAVA)" -Xfuture -classpath \
		"$(TARGETPATH)/$$snapshot$(CLASSPATHSEPARATOR)$(CLASSPATH)" \
					$(TARGETPACKAGE).Main | tail -1 ; \
		ls -l $(TREESHAKE_PREFIX)_$${snapshot}.jar; \
	done	

runTreeShakeSnapshots:
	@echo "Treeshake $(MODEL) snapshots"
	for snapshot in $(SNAPSHOTS); \
	do \
		echo "Run the code from $(TARGETPATH)/$${snapshot}"; \
		"$(JAVA)" -classpath $(TREESHAKE_PREFIX)_$${snapshot}.jar \
			$(TARGETPACKAGE).Main; \
	done

profileTreeShakeSnapshots:
	@echo "Treeshake $(MODEL) snapshots"
	for snapshot in $(SNAPSHOTS); \
	do \
		echo "Profile the code from $(TARGETPATH)/$${snapshot}"; \
		rm -f  $(STATSFILE); \
		for repeat in 1 2 3 4; \
		do \
			"$(JAVA)" $(MEMORYJFLAGS) \
				-classpath $(TREESHAKE_PREFIX)_$${snapshot}.jar \
				$(TARGETPACKAGE).Main | tail -1 | \
				tee -a $(STATSFILE); \
	                "$(ROOT)/util/testsuite/gcstats" < "$(GCLOGFILE)" |\
				tee -a $(STATSFILE); \
		done; \
		"$(ROOT)/util/testsuite/memorystats" "$(MODEL) $$snapshot" < $(STATSFILE); \
	done

# Compare codegen to original jar file.
compareTreeShakeJars:
	@echo "See ${TREESHAKE_PREFIX}_jardiff.txt"
	@echo "  for the .class files are present in the regular jar,"
	@echo "  but not in the codegen jar"
	@"$(JAR)" -tvf ${TREESHAKE_PREFIX}.jar | \
		awk '{print $$NF}' | sort > /tmp/treeshake_toc
	@"$(JAR)" -tvf ${TREESHAKE_PREFIX}_codegen.jar | \
		awk '{print $$NF}' | sort > /tmp/treeshake_codegen_toc
	@comm -23 /tmp/treeshake_toc /tmp/treeshake_codegen_toc \
		> ${TREESHAKE_PREFIX}_jardiff.txt
	@rm -f /tmp/treeshake_toc /tmp/treeshake_codegen_toc	
	ls -l ${TREESHAKE_PREFIX}*.jar

############################################################################
# Rules to run the jode obfuscator
# Jode is a java decompiler.  It is useful for looking at the contents of 
# class files.  It can be downloaded from 
# http://jode.sourceforge.net/download.php
#
# Jode is full GPL, so we can't distribute it without making Ptolemy GPL'd
#
# Jode can be downloaded from
# http://jode.sourceforge.net/download.php

obfuscate:
	"$(ROOT)/bin/obfuscate" "\"$(TARGETPATH)/obfuscateScript.jos\""
	@ls -l treeshake_codegen_obfuscated.jar
	@echo "run 'make runObfuscate' to run the obfuscated code"

runObfuscate: 
	@echo "Run the final obfuscated version"
	"$(JAVA)" -classpath treeshake_codegen_obfuscated.jar \
		$(TARGETPACKAGE).Main

profileObfuscate:
	@echo "Profile the final obfuscated version"
	@rm -f  $(STATSFILE)
	@for repeat in 1 2 3 4; \
	do \
		"$(JAVA)" $(MEMORYJFLAGS) \
			-classpath treeshake_codegen_obfuscated.jar \
			$(TARGETPACKAGE).Main | tail -1 | \
			tee -a $(STATSFILE); \
                "$(ROOT)/util/testsuite/gcstats" < "$(GCLOGFILE)" | tee -a $(STATSFILE); \
	done
	@"$(ROOT)/util/testsuite/memorystats" "$(MODEL) codegen" < $(STATSFILE);
	@rm -f $(STATSFILE)


############################################################################
# Rules to run gcj, the GNU Java -> Native compiler
# This code is very experimental, and not likely to work

GCJ_DIR =	c:

# The GNU C/Java compiler 
GCJ =		$(GCJ_DIR)/bin/gcj
GCJ_LIBDIR =	$(GCJ_DIR)/lib

# GCJ Options, see http://gcc.gnu.org/onlinedocs/
# If there is no -g or -O option, then the default is -g1
#GCJ_FLAGS =	-static
GCJ_FLAGS =	-pg -g0 -O3 -fno-bounds-check

# GCJ flags used at link time
#GCJ_LINK_FLAGS = -v -Wl,-R,$(GCJ_LIBDIR)
GCJ_LINK_FLAGS = -v
# -L$(GCJ_LIBDIR) should be first so we get the right libgcj.spec
#GCJ_LINK_LIBS =  -L$(GCJ_LIBDIR)

#  GCJ only needs one rule now!
gcj:    
	@echo "Running GCJ on treeshake_codegen.jar"
	$(GCJ) $(GCJ_FLAGS) --main=$(TARGETPACKAGE).Main -o $(MODEL)_gcj $(TARGETPATH)/treeshake_codegen.jar


gcjOld:
	echo "To compile a demo with gcj:" 
	echo " 1) Run 'make gcjSetup gcjFix'"
	echo " 2) Fix CGoutputBitDisplay.java so that 'make gcjFixCompile' works"
	echo " 3) Run 'make gcj2'"
	echo " 4) Run 'make gcjRun'"

gcjSetup:	demo treeShake runTreeShake


gcjFix: $(TARGETPATH)/CGoutputBitDisplay.java
$(TARGETPATH)/CGoutputBitDisplay.java:
	@echo "gcj fails with stack underflow on CGoutputBitDisplay,"
	@echo " so we regenerate"
	cd $(TARGETPATH); \
		"$(PTII)/bin/jode" \
		ptolemy.copernicus.java.cg.OrthogonalCom.CGoutputBitDisplay | \
		awk '{if ($$0 ~ /^package /) {printit=1}; if (printit == 1) { print $$0}} ' | \
		sed 's@final@/* final */@g' > CGoutputBitDisplay.java
	@echo "Now edit $(TARGETPATH)/CGoutputBitDisplay.java"
	@echo "and run make gcjFixCompile"

gcjFixCompile:
	cd $(TARGETPATH); \
		$(JAVAC) -classpath "$(PTII)" CGoutputBitDisplay.java

gcj1:
	@echo "---- This will fail during linking because of missing"
	@echo "     classes like actor.lib.Sequence and util.StringUtilities"
	cd $(TARGETPATH); \
		CLASSPATH=$(PTII) \
		$(GCJ) $(GCJ_FLAGS) \
			--main=ptolemy.copernicus.java.cg.$(MODEL).Main \
			-o ortho *.class;

gcj2: $(TARGETPATH)/gcj gcj2_0 gcj2_1 gcj2_2

# Unjar the treeshake_codegen jar file for use with gcj
# Use $(TARGETPATH)/treeshake_codegen.jar insetead of
# $(TREESHAKE_PREFIX)_codegen.jar because of relative path name problems
unjar_treeshake_codegen: $(TARGETPATH)/gcj
$(TARGETPATH)/gcj: $(TARGETPATH)/treeshake_codegen.jar
	rm -rf $@
	mkdir $@
	cd $@; jar -xf "$(TARGETPATH)/treeshake_codegen.jar"

# A list of directories that are required to compile the treeshaken directories
# This is necessary because we treeshake by class, so the .class files
# that the treeshaker includes may have methods that are not called
# that contain references to classes that were not included in the
# treeshaker output.  However, gcj does a C style link, where all
# the symbols in a .o file must be resolved.  So we include these
# other classes.
GCJ_AUX_DIRS = ptolemy/data/expr ptolemy/data/unit ptolemy/data ptolemy/kernel/util ptolemy/graph ptolemy/data/type ptolemy/actor ptolemy/kernel ptolemy/util ptolemy/graph/analysis ptolemy/actor/util ptolemy/kernel/attributes

GCJ_TO_BE_REMOVED = ptolemy/util/XSLTUtilities.class \
	ptolemy/data/expr/NotEditableParameter.class \
	ptolemy/actor/MobileFunction.class \
	ptolemy/actor/MobileModel.class

gcj2_0: $(TARGETPATH)/gcj
	@echo "For each directory in the treeshaken output,"
	@echo "Copy all the class files from corresponding directory"
	@echo "in $PTII"
	@echo " Ignore any '*.class not found' messages" 
	cd $(TARGETPATH)/gcj; \
		dirs=`find . -type d -print`; \
		for dir in $$dirs; \
		do \
			files=`ls -1 $$dir/*.class | awk 'END {print NR}'`; \
			if [ $$files -gt 1 ]; then \
				echo "---Copying .class files from \$$PTII to $$dir"; \
				cp $(PTII)/$$dir/*.class $$dir; \
			fi; \
		done; \
		for dir in $(GCJ_AUX_DIRS); \
		do \
			if [ ! -d $$dir ]; then \
				mkdir -p $$dir; \
			fi; \
			echo "---Copying aux .class from \$$PTII to $$dir"; \
			cp $(PTII)/$$dir/*.class $$dir; \
		done;
	(cd $(TARGETPATH)/gcj; rm -f $(GCJ_TO_BE_REMOVED))


gcj2_1:
	@echo "--- Run gcj on all the .class files in the jar file dir"
	cd $(TARGETPATH)/gcj; \
		dirs=`find . -type d -print`; \
		for dir in $$dirs; \
		do \
			files=`ls -1 $$dir/*.class 2>&1 | awk '$$1 ~ /.class$$/ {c++}  END {print c}'`; \
			if [ $$files -gt 1 ]; then \
				echo "$$retval---Running gcj in $$dir"; \
				(cd $$dir; CLASSPATH="."; \
					$(GCJ) -g -c \
					$(GCJ_FLAGS) \
					--CLASSPATH=$(TARGETPATH)/gcj \
					*.class); \
			fi; \
		done;

gcj2_2:
	@echo "--- Run gcj on all the .o files in the jar file dir"
	@echo "    Note that here, we end up needing .class files other"
	@echo "    than the ones in the tree shaken jar file"
	cd $(TARGETPATH)/gcj; \
		objs=`find . -name "*.o" -print | awk -F / '{for (i=1;i<NF;i++) {printf("%s/", $$i) } printf("*.o\n")}' | sort | uniq`; \
		$(GCJ) -g --main=ptolemy.copernicus.java.cg.$(MODEL).Main \
			$(GCJ_FLAGS) \
			$(GCJ_LINK_FLAGS) \
			-o $(MODEL)_gcj $$objs \
			$(GCJ_LINK_LIBS);
	ls -l $(TARGETPATH)/gcj/$(MODEL)_gcj

gcjRun:
	cd $(TARGETPATH)/gcj; \
		./$(MODEL)_gcj

gcjRunStats:
	@echo "Run the gcj output and collect stats"
	@rm -f  $(STATSFILE)
	@for repeat in 1 2 3 4; \
	do \
		(cd $(TARGETPATH)/gcj; \
			./$(MODEL)_gcj) | tail -1 | \
			tee -a $(STATSFILE); \
	done
	"$(ROOT)/util/testsuite/memorystats" "$(MODEL) gcj" < $(STATSFILE);
	@rm -f $(STATSFILE)

gcj_decompile:
	@echo "--- Decompile .class files in gcj"
	decompilerTargetPath=`echo $(TARGETPACKAGE) | sed 's@\.@/@g'`; \
	CLASSPATH=foo $(MAKE) \
		AUXCLASSPATH=$(CLASSPATHSEPARATOR)$(TARGETPATH)gcj \
		DECOMPILERTARGETPATH=$(TARGETPATH)gcj/$$decompilerTargetPath \
		jodeDecompileDemo

GDB=/usr/local/bin/gdb 
gcjGdb:
	echo "handle SIGPWR nostop noprint" > .gdbinit
	echo "handle SIGXCPU nostop noprint" >> .gdbinit
	echo "directory $(PTII)" >> .gdbinit 
	$(GDB) $(TARGETPATH)/gcj/$(MODEL)_gcj



AR =		ar
LIBNONSHAREDSUFFIX =	a
RANLIB =	ranlib
LIBDIR =	$(TARGETPATH)/gcj/lib
gcj3_1:
	@echo "--- Determine what directories are in the jar file"
	@echo "    then create libraries in "
	@echo "    $(TARGETPATH)/gcj/lib/"
	if [ ! -d $(TARGETPATH)/gcj/lib ]; then \
		echo "making $(TARGETPATH)/gcj/lib"; \
		mkdir $(TARGETPATH)/gcj/lib; \
	fi
	cd $(TARGETPATH)/gcj; \
		dirs=`find . -type d -print`; \
		echo "dirs=$$dirs"; \
		for dir in $$dirs; \
		do \
			files=`ls -1 $$dir/*.o | awk 'END {print NR}'`; \
			if [ $$files -gt 1 ]; then \
				echo "---Running ar in $$dir"; \
				ptlib=lib`basename $$dir`.$(LIBNONSHAREDSUFFIX); \
				(cd $$dir; \
					pwd; \
					rm -f $$ptlib; \
					$(AR) cq $$ptlib \
						*.o; \
					$(RANLIB) $$ptlib; \
					rm -f $(LIBDIR)/$$ptlib; \
					ln $$ptlib \
						$(LIBDIR); \
					); \
			fi; \
		done;
		ls -l $(LIBDIR)


gcj3_2:
	@echo "--- Link using the libraries in "
	@echo "    $(TARGETPATH)/gcj/lib/"
	cd $(TARGETPATH)/gcj; \
		$(GCJ) -g --main=ptolemy.copernicus.java.cg.$(MODEL).Main \
			$(GCJ_FLAGS) \
			$(GCJ_LINK_FLAGS) \
			-o $(MODEL)_lib_gcj  \
			$(TARGETPATH)/*.o \
			ptolemy/data/Numerical.o \
			$(GCJ_LINK_LIBS) \
			-L$(LIBDIR) \
			-ldata -lexpr -ltype -lunit -lexpr -ldata -lmath -lgraph -lutil;
	ls -l $(TARGETPATH)/gcj/$(MODEL)_lib_gcj

############################################################################
# Rules to run the jode as a decompiler
# Jode is a java decompiler.  It is useful for looking at the contents of 
# class files.  It can be downloaded from 
# http://jode.sourceforge.net/download.php
#
# Jode is full GPL, so we can't distribute it without making Ptolemy GPL'd
#
# Jode can be downloaded from
# http://jode.sourceforge.net/download.php
JODE=$(ROOT)/bin/jode
# Class to disassemble
DECOMPILERTARGETCLASS =		CGModel$(MODEL)

# Generate a .java file from a class file and recompile it.
# Jode
jodeDecompile: jodeDecompileDemo jodeRecompileDemo jodeRunRecompiledDemo
jodeDecompileDemo:
	@echo "Convert .class file back to .java file, compile it, run it"
	classes=`cd $(DECOMPILERTARGETPATH); ls -1 *.class | sed 's/.class//g'`; \
	for class in $$classes; \
	do \
		echo "--- Decompiling $(DECOMPILERTARGETPACKAGE).$$class"; \
		"$(JODE)" -d $(DECOMPILERTARGETPATH) $(DECOMPILERTARGETPACKAGE).$$class; \
		relativetargetpath=`echo $(TARGETPACKAGE) | sed 's@\.@/@g'`; \
		sh "$(ROOT)/ptolemy/copernicus/shallow/test/jode2java" \
			$$relativetargetpath/$$class.java \
				> jodeDecompile.java; \
		mv jodeDecompile.java $$relativetargetpath/$$class.java; \
	done

jodeRecompileDemo:
	relativetargetpath=`echo $(TARGETPACKAGE) | sed 's@\.@/@g'`; \
	$(JAVAC) -classpath \
		"$(DECOMPILERTARGETPATH)$(CLASSPATHSEPARATOR)$(ROOT)" \
		-d $(DECOMPILERTARGETPATH)$$relativetargetpath \
		$(DECOMPILERTARGETPATH)$$relativetargetpath/$(DECOMPILERTARGETCLASS).java

jodeRunRecompiledDemo:
	$(JAVA) $(MEMORYJFLAGS) -Xfuture -classpath "$(DECOMPILERTARGETPATH)$(CLASSPATHSEPARATOR)$(ROOT)" \
		ptolemy.actor.gui.CompositeActorApplication \
		-class $(TARGETPACKAGE).CG$(MODEL)

# Generate .java files from the snapshots
jadDecompile:
	$(JAD) -r -o -d $(TARGETPATH)/jad $(TARGETPATH)/*.class; \
	for file in $(TARGETPATH)/jad/$(TARGETPATH)/*.jad; \
	do \
		echo "Fixing $$file"; \
		javafile=`dirname $$file`/`basename $$file .jad`.java;\
		sh $(ROOT)/ptolemy/copernicus/shallow/test/jad2java $$file \
				> $$javafile; \
		echo "Compiling $$javafile"; \
		$(JAVAC) -classpath "$(TARGETPATH)/jad$(CLASSPATHSEPARATOR)$(ROOT)" \
			$$javafile; \
	done; \

# Generate .java files from the snapshots
recompileSnapshots:
	for snapshot in $(SNAPSHOTS); \
	do \
		echo "Recompiling in $(TARGETPATH)/$$snapshot"; \
		$(JAD) -r -o -d $(TARGETPATH)/$$snapshot/jad $(TARGETPATH)/$$snapshot/$(TARGETPATH)/*.class; \
		for file in $(TARGETPATH)/$$snapshot/jad/$(TARGETPATH)/*.jad; \
		do \
			echo "Fixing $$file"; \
			javafile=`dirname $$file`/`basename $$file .jad`.java;\
			sh ../shallow/test/jad2java $$file \
				> $$javafile; \
			echo "Compiling $$javafile"; \
			$(JAVAC) -classpath "$(TARGETPATH)/$$snapshot/jad$(CLASSPATHSEPARATOR)$(ROOT)" \
				$$javafile; \
		done; \
	done

sootDecompile:
	@echo "Convert .class file back to .java file, using soot"
	echo "--- Decompiling $(TARGETPACKAGE).Main";\
	soot -cp '"$(TARGETPATH)$(CLASSPATHSEPARATOR)$(CLASSPATH)"' -f d `cat jarClassList.txt`

###############################
# C compilation rules

# Standard variables
RUNTIME = $(ROOT)/ptolemy/copernicus/c/runtime
NATIVE_BODIES = $(ROOT)/runtime/native_bodies/
OVER_BODIES = $(ROOT)/runtime/over_bodies/
# Make a param
LIB = $(ROOT)/ptolemy/copernicus/c/test/testOutput/j2c_lib
LIB_FILE = $(LIB)/j2c_lib.a
CFLAGS = -g -Wall -Wno-trigraphs
DEPEND = gcc -Wno-trigraphs -MM -I $(RUNTIME) -I $(LIB) -I $(NATIVE_BODIES) -I $(OVER_BODIES)

THIS = makefile
SOURCES = @cFiles@

LIB_SOURCES = @cLibFiles@

OBJECTS = $(SOURCES:.c=.o)
HEADERS = $(SOURCES:.c=.h)
IHEADERS = $(SOURCES:.c=_i.h)

LIB_OBJECTS = $(LIB_SOURCES:.c=.o)
LIB_HEADERS = $(LIB_SOURCES:.c=.h)
LIB_IHEADERS = $(LIB_SOURCES:.c=_i.h)

@modelName@.exe : $(OBJECTS) $(LIB_FILE)
	gcc -g $(OBJECTS) $(LIB_FILE) -o @modelName@.exe
.c.o:
	gcc $(CFLAGS) -c  -I $(RUNTIME) -I $(LIB) -I $(NATIVE_BODIES) $< -o $@ 

$(LIB_FILE): $(LIB_OBJECTS)
	ar r $(LIB_FILE) $(LIB_OBJECTS)
	ranlib $(LIB_FILE)

.PHONY:depend

depend:
	$(DEPEND) $(SOURCES)>makefile.tmp;\
	cat $(THIS) makefile.tmp > @modelName@.mk;\
	rm makefile.tmp;

#clean:
#	rm $(OBJECTS) $(LIB_OBJECTS) $(LIB_FILE);

# Get the rest of the rules
include $(ROOT)/mk/ptcommon.mk

