/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. PtParser.jj */
/*@egen*//*                        -*- Mode: java -*-                     */
/* Input file to JJTree and JavaCC to generate Ptolemy II Parser */

options {
LOOKAHEAD=1;                                                                      
STATIC = false;                          
}

PARSER_BEGIN(PtParser)
/* 
 Copyright (c) 1998-2002 The Regents of the University of California.
 All rights reserved.
 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.
 
                                        PT_COPYRIGHT_VERSION_2
                                        COPYRIGHTENDKEY

@ProposedRating Yellow (nsmyth@eecs.berkeley.edu)
@AcceptedRating Yellow (yuhong@eecs.berkeley.edu)

Created : May 1998

*/

package ptolemy.data.expr;

import ptolemy.kernel.*;
import ptolemy.kernel.util.*;
import ptolemy.data.*;
import ptolemy.math.Complex;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.StringTokenizer;

import java.io.*;

//////////////////////////////////////////////////////////////////////
//// PTParser.jjt
/** 
This file implements an expression parser for Ptolemy II using the 
JavaCC parser generator. It can handle all the basic arithmetic operators
(*, /, +, -,, %), relational operators (<, <=, >, >=, == !=), logical 
operators(&&, ||, !), bitwise operators (&, |, ^, ~)  and, using 
reflection, all of the functionality available in the java.lang.Math 
package. 
<p>
By editing the ASTFunctionNode file it is also relatively 
easy to allow references to other functions. This provides an easy mechanism 
to extend the range to the parser e.g. have a tcl(...) function 
that passes the string to a Tcl interpreter and retuns the result.
<p>
Functional if is supported via the following syntax:
        (boolean) ? (value1) : (value2)
<p>
Extensibility is also supported by allowing method calls on the Tokens,
the syntax is 
        (value1).method(comma separated arguments)
<p>
JavaCC by itself simply generates a file (and support files) that allow an 
input to be parsed, it does not return a parse tree. For the purposes of 
type checking we require a parse tree, and this is obtained using JJTree, a 
preprocesssor for JavaCC. 
<p>
JJtree operates by annotating the grammar file to support the generation
of the parse tree. Thus the process is
<p>
<center>X.jjt --> JJTREE --> X.jj --> JAVACC --> X.java + support files
<br>
</CENTER>
<p>
The parser can also be passed a symbol table of ptolemy.data.expr.Variables
which the expression to be parsed can reference.
<p>
Anything between quotes(") or apostrophes(') is taken to be one string.
Strings are not allowed to contain newlines or carriage returns. These
characters, as well as other special characters, can be escaped using the
standard Java syntax (\n, \t, \077, etc.).
<p>
The expressions recognized follow as close as possible the syntax of Java.
In particular the operator precedences implemented here follow exactly 
those in Java. Any type conversions that are performed are lossless. If 
the user wants lossy conversions, explicit casts will be necessary.
<p>
Complex number are specified by an i or j after the imaginary part 
of the number. Long numbers are specified by an l or L after an 
integer number.
<p>
Users can register constants with the parser and also register classes
where functions that may be called are defined. For a more 
thorough description of what the Parser is designed to do, 
please consult the Ptolemy II design document (or contact nsmyth@eecs)
<p>
@author Neil Smyth
@version $Id$

@see ptolemy.data.expr.ASTPtBitwiseNode
@see ptolemy.data.expr.ASTPtFunctionNode
@see ptolemy.data.expr.ASTPtFunctionalIfNode
@see ptolemy.data.expr.ASTPtLeafNode
@see ptolemy.data.expr.ASTPtLogicalNode
@see ptolemy.data.expr.ASTPtMethodCallNode
@see ptolemy.data.expr.ASTPtProductNode
@see ptolemy.data.expr.ASTPtRelationalNode
@see ptolemy.data.expr.ASTPtRootNode
@see ptolemy.data.expr.ASTPtSumNode
@see ptolemy.data.expr.ASTPtUnaryNode
@see ptolemy.data.Token 
*/
public class PtParser/*@bgen(jjtree)*/implements PtParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPtParserState jjtree = new JJTPtParserState();

/*@egen*/
    
    boolean debug = false;
    
    public PtParser(Variable owner) {
        this(new ByteArrayInputStream("a hack!!".getBytes()));
        _initialize();
        _owner = owner;
    }

    public PtParser() {
        this(new ByteArrayInputStream("a hack!!".getBytes()));
        _initialize();
    }
   
    /** Returns the list of undefined variables after parsing the given String.
     *  @param stringIn The expression to be parsed
     *  @exception IllegalActionException If the parse fails.
     *  @return The list of undefined variables.
     */
    public LinkedList getUndefinedList(String stringIn)
            throws IllegalActionException {
        InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
        _scope = null;
        _parserScope = null;
	this.ReInit(stream);
        //debug = true;
        String str = stringIn.replace('\n', ' ');
        try {
            // Parse the expression to obtain the parse tree
            _undefined = new LinkedList();
            ASTPtRootNode rootNode = start();
            if (debug) rootNode.displayParseTree(" ");
            return _undefined;
        } catch (ParseException x) {
            throw new IllegalActionException("Error parsing expression \""
                    + stringIn + "\":\n" + x.getMessage());
        }
    }  

   
    /** Generates a parse tree from the given String. The root node is 
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed
     *  @exception IllegalActionException If the parse fails.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode generateParseTree(String stringIn)
            throws IllegalActionException {
        InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
        _scope = null;
        _parserScope = null;
	this.ReInit(stream);
        //debug = true;
        String str = stringIn.replace('\n', ' ');
        try {
            // Parse the expression to obtain the parse tree
            _undefined = null;
            ASTPtRootNode rootNode = start();
            if (debug) rootNode.displayParseTree(" ");
            return rootNode;
        } catch (ParseException x) {
            throw new IllegalActionException("Error parsing expression \""
                    + stringIn + "\":\n" + x.getMessage());
        }
    }  

    /** Generates a parse tree from the given String. The root node is 
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed.
     *  @param scope Variables to which the expression can refer.
     *  @exception IllegalActionException If the parse fails.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode generateParseTree(String stringIn, NamedList scope) 
            throws IllegalActionException {
        InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
        _scope = scope;
        _parserScope = null;
        this.ReInit(stream);
        String str = stringIn.replace('\n', ' ');
	ASTPtRootNode rootNode;
        try {
            // Parse the expression to obtain the parse tree
            _undefined = null;
            rootNode = start();
            if (debug) rootNode.displayParseTree(" ");
        } catch (ParseException x) {
            throw new IllegalActionException("Error parsing expression \""
                    + stringIn + "\":\n" + x.getMessage());
        }
        return rootNode;
    }

    /** Generates a parse tree from the given String. The root node is
     *  returned. To evaluate the parse tree, the method evaluateParseTree()
     *  should be called on the rootNode
     *  @param stringIn The expression to be parsed.
     *  @param scope Variables to which the expression can refer.
     *  @exception IllegalActionException If the parse fails.
     *  @return The root node of the parse tree.
     */
    public ASTPtRootNode generateParseTree(String stringIn,
            ParserScope scope) throws IllegalActionException {
        InputStream stream = new ByteArrayInputStream(stringIn.getBytes());
        _scope = null;
        _parserScope = scope;
        this.ReInit(stream);
        String str = stringIn.replace('\n', ' ');
        ASTPtRootNode rootNode;
        try {
            // Parse the expression to obtain the parse tree
            _undefined = null;
            rootNode = start();
            if (debug) rootNode.displayParseTree(" ");
        } catch (ParseException x) {
            throw new IllegalActionException("Error parsing expression \""
                    + stringIn + "\":\n" + x.getMessage());
        }
        return rootNode;
    }
               
    /** Return the list of classes the parser searches 
     *  when a function call is encountered. 
     *  It is a static method. It stores the classes in a LinkedList. The 
     *  classes are searched in the same order that they were registered 
     *  with the parser, so the classes that are most likely to be 
     *  searched should be registered first.
     */
    public static LinkedList getRegisteredClasses() {
        if (_classesSearched == null) {
            _classesSearched = new LinkedList();
        }
        return _classesSearched;
    }
    
    /** Return the list of Variables that comprise the current scope.
     *  @return The current scope.
     */	
    public NamedList getScope() {
        if (_parserScope != null)
            return _parserScope.attributeList();
        else
            return _scope;
    }
	

    /** Add a constant to the list of constants that the parser recognizes.
     *  It is a static method. The constants are stored in a hash table by
     *  the Constants class. The entry for each name is a ptolemy.data.Token 
     *  of the appropriate type. The value for the constant can be given
     *  in a ptolemy.data.Token or in one of the data wrapper classes 
     *  in java.lang.
     *  @param name The string name that the parser will recognize.
     *  @param value An Object constraining the value associated with 
     *   the constant.
     *  @exception IllegalArgumentException If the constant cannot
     *   be registered with the parser.
     */
    public static void registerConstant(String name, Object value) 
            throws IllegalArgumentException {
        if ( (value == null) || (name == null)) {
            throw new IllegalArgumentException("PtParser: cannot register " +
                    "a constant if either the name or value object is null.");
        }
        ptolemy.data.Token tmp;
        if  (value instanceof ptolemy.data.Token) {
            tmp = (ptolemy.data.Token)value;
        } else if (value instanceof Integer) {
            tmp = new IntToken(((Integer)value).intValue());
        } else if (value instanceof Double) {
            tmp = new DoubleToken(((Double)value).doubleValue());   
        } else if (value instanceof Long) {
            tmp = new LongToken(((Long)value).longValue());   
        } else if (value instanceof String) {
            tmp = new StringToken((String)value);   
        } else if (value instanceof Boolean) {
            tmp = new BooleanToken(((Boolean)value).booleanValue());
        } else if (value instanceof Complex) {
            tmp = new ComplexToken((Complex)value);
        } else {
            throw new IllegalArgumentException("PtParser: cannot register " +
                    name + "  as a constant of the parser.");
        }
        Constants.add(name, tmp); 
        return;
    }
      
    /** Add a class to the list of classes that the parser searches 
     *  when a function call is encountered. 
     *  It is a static method. It stores the classes in a LinkedList. The 
     *  classes are searched in the same order that they were registered 
     *  with the parser, so the classes that are most likely to be 
     *  searched should be registered first.
     *  @param newClassName The fully qualified name of the Class to 
     *   be added to the search path for functions.
     *  @exception IllegalArgumentException If the Class named by the 
     *   argument cannot not be found.
     */
    public static void registerFunctionClass(String newClassName)
            throws IllegalArgumentException {
        if (_classesSearched == null) {
            _classesSearched = new LinkedList();
        }
        try {
            Class newClass = Class.forName(newClassName);
            _classesSearched.add((Object)newClass);
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException("PtParser.registerClass: " +
                     "Could not find " + newClassName + ".");
        }
        CachedMethod.clear();
    }

    /*  The Variable creating the parser. 
     *  Each time another variable is referenced in the input expression, 
     *  this Variable is registered as a listener of that Variable. 
     *  If null, then no dependency is registered.
     */
    protected Variable _owner;

    /** Initialize the static variable containing the classes searched by
     *  the parser upon encountering a function call.
     */
    private void _initialize() {
        if (!_alreadyInitialized) {
            //System.out.println("Initializing...");
            _alreadyInitialized = true;
            registerFunctionClass("java.lang.Math");
            registerFunctionClass("java.lang.Double");
            registerFunctionClass("java.lang.String");
            registerFunctionClass("ptolemy.data.expr.UtilityFunctions");
            registerFunctionClass("ptolemy.data.expr.FixPointFunctions");
            registerFunctionClass("ptolemy.math.Complex");
            registerFunctionClass("ptolemy.math.ExtendedMath");
	    registerFunctionClass("ptolemy.math.IntegerMatrixMath");
	    registerFunctionClass("ptolemy.math.DoubleMatrixMath");
	    registerFunctionClass("ptolemy.math.ComplexMatrixMath");
	    registerFunctionClass("ptolemy.math.LongMatrixMath");
	    registerFunctionClass("ptolemy.math.IntegerArrayMath");
	    registerFunctionClass("ptolemy.math.DoubleArrayStat");
	    registerFunctionClass("ptolemy.math.ComplexArrayMath");
	    registerFunctionClass("ptolemy.math.LongArrayMath");
	    registerFunctionClass("ptolemy.math.SignalProcessing");
            registerFunctionClass("ptolemy.math.FixPoint");
        }
    }
    
    /* Return true if the id is a variable name in scope or a registered
     * constant.
     */
    private boolean _isKnownID(String id) {
        if (Constants.get(id) != null) {
            return true;
        }
        if (_parserScope != null) {
        {
            if (_parserScope.get(id) != null)
                return true;
            }
        }
        if (_scope != null) {
            if (_scope.get(id) != null) {
                return true;
            }
        }
        return false;
    }

    /* Flag indicating whether the default set of classes searched 
     * by the parser has already been loaded.
     */
    private static boolean _alreadyInitialized = false;

    /*  Stores the classes that are searched by the parser when a 
     *  function call is parsed. It is static, and by default only 
     *  contains the java.lang.Math class.
     */
    private static LinkedList _classesSearched;

    /*  Stores the variables to which the input expression can reference
     */
    private NamedList _scope;

    /* The instance of ParserScope that represents the current scope.
     */
    private ParserScope _parserScope;

    /* Keeps track of undefined variables if not null
     */
    private LinkedList _undefined;

    
    }

PARSER_END(PtParser)


/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/* Now come to proper tokens */

SKIP :
{
 	" "
  |	"\r"
  |	"\t"
  |     "\n"
}
/*
TOKEN :
{
	< EOL: "\n" >
}
*/
TOKEN : /* Arithmetic operators */
{
	< PLUS: "+" >
  |	< MINUS: "-" >
  |	< MULTIPLY: "*" >
  |	< DIVIDE: "/" >
  |     < MODULO: "%" >
  |     < POWER: "^" >
}

TOKEN : /* Relational operators */
{
	< GT: ">" >
  |	< LT: "<" >
  |	< GTE: ">=" >
  |	< LTE: "<=" >
  |     < NOTEQUALS: "!=" >
  |     < EQUALS: "==" >
}

TOKEN : /* Boolean & bitwise operators */
{
	< COND_AND: "&&" >
  |	< COND_OR: "||" >
  |     < BOOL_NOT: "!" >
  |     < BITWISE_NOT: "~" >                          
  |	< AND: "&" >
  |     < OR: "|" >
  |     < XOR: "#" >  

}

TOKEN : /* Numeric literals */
{
  < INTEGER:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < DOUBLE:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < COMPLEX:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? (["i","j"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["i","j"])?
      | (["0"-"9"])+ <EXPONENT> (["i","j"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["i","j"]
  >
}

TOKEN : /*Boolean literals */
{
    <BOOLEAN : ( "TRUE" | "true" | "True" | "FALSE" | "false" | "False") >
}

TOKEN : /* Function names */
{
	< ID: ( <LETTER> )+ (["0"-"9", "$", "@", "#" ] | <LETTER> )* >
  | 	< #LETTER: ["a"-"z", "A"-"Z", "_"] > 		
} 

TOKEN : /* literal strings */
{
        < STRING: (
            ("\""
                ( (~["\"","\\","\n","\r"]) |
                    ("\\"
                        ( ["n","t","b","r","f","\\","'","\""]
                        | ["0"-"7"] ( ["0"-"7"] )?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                        )
                    )
                )*
                "\""
            ) |
            ("'"
                ( (~["\"","\\","\n","\r"]) |
                    ("\\"
                        ( ["n","t","b","r","f","\\","'","\""]
                        | ["0"-"7"] ( ["0"-"7"] )?
                        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                        )
                    )
                )*
                "'"
            )
        )>
}

ASTPtRootNode start()             :
{/*@bgen(jjtree) PtRootNode */
  ASTPtRootNode jjtn000 = new ASTPtRootNode(this, JJTPTROOTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PtRootNode */
    try {
/*@egen*/
    funcIf() <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void funcIf()       :
{}
{/*@bgen(jjtree) #PtFunctionalIfNode(> 1) */
   {
     ASTPtFunctionalIfNode jjtn001 = new ASTPtFunctionalIfNode(this, JJTPTFUNCTIONALIFNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           logicalOr() ( "?" logicalOr() ":" logicalOr() )?
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void logicalOr()       :
{Token x;}
{/*@bgen(jjtree) #PtLogicalNode(> 1) */
   {
     ASTPtLogicalNode jjtn001 = new ASTPtLogicalNode(this, JJTPTLOGICALNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           logicalAnd() ( 
                   x = <COND_OR> logicalAnd()
                   {  jjtn001._lexicalTokens.add(x); }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void logicalAnd()       :
{Token x;}
{/*@bgen(jjtree) #PtLogicalNode(> 1) */
   {
     ASTPtLogicalNode jjtn001 = new ASTPtLogicalNode(this, JJTPTLOGICALNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           bitwiseOr() ( 
                   x = <COND_AND> bitwiseOr()
                   {  jjtn001._lexicalTokens.add(x); }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void bitwiseOr()       :
{Token x;}
{/*@bgen(jjtree) #PtBitwiseNode(> 1) */
   {
     ASTPtBitwiseNode jjtn001 = new ASTPtBitwiseNode(this, JJTPTBITWISENODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           bitwiseXor() ( 
                   x = <OR> bitwiseXor()
                   {  jjtn001._lexicalTokens.add(x); }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void bitwiseXor()       :
{Token x;}
{/*@bgen(jjtree) #PtBitwiseNode(> 1) */
   {
     ASTPtBitwiseNode jjtn001 = new ASTPtBitwiseNode(this, JJTPTBITWISENODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           bitwiseAnd() ( 
                   x = <XOR> bitwiseAnd()
                   {  jjtn001._lexicalTokens.add(x); }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void bitwiseAnd()       :
{Token x;}
{/*@bgen(jjtree) #PtBitwiseNode(> 1) */
   {
     ASTPtBitwiseNode jjtn001 = new ASTPtBitwiseNode(this, JJTPTBITWISENODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           logicalEquals() ( 
                   x = <AND> logicalEquals()
                   {  jjtn001._lexicalTokens.add(x); }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void logicalEquals()       :
{Token x;}
{/*@bgen(jjtree) #PtRelationalNode(> 1) */
   {
     ASTPtRelationalNode jjtn001 = new ASTPtRelationalNode(this, JJTPTRELATIONALNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           relational() ( 
                   ( x = <EQUALS> | x = <NOTEQUALS> ) relational()
                   {
                       jjtn001._lexicalTokens.add(x);
                   }
           )?
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/

}

void relational()       :
{Token x;}
{/*@bgen(jjtree) #PtRelationalNode(> 1) */
   {
     ASTPtRelationalNode jjtn001 = new ASTPtRelationalNode(this, JJTPTRELATIONALNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           sum() ( 
                   ( x = <GT> | x = <GTE> | x = <LT> | x = <LTE> ) sum()
                   {
                       jjtn001._lexicalTokens.add(x);
                   }
           )?
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void sum()       :
{Token x;}
{/*@bgen(jjtree) #PtSumNode(> 1) */
   {
     ASTPtSumNode jjtn001 = new ASTPtSumNode(this, JJTPTSUMNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           term() ( 
                   ( x = <PLUS> | x = <MINUS> ) term()
                   {
                       jjtn001._lexicalTokens.add(x);
                   }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void term()       :
{Token x;}
{/*@bgen(jjtree) #PtProductNode(> 1) */
   {
     ASTPtProductNode jjtn001 = new ASTPtProductNode(this, JJTPTPRODUCTNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           unary() ( 
                   ( x = <MULTIPLY> | x = <DIVIDE> | x = <MODULO> | x = <POWER> ) unary()
                   {
                       jjtn001._lexicalTokens.add(x);
                   }
           )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}


void unary()       :
{}
{/*@bgen(jjtree) PtUnaryNode */
   {
     ASTPtUnaryNode jjtn001 = new ASTPtUnaryNode(this, JJTPTUNARYNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   (
           <MINUS> element()/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn001, true);
             jjtc001 = false;
           }
/*@egen*/
           { jjtn001._isMinus = true;}
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
     }
   }
/*@egen*/

 |/*@bgen(jjtree) PtUnaryNode */
   {
     ASTPtUnaryNode jjtn002 = new ASTPtUnaryNode(this, JJTPTUNARYNODE);
     boolean jjtc002 = true;
     jjtree.openNodeScope(jjtn002);
   }
   try {
/*@egen*/  
   (
           <BOOL_NOT> element()/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn002, true);
             jjtc002 = false;
           }
/*@egen*/
           { jjtn002._isNot = true;} 
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte002) {
     if (jjtc002) {
       jjtree.clearNodeScope(jjtn002);
       jjtc002 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte002 instanceof RuntimeException) {
       throw (RuntimeException)jjte002;
     }
     if (jjte002 instanceof ParseException) {
       throw (ParseException)jjte002;
     }
     throw (Error)jjte002;
   } finally {
     if (jjtc002) {
       jjtree.closeNodeScope(jjtn002, true);
     }
   }
/*@egen*/
 |/*@bgen(jjtree) PtUnaryNode */
   {
     ASTPtUnaryNode jjtn003 = new ASTPtUnaryNode(this, JJTPTUNARYNODE);
     boolean jjtc003 = true;
     jjtree.openNodeScope(jjtn003);
   }
   try {
/*@egen*/  
   (
           <BITWISE_NOT> element()/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn003, true);
             jjtc003 = false;
           }
/*@egen*/
           { jjtn003._isBitwiseNot = true;} 
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte003) {
     if (jjtc003) {
       jjtree.clearNodeScope(jjtn003);
       jjtc003 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte003 instanceof RuntimeException) {
       throw (RuntimeException)jjte003;
     }
     if (jjte003 instanceof ParseException) {
       throw (ParseException)jjte003;
     }
     throw (Error)jjte003;
   } finally {
     if (jjtc003) {
       jjtree.closeNodeScope(jjtn003, true);
     }
   }
/*@egen*/

 |  element()
}

void element()       :
{  
  boolean isMethodCall = false;
}
{/*@bgen(jjtree) #PtMethodCallNode( isMethodCall) */
  {
    ASTPtMethodCallNode jjtn001 = new ASTPtMethodCallNode(this, JJTPTMETHODCALLNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/ 
  ( primaryElement()
    [ "." <ID> {jjtn001._methodName = token.image; isMethodCall = true;}
      "(" [ funcIf() ( "," funcIf() )* ] ")" ]
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  isMethodCall);
    }
  }
/*@egen*/
}

void primaryElement()       :
{
int len;
String tidied, x;
}
{/*@bgen(jjtree) PtLeafNode */
   {
     ASTPtLeafNode jjtn001 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/
   ( 
      <COMPLEX>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();
                Double imag = new Double(x.substring(0, len-1 ));
                Complex value = new Complex(0, imag.doubleValue());
                jjtn001._ptToken = new ComplexToken(value);
		jjtn001._isConstant = true;
            } catch (NumberFormatException ee) {
                throw new ParseException(
                        "Unable to convert token " + token.image + 
                        " to a complex number.");
            }
        }
   )/*@bgen(jjtree)*/
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
     }
   }
/*@egen*/
  |/*@bgen(jjtree) PtLeafNode */
   {
     ASTPtLeafNode jjtn002 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
     boolean jjtc002 = true;
     jjtree.openNodeScope(jjtn002);
   }
   try {
/*@egen*/  
   (
     <DOUBLE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002, true);
          jjtc002 = false;
        }
/*@egen*/
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();
                if ( x.endsWith("d") || x.endsWith("f") ) {   
                    // all floating point numbers are double
                    Double value = new Double(x.substring(0, len-1 ));
                    jjtn002._ptToken = new DoubleToken(value.doubleValue());
                } else {
                   Double value = new Double(x);
                   jjtn002._ptToken = new DoubleToken(value.doubleValue()); 
                }
	        jjtn002._isConstant = true;
            } catch (NumberFormatException ee) {
                throw new ParseException(
                        "Unable to convert token " + token.image +
                        " to an float or double");
            }
        }
   )/*@bgen(jjtree)*/
   } finally {
     if (jjtc002) {
       jjtree.closeNodeScope(jjtn002, true);
     }
   }
/*@egen*/

  |/*@bgen(jjtree) PtLeafNode */
   {
     ASTPtLeafNode jjtn003 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
     boolean jjtc003 = true;
     jjtree.openNodeScope(jjtn003);
   }
   try {
/*@egen*/  
   (
     <INTEGER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003, true);
          jjtc003 = false;
        }
/*@egen*/
	{   try 
            {
                x = token.image.toLowerCase();
                len = x.length();

                // special case of hex
                if ( x.startsWith("0x") ) {
                    if ( x.endsWith("l") ) {                   
                        // long case
                        String hex = x.substring(2, len-1);
                        long value = Long.parseLong(hex, 16);
                        jjtn003._ptToken = new LongToken(value);
                    } else {
                        String hex = x.substring(2, len);
                        int value = Integer.parseInt(hex, 16);
                        jjtn003._ptToken = new IntToken(value);
                    }
                } else if ( x.endsWith("l") ) {
                    Long value = new Long(x.substring(0, len-1 ));
                    jjtn003._ptToken = new LongToken(value.longValue());
                } else {
		    try { 
                        Integer value = new Integer(x);
                        jjtn003._ptToken = new IntToken(value.intValue()); 
                    } catch (NumberFormatException nfe) {
                        Long value = new Long(x);
                        jjtn003._ptToken = new LongToken(value.longValue());
                    }
                }
		jjtn003._isConstant = true;
            } catch (NumberFormatException ee) {
                throw new ParseException(
                        "Unable to convert token " + token.image + 
                        " to an integer or long");
	    }
	}
   )/*@bgen(jjtree)*/
   } finally {
     if (jjtc003) {
       jjtree.closeNodeScope(jjtn003, true);
     }
   }
/*@egen*/

  |/*@bgen(jjtree) PtLeafNode */
   {
     ASTPtLeafNode jjtn004 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
     boolean jjtc004 = true;
     jjtree.openNodeScope(jjtn004);
   }
   try {
/*@egen*/ 
   (
      <STRING>/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn004, true);
        jjtc004 = false;
      }
/*@egen*/
      {
         // Now cut the " from each end of the string.
        len = token.image.length();
        tidied = token.image.substring(1, (len -1));

        // Resolve escape sequences in the string.
        StringTokenizer st = new StringTokenizer(tidied, "\\", true);
        boolean escape = false;
        x = new String();
        while (st.hasMoreTokens()) {
            String tok = st.nextToken();
            if (escape) {
                // The previous character was a backslash that started
                // an escape sequence.
                escape = false;
                int trailingCharIndex = 1;
                switch (tok.charAt(0)) {
                    case 'n': x += "\n"; break;
                    case 't': x += "\t"; break;
                    case 'b': x += "\b"; break;
                    case 'r': x += "\r"; break;
                    case 'f': x += "\f"; break;
                    case '\\': x += "\\"; break;
                    case '\'': x += "\'"; break;
                    case '"': x += "\""; break;
                    default:
                        // The escape sequence is a character
                        // specified in octal.
                        int i;
                        for (i = 0; i < tok.length(); i++) {
                            // The octal sequence stops at the first
                            // non-octal character.
                            char c = tok.charAt(i);
                            if (! (c == '0' ||
                                   c == '1' ||
                                   c == '2' ||
                                   c == '3' ||
                                   c == '4' ||
                                   c == '5' ||
                                   c == '6' ||
                                   c == '7'))
                                break;
                        }
                        trailingCharIndex = i;
                        int octVal = Integer.parseInt(
                                tok.substring(0, trailingCharIndex), 8);
                        x += (char)octVal;
                        break;
                }
                if (trailingCharIndex < tok.length()) {
                    // Keep any remaining characters.
                    x += tok.substring(trailingCharIndex);
                }
            }
            else if (tok.equals("\\")) {
                // Start an escape sequence.
                escape = true;
            }
            else {
                // Keep regular text.
                x += tok;
            }
        }
        jjtn004._ptToken = new StringToken(x);
	jjtn004._isConstant = true;
      }
   )/*@bgen(jjtree)*/
   } finally {
     if (jjtc004) {
       jjtree.closeNodeScope(jjtn004, true);
     }
   }
/*@egen*/

  |/*@bgen(jjtree) PtLeafNode */
   {
     ASTPtLeafNode jjtn005 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
     boolean jjtc005 = true;
     jjtree.openNodeScope(jjtn005);
   }
   try {
/*@egen*/  
   (
     <BOOLEAN>/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn005, true);
        jjtc005 = false;
      }
/*@egen*/
      { 
          if (token.image.equalsIgnoreCase("TRUE")) {
              jjtn005._ptToken = new BooleanToken(true);
          } else if (token.image.equalsIgnoreCase("FALSE")) {
              jjtn005._ptToken = new BooleanToken(false);   
          }
	  jjtn005._isConstant = true;
      }
   )/*@bgen(jjtree)*/
   } finally {
     if (jjtc005) {
       jjtree.closeNodeScope(jjtn005, true);
     }
   }
/*@egen*/   


  | "(" funcIf() ")"
 
  |   LOOKAHEAD( <ID> "(" )
      function()
    
  |/*@bgen(jjtree) PtLeafNode */
   {
     ASTPtLeafNode jjtn006 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
     boolean jjtc006 = true;
     jjtree.openNodeScope(jjtn006);
   }
   try {
/*@egen*/ 
   (
     <ID>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn006, true);
       jjtc006 = false;
     }
/*@egen*/
     { 
        Variable referredVar = null;
        if (_parserScope != null) {
            referredVar = (Variable)_parserScope.get(token.image);
        }
        if (referredVar == null && _scope != null) {
            referredVar = (Variable)_scope.get(token.image);
        }
        if (referredVar != null) {
           // The Variable is stored in the node so that the tree 
	   // does not have to be reparsed whenever the Token in 
	   // the Variable changes.
           jjtn006._var   = referredVar; 
           // Register the calling Variable as a listener
	   // of the Variable this ID references.
           if (_owner != null) {
        	referredVar.addValueListener(_owner);
            }
        } else if (Constants.get(token.image) != null) {
            // A named constant that is recognized by the parser.
            jjtn006._ptToken = Constants.get(token.image);
	    jjtn006._isConstant = true;
        } else {
            if (_undefined == null) {
                // System.out.println("Undefined <" + token.image + ">");
		throw new ParseException("The ID " + token.image + 
			" is undefined.");
            } else {
                // System.out.println("Defining <" + token.image + ">");
                _undefined.add(token.image);
                jjtn006._var = null;
            }

        }
    }
   )/*@bgen(jjtree)*/
   } finally {
     if (jjtc006) {
       jjtree.closeNodeScope(jjtn006, true);
     }
   }
/*@egen*/

  |   LOOKAHEAD( "[" )
      matrixConstruct()

  |   LOOKAHEAD( "{" <ID> "=" )
      recordConstruct()
  
  |   LOOKAHEAD( "{" )
      arrayConstruct()

}

void function()                 :
{/*@bgen(jjtree) PtFunctionNode */
  ASTPtFunctionNode jjtn000 = new ASTPtFunctionNode(this, JJTPTFUNCTIONNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token x = null;
  boolean isArrayRef = false;
}
{/*@bgen(jjtree) PtFunctionNode */
    try {
/*@egen*//*@bgen(jjtree) #PtLeafNode( _isKnownID ( x . image )) */
    {
      ASTPtLeafNode jjtn001 = new ASTPtLeafNode(this, JJTPTLEAFNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    
    ( x = <ID>/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  _isKnownID ( x . image ));
        jjtc001 = false;
      }
/*@egen*/ 
      {
        Variable referredVar = null;
        if (_parserScope != null) {
            referredVar = (Variable)_parserScope.get(token.image);
        }
        if (referredVar == null && _scope != null) {
            referredVar = (Variable)_scope.get(token.image);
        }
        if (referredVar != null) {
          // The Parameter is stored in the node so that the tree 
	  // does not have to be reparsed whenever the Token in 
	  // the Parameter changes.
          jjtn001._var   = referredVar; 
          // Register the calling parameter as a listener 
          // of this Parameter this ID references.
          if (_owner != null) {
       	    referredVar.addValueListener(_owner);
    	  }
	  isArrayRef = true;
        } else if (Constants.get(x.image) != null) {
     	  // A named constant that is recognized by the parser.
      	  jjtn001._ptToken = Constants.get(x.image);
	  jjtn001._isConstant = true;
	  isArrayRef = true;
        } else {
          if (_undefined != null)
              _undefined.add(token.image);
        }
      }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  _isKnownID ( x . image ));
      }
    }
/*@egen*/
    { 
      jjtn000._funcName = x.image;
      jjtn000._isArrayRef = isArrayRef;
    }
    "(" [ funcIf() ( "," funcIf() )* ] ")"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
      int nch = jjtn000.jjtGetNumChildren();
      if (isArrayRef && !(nch == 2 || nch == 3)) {
        throw new ParseException("PtParser: Parsed an array reference to "
                + x.image + " having " + (nch - 1) + " indices, "
                + "only reference to 1 and 2 dimensional arrays "
                + "are supported.");
      }
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void matrixConstruct()                        :
{/*@bgen(jjtree) PtMatrixConstructNode */
  ASTPtMatrixConstructNode jjtn000 = new ASTPtMatrixConstructNode(this, JJTPTMATRIXCONSTRUCTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ 
  int i;
  int nRows = 0; }
{/*@bgen(jjtree) PtMatrixConstructNode */
  try {
/*@egen*/
  "[" { ++jjtn000._nColumns; ++nRows; } funcIf()  /* first term */
  (
   (  
    ( "," { ++jjtn000._nColumns; } funcIf() )*  /* first row */
    ( ";" { ++nRows; i = 0; } funcIf() { ++i; } 
    ( "," funcIf() { ++i; } )*  /* one more row */
      { /* Assert that the following rows have the same number of terms as the
         first row. */
        if ( i != jjtn000._nColumns ) {
          throw new ParseException("PtParser: error parsing matrix "
                  + "construction, the "
                  + nRows + "th row does not have the same number of "
                  + "terms as the first row.");
        }
      }
    )* "]"/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000._form = 1; jjtn000._nRows = nRows; }
   )
   | 
   (
    ":" funcIf() ":" funcIf() 
    ( ";" { ++nRows; } funcIf() ":" funcIf() ":" funcIf() )* 
    "]"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ { jjtn000._form = 2; jjtn000._nRows = nRows; }
   )
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void recordConstruct()                        :
{/*@bgen(jjtree) PtRecordConstructNode */
  ASTPtRecordConstructNode jjtn000 = new ASTPtRecordConstructNode(this, JJTPTRECORDCONSTRUCTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token x = null;
}
{/*@bgen(jjtree) PtRecordConstructNode */
    try {
/*@egen*/
    "{"
    ( x = <ID>
      {
        jjtn000._fieldNames.add(x.image);
      }
    )
    "="
    funcIf()
    (
      ","
      ( x = <ID>
        {
          jjtn000._fieldNames.add(x.image);
        }
      )
      "="
      funcIf()
    )*
    "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arrayConstruct()                       :
{/*@bgen(jjtree) PtArrayConstructNode */
  ASTPtArrayConstructNode jjtn000 = new ASTPtArrayConstructNode(this, JJTPTARRAYCONSTRUCTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) PtArrayConstructNode */
    try {
/*@egen*/
    "{"
    funcIf()
    (
      ","
      funcIf()
    )*
    "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
