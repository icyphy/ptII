<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="Quadralay WebWorks Publisher Standard Edition 6.0.6">
<meta name="TEMPLATEBASE" content="Portable HTML Standard Edition">
<meta name="LASTUPDATED" content="07/16/03 21:32:56">
<title>3 Expressions  </title>
</head>


<!--
This file was generated from ptII/doc/design/expressions.fm
using WebWorks standard edition and then edited by hand.
Things to watch out for:
&#14;
* Get rid of the font html
  1. Replace <font face="Courier New"></font>
      with nothing

     sed 's@<font face="Courier New">\(.*\)</font>@\1@g' <4.htm >5.htm
     sed 's@<font  face="Verdana, Arial, Helvetica, sans-serif">\(.*\)</font>@\1@g' <5.htm >6.htm
     sed 's@<font  face="Verdana, Arial, Helvetica, sans-serif">@@g' <6.htm >7.htm
     sed 's@<font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">\(.*\)</font>@\1@g' <7.htm >8.htm
     sed 's@<font face="Verdana, Arial, Helvetica, sans-serif" color="#003366">\(.*\)</font>@\1@g' <9.htm >10.htm
     sed 's@\(.*\)</font>@\1@g' <10.htm >11.htm

* Be sure to change the symbol font face p code to &#960;
  so that you get a pi symbol
 -->

<body link="#3366CC" vlink="#9999CC" text="#000000" alink="#0000CC" bgcolor="#FFFFFF">

<center><h1>3  Expressions</h1></center>

<a name="162678"> </a>Authors:		Edward A. Lee<br>


<a name="169035"> </a>		Xiaojun Liu<br>


<a name="190518"> </a>		Steve Neuendorffer<br>


<a name="175508"> </a>		Neil Smyth<br>


<a name="175425"> </a>		Yuhong Xiong<br>


<h3>
  <a name="168803"> </a>3.1   Introduction
</h3>


<a name="175470"> </a>In Ptolemy II, models specify computations by composing actors. Many computations, however, are awkward to specify this way. A common situation is where we wish to evaluate a simple algebraic expression, such as "sin(2&#960;(<i>x</i>-1))." It is possible to express this computation by composing actors in a block diagram, but it is far more convenient to give it textually.<br>


<p>
  <a name="175479"> </a>The Ptolemy II expression language provides infrastructure for specifying algebraic expressions textually and for evaluating them. The expression language is used to specify the values of parameters, guards and actions in state machines, and for the calculation performed by the <i>Expression</i> actor. In fact, the expression language is part of the generic infrastructure in Ptolemy II, and it can be used by programmers extending the Ptolemy II system. In this chapter, we describe how to use expressions from the perspective of a user rather than a programmer.
</p>


<h4>
  <a name="183565"> </a>3.1.1   Expression Evaluator
</h4>


<a name="183566"> </a>Vergil provides an interactive <i>expression evaluator</i>, which is accessed through the File:New menu. This operates like an interactive command shell, and is shown in figure <img src="img/expressions41.gif" height="510" width="937" align="center" border="0" hspace="0" vspace="0"><br>
<a href="#183566">3.1</a>. It supports a command history. To access the previously entered expression, type the up arrow or Control-P. To go back, type the down arrow or Control-N. The expression evaluator is useful for experimenting with expressions.<br></font>


<h3>
  <a name="175566"> </a>3.2   Simple Arithmetic Expressions
</h3>


<h4>
  <a name="175529"> </a>3.2.1   Constants and Literals
</h4>


<p>
  <a name="175531"> </a>The simplest expression is a constant, which can be given either by the symbolic name of the constant, or by a literal. By default, the symbolic names of constants supported are PI, pi, E, e, true, false, i, j, NaN, Infinity, PositiveInfinity, NegativeInfinity, MaxUnsignedByte, MinUnsignedByte, MaxInt, MinInt, MaxLong, MinLong, MaxDouble, MinDouble. For example,
</p>

<pre>
<a name="175540"> </a>
PI/2.0<a name="175541"> </a>
<a name="175542"> </a>
</pre>

<a name="175543"> </a>is a valid expression that refers to the symbolic name "PI" and the literal "2.0." The constants i and j are the imaginary number with value equal to the square root of <font  face="Symbol">-</font>1. The constant NaN is "not a number," which for example is the result of dividing 0.0/0.0. The constant Infinity is the result of dividing 1.0/0.0. The constants that start with "Max" and "Min" are the maximum and minimum values for their corresponding types.<br>


<p>
  <a name="175682"> </a>Numerical values without decimal points, such as "10" or "<font  face="Symbol">-</font>3" are integers (type <i>int</i>). Numerical values with decimal points, such as "10.0" or "3.14159" are of type <i>double</i>. Numerical values without decimal points followed by the character "l" (el) or "L" are of type <i>long</i>. Unsigned integers followed by "ub" or "UB" are of type <i>unsignedByte</i>, as in "5ub". An <i>unsignedByte</i> has a value between 0 and 255; note that it not quite the same as the Java byte, which has a value between -128 and 127.
</p>


<p>
  <a name="183874"> </a>Numbers of type <i>int</i>, <i>long</i>, or <i>unsignedByte</i> can be specified in decimal, octal, or hexadecimal. Numbers beginning with a leading "0" are octal numbers. Numbers beginning with a leading "0x" are hexadecimal numbers. For example, "012" and "0xA" are both equal to the integer 10. 
</p>


<p>
  <a name="176526"> </a>A <i>complex</i> is defined by appending an "i" or a "j" to a double for the imaginary part. This gives a purely imaginary complex number which can then leverage the polymorphic operations in the Token classes to create a general complex number. Thus "2 + 3i</font>" will result in the expected complex number. You can optionally write this "2 + 3*i</font>".
</p>


<p>
  <a name="183893"> </a>Literal string constants are also supported. Anything between double quotes, "...", is interpreted as a string constant. The following built-in string-valued constants are defined:

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="185430"> </a><font face="Times New Roman">TABLE 1:  String-valued constants defined in the expression language.</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="176529"> </a>Variable name</th>
    <th><a name="176531"> </a>Meaning</th>
    <th><a name="176533"> </a>Property name</th>
    <th><a name="176570"> </a>Example under Windows</th>
  </tr>
  <tr>
    <td><a name="176536"> </a>PTII</td>
    <td><a name="176538"> </a>The directory in which Ptolemy II is installed</td>
    <td><a name="176540"> </a>ptolemy.ptII.dir</td>
    <td><a name="176572"> </a>c:\tmp</td>
  </tr>
  <tr>
    <td><a name="176543"> </a>HOME</td>
    <td><a name="176545"> </a>The user home directory</td>
    <td><a name="176547"> </a>user.home</td>
    <td><a name="176574"> </a>c:\Documents and Settings\you</td>
  </tr>
  <tr>
    <td><a name="176550"> </a>CWD</td>
    <td><a name="176552"> </a>The current working directory</td>
    <td><a name="176554"> </a>user.dir</td>
    <td><a name="176576"> </a>c:\ptII</td>
  </tr>
</table>



</font>
</p>


<a name="176584"> </a>The value of these variables is the value of the Java virtual machine property, such as <i>user.home</i>. The properties <i>user.dir</i> and <i>user.home</i> are standard in Java. Their values are platform dependent; see the documentation for the java.lang.System.getProperties() method for details. Note that <i>user.dir</i> and <i>user.home</i> are usually not readable in unsigned applets, in which case, attempts to use these variables in an expression will result in an exception. Vergil will display all the Java properties if you invoke JVM Properties in the View menu of a Graph Editor.<br>


<p>
  <a name="176629"> </a>The <i>ptolemy.ptII.dir</i> property is set automatically when Vergil or any other Ptolemy II executable is started up. You can also set it when you start a Ptolemy II process using the java command by a syntax like the following:
</p>

<pre>
<a name="176693"> </a>
java -Dptolemy.ptII.dir=${PTII} <i>classname</i><a name="176699"> </a>
<a name="176702"> </a>
</pre>

<a name="183552"> </a>where <i>classname</i> is the full class name of a Java application.<br>


<p>
  <a name="183554"> </a>The constants() utility function returns a record with all the globally defined constants. If you open the expression evaluator and invoke this function, you will see that its value is something like:
</p>

<pre>
<a name="183584"> </a>
{CWD="C:\ptII\ptolemy\data\expr", E=2.718281828459, HOME="C:\Documents and Settings\eal", Infinity=Infinity, MaxDouble=1.7976931348623E308, MaxInt=2147483647, MaxLong=9223372036854775807L, MaxUnsignedByte=255ub, MinDouble=4.9E-324, MinInt=-2147483648, MinLong=-9223372036854775808L, MinUnsignedByte=0ub, NaN=NaN, NegativeInfinity=-Infinity, PI=3.1415926535898, PTII="c:\ptII", PositiveInfinity=Infinity, boolean=false, complex=0.0 + 0.0i, double=0.0, e=2.718281828459, false=false, fixedpoint=fix(0.0,2,1), general=present, i=0.0 + 1.0i, int=0, j=0.0 + 1.0i, long=0L, matrix=[], object=object(null),pi=3.1415926535898, scalar=present, string="", true=true, unknown=present, unsignedByte=0ub}<a name="183585"> </a>
</pre>

<h4>
  <a name="175515"> </a>3.2.2   Variables
</h4>


<p>
  <a name="175517"> </a>Expressions can contain identifiers that are references to variables within the <i>scope</i> of the expression. For example,
</p>

<pre>
<a name="175696"> </a>
PI*x/2.0<a name="175697"> </a>
<a name="175704"> </a>
</pre>

<a name="191833"> </a>is valid if "x" is a variable in scope. In the expression evaluator, the variables that are in scope include the built-in constants plus any assignments that have been previously made. For example,<br>

<pre>
<a name="191835"> </a>
&gt;&gt; x = pi/2<a name="191853"> </a>
1.5707963267949<a name="191854"> </a>
&gt;&gt; sin(x)<a name="191855"> </a>
1.0<a name="191856"> </a>
&gt;&gt;<a name="191836"> </a>
<a name="191837"> </a>
</pre>

<a name="191844"> </a>In the context of Ptolemy II models, the variables in scope include all parameters defined at the same level of the hierarchy or higher. So for example, if an actor has a parameter named "x" with value 1.0, then another parameter of the same actor can have an expression with value "PI*x/2.0</font>", which will evaluate to &#960;/2.<br>


<p>
  <a name="175710"> </a>Consider a parameter <i>P </i>in actor <i>X</i> which is in turn contained by composite actor <i>Y</i>. The scope of an expression for <i>P </i>includes all the parameters contained by <i>X</i> and <i>Y</i>, plus those of the container of <i>Y</i>, its container, etc. That is, the scope includes any parameters defined above in the hierarchy.
</p>


<p>
  <a name="175724"> </a>You can add parameters to actors (composite or not) by right clicking on the actor, selecting "Configure" and then clicking on "Add", or by dragging in a parameter from the <i>utilities</i> library. Thus, you can add variables to any scope, a capability that serves the same role as the "let" construct in many functional programming languages.
</p>


<h4>
  <a name="175554"> </a>3.2.3   Operators
</h4>


<p>
  <a name="175556"> </a>The arithmetic operators are +, <font  face="Symbol">-,</font> *, /, ^, and %. Most of these operators operate on most data types, including arrays, records, and matrices. The ^ operator computes "to the power of" or exponentiation where the exponent can only be an <i>int</i> or an <i>unsignedByte</i>. 
</p>


<p>
  <a name="183454"> </a>The <i>unsignedByte</i>, <i>int</i> and <i>long</i> types can only represent integer numbers. Operations on these types are integer operations, which can sometimes lead to unexpected results. For instance, 1/2 yields 0 if 1 and 2 are integers, whereas 1.0/2.0 yields 0.5. The exponentiation operator '^' when used with negative exponents can similarly yield unexpected results. For example, 2^<font  face="Symbol">-</font>1 is 0 because the result is computed as 1/(2^1).
</p>


<p>
  <a name="186979"> </a>The % operation is a <i>modulo</i> or <i>remainder</i> operation. The result is the remainder after division. The sign of the result is the same as that of the dividend (the left argument). For example,
</p>

<pre>
<a name="187558"> </a>
&gt;&gt; 3.0 % 2.0<a name="187564"> </a>
1.0<a name="187565"> </a>
&gt;&gt; -3.0 % 2.0<a name="187568"> </a>
-1.0<a name="187569"> </a>
&gt;&gt; -3.0 % -2.0<a name="187570"> </a>
-1.0<a name="187571"> </a>
&gt;&gt; 3.0 % -2.0<a name="187572"> </a>
1.0<a name="187562"> </a>
<a name="187587"> </a>
</pre>

<a name="187588"> </a>The magnitude of the result is always less than the magnitude of the divisor (the right argument). Note that when this operator is used on doubles, the result is not the same as that produced by the remainder() function (see <a href="#194754">Table 5 on page 96</a>). For instance,<br>

<pre>
<a name="187601"> </a>
&gt;&gt; remainder(-3.0, 2.0)<a name="187607"> </a>
1.0<a name="187605"> </a>
<a name="187611"> </a>
</pre>

<a name="186986"> </a>The remainder() function calculates the IEEE 754 standard remainder operation. It uses a rounding division rather than a truncating division, and hence the sign can be positive or negative, depending on complicated rules (see <a href="#186842">page 90</a>). For example, counter intuitively,<br>

<pre>
<a name="187628"> </a>
&gt;&gt; remainder(3.0, 2.0)<a name="187634"> </a>
-1.0<a name="187632"> </a>
<a name="187642"> </a>
</pre>

<p>
  <a name="183724"> </a>When an operator involves two distinct types, the expression language has to make a decision about which type to use to implement the operation. If one of the two types can be converted without loss into the other, then it will be. For instance, <i>int</i> can be converted losslessly to <i>double</i>, so 1.0/2 will result in 2 being first converted to 2.0, so the result will be 0.5. Among the scalar types, <i>unsignedByte</i> can be converted to anything else, <i>int</i> can be converted to <i>double</i>, and <i>double</i> can be converted to <i>complex</i>. Note that <i>long</i> cannot be converted to <i>double</i> without loss, nor vice versa, so an expression like 2.0/2L</font> yields the following error message:
</p>

<pre>
<a name="183725"> </a>
Error evaluating expression "2.0/2L"<a name="183743"> </a>
 in .Expression.evaluator<a name="183726"> </a>
Because:<a name="183727"> </a>
divide method not supported between ptolemy.data.DoubleToken '2.0' and ptolemy.data.LongToken '2L' because the types are incomparable.<a name="183700"> </a>
<a name="183744"> </a>
</pre>

<p>
  <a name="183459"> </a>All scalar types have limited precision and magnitude. As a result of this, arithmetic operations are subject to underflow and overflow. 
</p>


<a name="183477"> </a>	 For <i>double</i> numbers, overflow results in the corresponding positive or negative infinity. Underflow (i.e. the precision does not suffice to represent the result) will yield zero.<br>


<a name="183478"> </a>	 For integer types and <i>fixedpoint</i>, overflow results in wraparound. For instance, while the value of MaxInt</font> is 2147483647, the expression MaxInt + 1</font> yields <font  face="Symbol">-</font>2147483648. Similarly, while MaxUnsignedByte</font> has value 255ub, MaxUnsignedByte + 1ub</font> has value 0ub. Note, however, that MaxUnsignedByte + 1</font> yields 256, which is an <i>int</i>, not an <i>unsignedByte</i>. This is because MaxUnsignedByte</font> can be losslessly converted to an <i>int</i>, so the addition is <i>int</i> addition, not <i>unsignedByte</i> addition.<br>


<a name="183480"> </a>The bitwise operators are &amp;</font>, |</font>, #</font>, and ~</font>. They operate on <i>boolean</i>, <i>unsignedByte</i>, <i>int</i> and <i>long</i> (but not <i>fixedpoint</i>, <i>double</i> or <i>complex</i>). The operator &amp;</font> is bitwise AND, ~</font> is bitwise NOT, and |</font> is bitwise OR, and #</font> is bitwise XOR (exclusive or, after MATLAB). <br>


<p>
  <a name="175559"> </a>The relational operators are &lt;</font>, &lt;=</font>, &gt;</font>, &gt;=</font>, ==</font> and !=</font>. They return type <i>boolean</i>. Note that these relational operators check the values when possible, irrespective of type. So, for example,
</p>

<pre>
<a name="188798"> </a>
1 == 1.0<a name="188802"> </a>
<a name="188810"> </a>
</pre>

<a name="188811"> </a>returns <i>true</i>. If you wish to check for equality of both type and value, use the equals() method, as in<br>

<pre>
<a name="188815"> </a>
&gt;&gt; 1.equals(1.0)<a name="188819"> </a>
false<a name="188820"> </a>
<a name="188821"> </a>
</pre>

<p>
  <a name="188797"> </a>Boolean-valued expressions can be used to give conditional values. The syntax for this is 
</p>

<pre>
<a name="175560"> </a>
boolean ? value1 : value2<a name="195993"> </a>
<a name="195994"> </a>
</pre>

<a name="175562"> </a>If the boolean is true, the value of the expression is value1</font>; otherwise, it is value2</font>.<br>


<p>
  <a name="175732"> </a>The logical boolean operators are &amp;&amp;</font>, ||</font>, !</font>, &amp;</font> and |</font>. They operate on type <i>boolean</i> and return type <i>boolean</i>. The difference between logical &amp;&amp;</font> and logical &amp;</font> is that &amp;</font> evaluates all the operands regardless of whether their value is now irrelevant. Similarly for logical ||</font> and |</font>. This approach is borrowed from Java. Thus, for example, the expression "false &amp;&amp; x</font>" will evaluate to <i>false</i> irrespective of whether x</font> is defined. On the other hand, "false &amp; x</font>" will throw an exception.
</p>


<p>
  <a name="175563"> </a>The &lt;&lt;</font> and &gt;&gt;</font> operators performs arithmetic left and right shifts respectively. The &gt;&gt;&gt;</font> operator performs a logical right shift, which does not preserve the sign. They operate on <i>unsignedByte</i>, <i>int</i>, and <i>long</i>.
</p>


<h4>
  <a name="175609"> </a>3.2.4   Comments
</h4>


<a name="175611"> </a>In expressions, anything inside<b> </b></font>/*...*/</font> is ignored, so you can insert comments.<br>


<h3>
  <a name="175570"> </a>3.3   Uses of Expressions
</h3>


<h4>
  <a name="175574"> </a>3.3.1   Parameters
</h4>


<a name="175578"> </a>The values of most parameters of actors can be given as expressions<a href="#175811"><sup>1</sup></a>. The variables in the expression refer to other parameters that are in scope, which are those contained by the same container or some container above in the hierarchy. They can also reference variables in a <i>scope-extending attribute</i>, which includes variables defining units, as explained below in section <a href="#175821">3.9</a>. Adding parameters to actors is straightforward, as explained in the previous chapter.<br>


<h4>
  <a name="176319"> </a>3.3.2   Port Parameters
</h4>


<a name="176320"> </a>It is possible to define a parameter that is also a port. Such a <i>PortParameter</i> provides a default value, which is specified like the value of any other parameter. When the corresponding port receives data, however, the default value is overridden with the value provided at the port. Thus, this object functions like a parameter and a port. The current value of the PortParameter is accessed like that of any other parameter. Its current value will be either the default or the value most recently received on the port.<br>


<p>
  <a name="176834"> </a>A PortParameter might be contained by an atomic actor or a composite actor. To put one in a composite actor, drag it into a model from the <i>utilities</i> library, as shown in figure <img src="img/expressions17.gif" height="546" width="937" align="left" border="0" hspace="0" vspace="0">
<a href="#176834">3.2</a>. The resulting icon is actually a combination of two icons, one representing the port, and the other representing the parameter. These can be moved separately, but doing so might create confusion, so we recommend selecting both by clicking and dragging over the pair and moving both together.</font>
</p>


<p>
  <a name="176895"> </a>To be useful, a PortParameter has to be given a name (the default name, "portParameter," is not very compelling). To change the name, right click on the icon and select "Customize Name," as shown in figure <a href="#176834">3.2</a>. In the figure, the name is set to "noiseLevel." Then set the default value by either double clicking or selecting "Configure." In the figure, the default value is set to 10.0.
</p>


<p>
  <a name="176899"> </a>An example of a library actor that uses a PortParameter is the Sinewave actor, which is found in the <i>sources</i> library in Vergil. It is shown in figure <img src="img/expressions14.gif" height="529" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="#176899">3.3</a>. If you double click on this actor, you can set the default values for <i>frequency</i> and <i>phase</i>. But both of these values can also be set by the corresponding ports, which are shown with grey fill.
</p>


<h4>
  <a name="171261"> </a>3.3.3   Expression Actor
</h4>


<a name="171267"> </a>The <i>Expression</i> actor is a particularly useful actor found in the <i>math</i> library. By default, it has one output and no inputs, as shown in Figure <img src="img/expressions55.gif" height="441" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="#171267">3.4</a>(a). The first step in using it is to add ports, as shown in (b) and (c), resulting in a new icon as shown in (d). Note: In (c) when you click on Add, you will be prompted for a Name (pick one) and a Class. Leave the Class entry blank and click OK. You then specify an expression using the port names, as shown in (e), resulting in the icon shown in (f).<br></font>


<h4>
  <a name="183128"> </a>3.3.4   State Machines
</h4>


<a name="176000"> </a>Expressions give the guards for state transitions, as well as the values used in actions that produce outputs and actions that set values of parameters in the refinements of destination states. This mechanism was explained in the previous chapter.<br>


<h3>
  <a name="175590"> </a>3.4   Composite Data Types
</h3>


<h4>
  <a name="169763"> </a>3.4.1   Arrays
</h4>


<p>
  <a name="167020"> </a>Arrays are specified with curly brackets, e.g., "{1, 2, 3}</font>" is an array of <i>int</i>, while "{"x", "y", "z"}</font>" is an array of <i>string</i>. The types are denoted "{int}</font>" and "{string}</font>" respectively. An array is an ordered list of tokens of any type, with the only constraint being that the elements all have the same type. If an array is given with mixed types, the expression evaluator will attempt to losslessly convert the elements to a common type. Thus, for example, 
</p>

<pre>
<a name="183808"> </a>
{1, 2.3}<a name="183812"> </a>
<a name="183813"> </a>
</pre>

<a name="183814"> </a>has value<br>

<pre>
<a name="183827"> </a>
{1.0, 2.3}<a name="183828"> </a>
<a name="183829"> </a>
</pre>

<a name="183821"> </a>Its type is {double}</font>. The elements of the array can be given by expressions, as in the example "{2*pi, 3*pi}</font>." Arrays can be nested; for example, "{{1, 2}, {3, 4, 5}}</font>" is an array of arrays of integers. The elements of an array can be accessed as follows:<br>

<pre>
<a name="184963"> </a>
&gt;&gt; {1.0, 2.3}(1)<a name="184967"> </a>
2.3<a name="196065"> </a>
<a name="184976"> </a>
</pre>

<a name="184977"> </a>which yields 2.3. Note that indexing begins at 0. Of course, if <i>name</i> is the name of a variable in scope whose value is an array, then its elements may be accessed similarly, as shown in this example:<br>

<pre>
<a name="196069"> </a>
&gt;&gt; x = {1.0, 2.3}<a name="196075"> </a>
{1.0, 2.3}<a name="196076"> </a>
&gt;&gt; x(0)<a name="196077"> </a>
1.0<a name="196078"> </a>
<a name="196086"> </a>
</pre>

<p>
  <a name="186462"> </a>Arithmetic operations on arrays are carried out element-by-element, as shown by the following examples:
</p>

<pre>
<a name="186469"> </a>
&gt;&gt; {1, 2}*{2, 2}<a name="186475"> </a>
{2, 4}<a name="186528"> </a>
&gt;&gt; {1, 2}+{2, 2}<a name="186505"> </a>
{3, 4}<a name="186535"> </a>
&gt;&gt; {1, 2}-{2, 2}<a name="186510"> </a>
{-1, 0}<a name="186542"> </a>
&gt;&gt; {1, 2}^2<a name="186513"> </a>
{1, 4}<a name="186549"> </a>
&gt;&gt; {1, 2}%{2, 2}<a name="186586"> </a>
{1, 0}<a name="186587"> </a>
<a name="186473"> </a>
</pre>

<a name="186419"> </a>An array can be checked for equality with another array as follows:<br>

<pre>
<a name="186420"> </a>
&gt;&gt; {1, 2}=={2, 2}<a name="186576"> </a>
false<a name="186577"> </a>
&gt;&gt; {1, 2}!={2, 2}<a name="186578"> </a>
true<a name="186579"> </a>
<a name="186425"> </a>
</pre>

<a name="186430"> </a>For other comparisons of arrays, use the compare() function (see <a href="#194754">Table 5 on page 96</a>). As with scalars, testing for equality using the ==</font> or !=</font> operators tests the values, independent of type. For example,<br>

<pre>
<a name="188887"> </a>
&gt;&gt; {1, 2}=={1.0, 2.0}<a name="188893"> </a>
true<a name="188891"> </a>
</pre>

<h4>
  <a name="169767"> </a>3.4.2   Matrices
</h4>


<p>
  <a name="169058"> </a>In Ptolemy II, <i>arrays</i> are ordered sets of tokens. Ptolemy II also supports <i>matrices</i>, which are more specialized than arrays. They contain only certain primitive types, currently <i>boolean</i>, <i>complex</i>, <i>double</i>, <i>fixedpoint</i>, <i>int</i>, and <i>long. </i>Currently <i>unsignedByte</i> matrices are not supported. Matrices cannot contain arbitrary tokens, so they cannot, for example, contain matrices. They are intended for data intensive computations.
</p>


<p>
  <a name="175215"> </a>Matrices are specified with square brackets, using commas to separate row elements and semicolons to separate rows. E.g., "[1, 2, 3; 4, 5, 5+1]" gives a two by three integer matrix (2 rows and 3 columns). Note that an array or matrix element can be given by an expression. A row vector can be given as "[1, 2, 3]" and a column vector as "[1; 2; 3]". Some MATLAB-style array constructors are supported. For example, "[1:2:9]" gives an array of odd numbers from 1 to 9, and is equivalent to "[1, 3, 5, 7, 9]." Similarly, "[1:2:9; 2:2:10]" is equivalent to "[1, 3, 5, 7, 9; 2, 4, 6, 8, 10]." In the syntax "[<i>p</i>:<i>q</i>:<i>r</i>]", <i>p</i> is the first element, <i>q</i> is the step between elements, and <i>r</i> is an upper bound on the last element. That is, the matrix will not contain an element larger than <i>r</i>. If a matrix with mixed types is specified, then the elements will be converted to a common type, if possible. Thus, for example, "[1.0, 1]" is equivalent to "[1.0, 1.0]," but "[1.0, 1L]" is illegal (because there is no common type to which both elements can be converted losslessly).
</p>


<p>
  <a name="167025"> </a>Reference to elements of matrices have the form "<i>matrix</i>(<i>n</i>, <i>m</i>)" or "<i>name</i>(<i>n</i>, <i>m</i>)" where <i>name</i> is the name of a matrix variable in scope, <i>n</i> is the row index, and <i>m</i> is the column index. Index numbers start with zero, as in Java, not 1, as in MATLAB. For example,
</p>

<pre>
<a name="196100"> </a>
&gt;&gt; [1, 2; 3, 4](0,0)<a name="196106"> </a>
1<a name="196107"> </a>
&gt;&gt; a = [1, 2; 3, 4]<a name="196108"> </a>
[1, 2; 3, 4]<a name="196109"> </a>
&gt;&gt; a(1,1)<a name="196110"> </a>
4<a name="196104"> </a>
<a name="196114"> </a>
</pre>

<p>
  <a name="183127"> </a>Matrix multiplication works as expected. For example, as seen in the expression evaluator (see figure <a href="#183566">3.1</a>),
</p>

<pre>
<a name="183161"> </a>
&gt;&gt; [1, 2; 3, 4]*[2, 2; 2, 2]<a name="183167"> </a>
[6, 6; 14, 14]<a name="183165"> </a>
<a name="183175"> </a>
</pre>

<a name="190332"> </a>Of course, if the dimensions of the matrix don't match, then you will get an error message. To do element wise multiplication, use the multipyElements() function (see <a href="#195091">Table 6 on page 98</a>). Matrix addition and subtraction are element wise, as expected, but the division operator is not supported. Element wise division can be accomplished with the divideElements() function, and multiplication by a matrix inverse can be accomplished using the inverse() function (see <a href="#195091">Table 6 on page 98</a>). A matrix can be raised to an <i>int</i> or <i>unsignedByte</i> power, which is equivalent to multiplying it by itself some number of times. For instance,<br>

<pre>
<a name="183193"> </a>
&gt;&gt; [3, 0; 0, 3]^3<a name="190349"> </a>
[27, 0; 0, 27]<a name="183189"> </a>
<a name="192936"> </a>
</pre>

<a name="190348"> </a>A matrix can also be multiplied or divided by a scalar, as follows:<br>

<pre>
<a name="183181"> </a>
&gt;&gt; [3, 0; 0, 3]*3<a name="183250"> </a>
[9, 0; 0, 9]<a name="183248"> </a>
<a name="183258"> </a>
</pre>

<a name="183259"> </a>A matrix can be added to a scalar. It can also be subtracted from a scalar, or have a scalar subtracted from it. For instance,<br>

<pre>
<a name="184024"> </a>
&gt;&gt; 1-[3, 0; 0, 3]<a name="184030"> </a>
[-2, 1; 1, -2]<a name="184028"> </a>
<a name="184038"> </a>
</pre>

<a name="184020"> </a>A matrix can be checked for equality with another matrix as follows:<br>

<pre>
<a name="183267"> </a>
&gt;&gt; [3, 0; 0, 3]!=[3, 0; 0, 6]<a name="183273"> </a>
true<a name="183274"> </a>
&gt;&gt; [3, 0; 0, 3]==[3, 0; 0, 3]<a name="183275"> </a>
true<a name="183271"> </a>
<a name="183279"> </a>
</pre>

<a name="188905"> </a>For other comparisons of matrices, use the compare() function (see <a href="#194754">Table 5 on page 96</a>). As with scalars, testing for equality using the ==</font> or !=</font> operators tests the values, independent of type. For example,<br>

<pre>
<a name="188906"> </a>
&gt;&gt; [1, 2]==[1.0, 2.0]<a name="188907"> </a>
true<a name="188908"> </a>
<a name="190353"> </a>
</pre>

<a name="190356"> </a>To get type-specific equality tests, use the equals() method, as in the following examples:<br>

<pre>
<a name="190357"> </a>
&gt;&gt; [1, 2].equals([1.0, 2.0])<a name="190358"> </a>
false<a name="190359"> </a>
&gt;&gt; [1.0, 2.0].equals([1.0, 2.0])<a name="190360"> </a>
true<a name="190361"> </a>
&gt;&gt; <a name="190362"> </a>
</pre>

<h4>
  <a name="169771"> </a>3.4.3   Records
</h4>


<a name="191373"> </a>A record token is a composite type containing named fields, where each field has a value. The value of each field can have a distinct type. Records are delimited by curly braces, with each field given a name. For example, "{a=1, b="foo"}</font>" is a record with two fields, named "a" and "b", with values 1 (an integer) and "foo" (a string), respectively. The value of a field can be an arbitrary expression, and records can be nested (a field of a record token may be a record token).<br>


<p>
  <a name="191374"> </a>Fields may be accessed using the period operator. For example,
</p>

<pre>
<a name="191375"> </a>
{a=1,b=2}.a<a name="184039"> </a>
<a name="184040"> </a>
</pre>

<a name="176782"> </a>yields 1. You can optionally write this as if it were a method call:<br>

<pre>
<a name="176772"> </a>
{a=1,b=2}.a()<a name="184041"> </a>
<a name="184042"> </a>
</pre>

<a name="191386"> </a>The arithmetic operators +, <font  face="Symbol">-</font>, *, /, and %</font> can be applied to records. If the records do not have identical fields, then the operator is applied only to the fields that match, and the result contains only the fields that match. Thus, for example,<br>

<pre>
<a name="184836"> </a>
{foodCost=40, hotelCost=100} + {foodCost=20, taxiCost=20}<a name="184861"> </a>
<a name="184837"> </a>
</pre>

<a name="184838"> </a>yields the result<br>

<pre>
<a name="184841"> </a>
{foodCost=60}<a name="184842"> </a>
<a name="184843"> </a>
</pre>

<a name="191471"> </a>You can think of an operation as a set intersection, where the operation specifies how to merge the values of the intersecting fields. You can also form an intersection without applying an operation. In this case, using the intersect() function, you form a record that has only the common fields of two specified records, with the values taken from the first record. For example,<br>

<pre>
<a name="191481"> </a>
&gt;&gt; intersect({a=1, c=2}, {a=3, b=4})<a name="191486"> </a>
{a=1}<a name="191476"> </a>
<a name="191485"> </a>
</pre>

<p>
  <a name="191473"> </a>Records can be joined (think of a set union) without any operation being applied by using the merge() function. This function takes two arguments, both of which are record tokens. If the two record tokens have common fields, then the field value from the first record is used. For example,
</p>

<pre>
<a name="184925"> </a>
merge({a=1, b=2}, {a=3, c=3})<a name="184929"> </a>
<a name="191458"> </a>
</pre>

<a name="191459"> </a>yields the result {a=1, b=2, c=3}</font>. <br>


<p>
  <a name="191460"> </a>Records can be compared, as in the following examples:
</p>

<pre>
<a name="187014"> </a>
&gt;&gt; {a=1, b=2}!={a=1, b=2}<a name="187020"> </a>
false<a name="187021"> </a>
&gt;&gt; {a=1, b=2}!={a=1, c=2}<a name="187022"> </a>
true<a name="187018"> </a>
<a name="187030"> </a>
</pre>

<a name="187031"> </a>Note that two records are equal only if they have the same field labels and the values match. As with scalars, the values match irrespective of type. For example:<br>

<pre>
<a name="188860"> </a>
&gt;&gt; {a=1, b=2}=={a=1.0, b=2.0+0.0i}<a name="188926"> </a>
true<a name="190426"> </a>
<a name="190427"> </a>
</pre>

<a name="191424"> </a>The order of the fields is irrelevant. Hence<br>

<pre>
<a name="191436"> </a>
&gt;&gt; {a=1, b=2}=={b=2, a=1}<a name="191440"> </a>
true<a name="191441"> </a>
<a name="191442"> </a>
</pre>

<a name="191443"> </a>Moreover, record fields are reported in alphabetical order, irrespective of the order in which they are defined. For example,<br>

<pre>
<a name="191447"> </a>
&gt;&gt; {b=2, a=1}<a name="191451"> </a>
{a=1, b=2}<a name="191452"> </a>
<a name="191453"> </a>
</pre>

<a name="190431"> </a>To get type-specific equality tests, use the equals() method, as in the following examples:<br>

<pre>
<a name="188862"> </a>
&gt;&gt; {a=1, b=2}.equals({a=1.0, b=2.0+0.0i})<a name="188930"> </a>
false<a name="188863"> </a>
&gt;&gt; {a=1, b=2}.equals({b=2, a=1})<a name="188864"> </a>
true<a name="188865"> </a>
&gt;&gt; <a name="188855"> </a>
</pre>

<h3>
  <a name="184832"> </a>3.5   Invoking Methods
</h3>


<p>
  <a name="184051"> </a>Every element and subexpression in an expression represents an instance of the Token class in Ptolemy II (or more likely, a class derived from Token). The expression language supports invocation of any method of a given token, as long as the arguments of the method are of type Token and the return type is Token (or a class derived from Token, or something that the expression parser can easily convert to a token, such as a string, double, int, etc.). The syntax for this is (<i>token</i>).<i>methodName</i>(<i>args</i>), where <i>methodName</i> is the name of the method and <i>args</i> is a comma-separated set of arguments. Each argument can itself be an expression. Note that the parentheses around the <i>token</i> are not required, but might be useful for clarity. As an example, the ArrayToken and RecordToken classes have a length() method, illustrated by the following examples:
</p>

<pre>
<a name="184058"> </a>
{1, 2, 3}.length()<a name="184060"> </a>
{a=1, b=2, c=3}.length()<a name="184338"> </a>
<a name="184061"> </a>
</pre>

<a name="184062"> </a>each of which returns the integer 3.<br>


<p>
  <a name="184064"> </a>The MatrixToken classes have three particularly useful methods, illustrated in the following examples:
</p>

<pre>
<a name="184065"> </a>
[1, 2; 3, 4; 5, 6].getRowCount()<a name="184067"> </a>
<a name="184068"> </a>
</pre>

<a name="184069"> </a>which returns 3, and<br>

<pre>
<a name="184070"> </a>
[1, 2; 3, 4; 5, 6].getColumnCount()<a name="184072"> </a>
<a name="184073"> </a>
</pre>

<a name="184074"> </a>which returns 2, and<br>

<pre>
<a name="184075"> </a>
[1, 2; 3, 4; 5, 6].toArray()<a name="184077"> </a>
<a name="184078"> </a>
</pre>

<a name="184079"> </a>which returns {1, 2, 3, 4, 5, 6}. The latter function can be particularly useful for creating arrays using MATLAB-style syntax. For example, to obtain an array with the integers from 1 to 100, you can enter:<br>

<pre>
<a name="184080"> </a>
[1:1:100].toArray()<a name="184081"> </a>
<a name="184082"> </a>
</pre>

<p>
  <a name="184048"> </a>
</p>


<h3>
  <a name="190432"> </a>3.6   Defining Functions
</h3>


<a name="184131"> </a>The expression language supports definition of functions. The syntax is:<br>

<pre>
<a name="184132"> </a>
function(arg1:Type, arg2:Type...)<a name="184133"> </a>
    function body <a name="184134"> </a>
<a name="184135"> </a>
</pre>

<a name="184136"> </a>where "function" is the keyword for defining a function. The type of an argument can be left unspecified, in which case the expression language will attempt to infer it. The function body gives an expression that defines the return value of the function. The return type is always inferred based on the argument type and the expression. For example:<br>

<pre>
<a name="184139"> </a>
function(x:double) x*5.0<a name="184140"> </a>
<a name="184141"> </a>
</pre>

<a name="184142"> </a>defines a function that takes a <i>double</i> argument, multiplies it by 5.0, and returns a double. The return value of the above expression is the function itself. Thus, for example, the expression evaluator yields:<br>

<pre>
<a name="184202"> </a>
&gt;&gt; function(x:double) x*5.0<a name="184212"> </a>
(function(x:double) (x*5.0))<a name="184213"> </a>
&gt;&gt; <a name="184210"> </a>
<a name="184217"> </a>
</pre>

<a name="184198"> </a>To apply the function to an argument, simply do<br>

<pre>
<a name="184143"> </a>
&gt;&gt; (function(x:double) x*5.0) (10.0)<a name="184223"> </a>
50.0<a name="184224"> </a>
&gt;&gt; <a name="184221"> </a>
<a name="184228"> </a>
</pre>

<a name="184245"> </a>Alternatively, in the expression evaluator, you can assign the function to a variable, and then use the variable name to apply the function. For example,<br>

<pre>
<a name="191865"> </a>
&gt;&gt; f = function(x:double) x*5.0<a name="191881"> </a>
(function(x:double) (x*5.0))<a name="191882"> </a>
&gt;&gt; f(10)<a name="191883"> </a>
50.0<a name="191884"> </a>
&gt;&gt; <a name="191872"> </a>
<a name="191892"> </a>
</pre>

<p>
  <a name="191864"> </a>Functions can be passed as arguments to certain "higher-order functions" that have been defined (see table <a href="#195813">Table 9 on page 102</a>). For example, the iterate() function takes three arguments, a function, an integer, and an initial value to which to apply the function. It applies the function first to the initial value, then to the result of the application, then to that result, collecting the results into an array whose length is given by the second argument. For example, to get an array whose values are multiples of 3, try
</p>

<pre>
<a name="193771"> </a>
&gt;&gt; iterate(function(x:int) x+3, 5, 0)<a name="193777"> </a>
{0, 3, 6, 9, 12}<a name="193772"> </a>
<a name="193781"> </a>
</pre>

<a name="193782"> </a>The function given as an argument simply adds three to its argument. The result is the specified initial value (0) followed by the result of applying the function once to that initial value, then twice, then three times, etc.<br>


<p>
  <a name="193793"> </a>Another useful higher-order function is the map() function. This one takes a function and an array as arguments, and simply applies the function to each element of the array to construct a result array. For example,
</p>

<pre>
<a name="193795"> </a>
&gt;&gt; map(function(x:int) x+3, {0, 2, 3})<a name="193801"> </a>
{3, 5, 6}<a name="193799"> </a>
<a name="193809"> </a>
</pre>

<p>
  <a name="193773"> </a>A typical use of functions in a Ptolemy II model is to define a parameter in a model whose value is a function. Suppose that the parameter named "f</font>" has value "function(x:double) x*5.0</font>". Then within the scope of that parameter, the expression "f(10.0)</font>" will yield result 50.0.
</p>


<p>
  <a name="184256"> </a>Functions can also be passed along connections in a Ptolemy II model. Consider the model shown in figure <img src="img/expressions40.gif" height="346" width="937" align="center" border="0" hspace="0" vspace="0">
<a href="#184256">3.5</a>. In that example, the Const actor defines a function that simply squares the argument. Its output, therefore, is a token with type <i>function</i>. That token is fed to the "f" input of the Expression actor. The expression uses this function by applying it to the token provided on the "y" input. That token, in turn, is supplied by the Ramp actor, so the result is the curve shown in the plot on the right.
</p>


<p>
  <a name="184278"> </a>A more elaborate use is shown in figure <img src="img/expressions54.gif" height="483" width="937" align="center" border="0" hspace="0" vspace="0">
<a href="#184278">3.6</a>. In that example, the Const actor produces a function, which is then used by the Expression actor to create new function, which is then used by Expression2 to perform a calculation. The calculation performed here adds the output of the Ramp to the square of the output of the Ramp.</font>
</p>


<p>
  <a name="193833"> </a>Functions can be recursive, as illustrated by the following (rather arcane) example:
</p>

<pre>
<a name="193834"> </a>
&gt;&gt; fact = function(x:int,f:(function(x,f) int)) (x&lt;1?1:x*f(x-1,f))<a name="193854"> </a>
(function(x:int, f:function(a0:general, a1:general) int) (x&lt;1)?1:(x*f((x-1), f)))<a name="193855"> </a>
&gt;&gt; factorial = function(x:int) fact(x,fact)<a name="193856"> </a>
(function(x:int) (function(x:int, f:function(a0:general, a1:general) int) (x&lt;1)?1:(x*f((x-1), f)))(x, (function(x:int, f:function(a0:gen-eral, a1:general) int) (x&lt;1)?1:(x*f((x-1), f)))))<a name="193857"> </a>
&gt;&gt; map(factorial, [1:1:5].toArray())<a name="193858"> </a>
{1, 2, 6, 24, 120}<a name="193859"> </a>
&gt;&gt; <a name="193838"> </a>
<a name="193849"> </a>
</pre>

<a name="193863"> </a>The first expression defines a function named "fact" that takes a function as an argument, and if the argument is greater than or equal to 1, uses that function recursively. The second expression defines a new function "factorial" using "fact." The final command applies the factorial function to an array to compute factorials.<br>


<h3>
  <a name="184246"> </a>3.7   Built-In Functions
</h3>


<p>
  <a name="190441"> </a>The expression language includes a set of functions, such as sin(), cos(), etc. The functions that are built in include all static methods of the classes shown <img src="img/expressions20.gif" height="256" width="600" align="left" border="0" hspace="0" vspace="0">
in <a href="#190441">Table 2 on page 88</a>, which together provide a rich set<a href="#190502"><sup>2</sup></a>. The functions currently available are shown in the tables in the appendix, which also show the argument types and return types.</font>
</p>


<p>
  <a name="181854"> </a>In most cases, a function that operates on scalar arguments can also operate on arrays and matrices. Thus, for example, you can fill a row vector with a sine wave using an expression like
</p>

<pre>
<a name="181858"> </a>
sin([0.0:PI/100:1.0])<a name="181862"> </a>
<a name="181863"> </a>
</pre>

<a name="181897"> </a>Or you can construct an array as follows,<br>

<pre>
<a name="182378"> </a>
sin({0.0, 0.1, 0.2, 0.3})<a name="182379"> </a>
<a name="182380"> </a>
</pre>

<a name="182375"> </a>Functions that operate on type <i>double</i> will also generally operate on <i>int</i> or <i>unsignedByte</i>, because these can be losslessly converted to <i>double</i>, but not generally on <i>long</i> or <i>complex</i>.<br>


<p>
  <a name="194173"> </a>Tables of available functions are shown in the appendix. For example, <a href="#194565">Table 4 on page 95</a> shows trigonometric functions. Note that these operate on <i>double</i> or <i>complex</i>, and hence on <i>int</i> and <i>unsignedByte</i>, which can be losslessly converted to <i>double</i>. The result will always be double. For example,
</p>

<pre>
<a name="194161"> </a>
&gt;&gt; cos(0)<a name="194162"> </a>
1.0<a name="194163"> </a>
<a name="194164"> </a>
</pre>

<a name="194165"> </a>These functions will also operate on matrices and arrays, in addition to the scalar types shown in the table, as illustrated above. The result will be a matrix or array of the same size as the argument, but always containing elements of type <i>double</i><br>


<p>
  <a name="187455"> </a><a href="#194754">Table 5 on page 96</a> shows other arithmetic functions beyond the trigonometric functions. As with the trigonometric functions, those that indicate that they operate on <i>double</i> will also work on <i>int</i> and <i>unsignedByte</i>, and unless they indicate otherwise, they will return whatever they return when the argument is <i>double</i>. Those functions in the table that take scalar arguments will also operate on matrices and arrays. For example, since the table indicates that the max() function can take <i>int, int</i> as arguments, then by implication, it can also take {<i>int</i>}, {<i>int</i>}. For example,
</p>

<pre>
<a name="187424"> </a>
&gt;&gt; max({1, 2}, {2, 1})<a name="187425"> </a>
{2, 2}<a name="187426"> </a>
<a name="187427"> </a>
</pre>

<a name="187428"> </a>Notice that the table also indicates that max() can take {<i>int</i>} as an argument. E.g.<br>

<pre>
<a name="187429"> </a>
&gt;&gt; max({1, 2, 3})<a name="187430"> </a>
3<a name="187431"> </a>
<a name="187432"> </a>
</pre>

<a name="192970"> </a>In the former case, the function is applied pointwise to the two arguments. In the latter case, the returned value is the maximum over all the contents of the single argument.<br>


<p>
  <a name="193300"> </a><a href="#195091">Table 6</a> shows functions that only work with matrices, arrays, or records (that is, there is no corresponding scalar operation). Recall that most functions that operate on scalars will also operate on arrays and matrices<a href="#195405">Table 7</a> shows utility functions for evaluating expressions given as strings or representing numbers as strings. Of these, the eval() function is the most flexible (see <a href="#185006">page 89</a>). 
</p>


<a name="189345"> </a>A few of the functions have sufficiently subtle properties that they require further explanation. That explanation is here.<br>


<a name="185006"> </a>eval() and traceEvaluation()<br>


<p>
  <a name="185001"> </a>The built-in function eval() will evaluate a string as an expression in the expression language. For example,
</p>

<pre>
<a name="185095"> </a>
eval("[1.0, 2.0; 3.0, 4.0]")<a name="185096"> </a>
<a name="185097"> </a>
</pre>

<a name="179783"> </a>will return a matrix of doubles. The following combination can be used to read parameters from a file:<br>

<pre>
<a name="179784"> </a>
eval(readFile("filename"))<a name="177806"> </a>
<a name="177814"> </a>
</pre>

<a name="177815"> </a>where the <i>filename</i> can be relative to the current working directory (where Ptolemy II was started, as reported by the property user.dir), the user's home directory (as reported by the property user.home), or the classpath, which includes the directory tree in which Ptolemy II is installed.<br>


<p>
  <a name="187981"> </a>Note that if eval() is used in an Expression actor, then it will be impossible for the type system to infer any more specific output type than <i>general</i>. If you need the output type to be more specific, then you will need to cast the result of eval(). For example, to force it to type <i>double</i>:
</p>

<pre>
<a name="187982"> </a>
&gt;&gt; cast(double, eval("pi/2"))<a name="187983"> </a>
1.5707963267949<a name="187984"> </a>
<a name="187985"> </a>
</pre>

<a name="192132"> </a>The traceEvaluation() function evaluates an expression given as a string, much like eval(), but instead of reporting the result, reports exactly how the expression was evaluated. This can be used to debug expressions, particularly when the expression language is extended by users.<br>


<a name="192134"> </a>random(), gaussian()<br>


<p>
  <a name="192140"> </a>The functions random() and gaussian() shown in <a href="#194754">Table 5 on page 96</a> return one or more random numbers. With the minimum number of arguments (zero or two, respectively), they return a single number. With one additional argument, they return an array of the specified length. With a second additional argument, they return a matrix with the specified number of rows and columns.
</p>


<p>
  <a name="187138"> </a>There is a key subtlety when using these functions in Ptolemy II. In particular, they are evaluated only when the expression within which they appear is evaluated. The result of the expression may be used repeatedly without re-evaluating the expression. Thus, for example, if the <i>value</i> parameter of the <i>Const</i> actor is set to "random()</font>", then its output will be a random constant, i.e., it will not change on each firing. The output will change, however, on successive runs of the model. In contrast, if this is used in an Expression actor, then each firing triggers an evaluation of the expression, and consequently will result in a new random number.
</p>


<a name="185051"> </a>property()<br>


<p>
  <a name="176396"> </a>The property() function accesses system properties by name. Some possibly useful system properties are:
</p>


<a name="176401"> </a>	 ptolemy.ptII.dir: The directory in which Ptolemy II is installed.<br>


<a name="176410"> </a>	 ptolemy.ptII.dirAsURL: The directory in which Ptolemy II is installed, but represented as a URL.<br>


<a name="176423"> </a>	 user.dir: The current working directory, which is usually the directory in which the current executable was started.<br>


<a name="186842"> </a>remainder()<br>


<a name="186848"> </a>This function computes the remainder operation on two arguments as prescribed by the IEEE 754 standard, which is not the same as the modulo operation computed by the % operator. The result of remainder(x, y) is <img src="img/expressions62.gif" height="18" width="39" border="0" hspace="0" vspace="0">
, where <img src="img/expressions63.gif" height="18" width="11" border="0" hspace="0" vspace="0">
 is the integer closest to the exact value of <img src="img/expressions64.gif" height="18" width="22" border="0" hspace="0" vspace="0">
. If two integers are equally close, then <img src="img/expressions65.gif" height="18" width="11" border="0" hspace="0" vspace="0">
 is the integer that is even. This yields results that may be surprising, as indicated by the following examples:<br></font>

<pre>
<a name="186899"> </a>
&gt;&gt; remainder(1,2)<a name="186905"> </a>
1.0<a name="186906"> </a>
&gt;&gt; remainder(3,2)<a name="186915"> </a>
-1.0<a name="186916"> </a>
<a name="186923"> </a>
</pre>

<a name="186924"> </a>Compare this to<br>

<pre>
<a name="186917"> </a>
&gt;&gt; 3%2<a name="186928"> </a>
1<a name="186903"> </a>
</pre>

<a name="186898"> </a>which is different in two ways. The result numerically different and is of type <i>int</i>, whereas remainder()</font> always yields a result of type <i>double</i>. The remainder()</font> function is implemented by the java.lang.Math class, which calls it IEEEremainder()</font>. The documentation for that class gives the following special cases:<br>


<a name="186856"> </a>	 If either argument is NaN, or the first argument is infinite, or the second argument is positive zero or negative zero, then the result is NaN. <br>


<a name="186967"> </a>	 If the first argument is finite and the second argument is infinite, then the result is the same as the first argument.<br>


<a name="192146"> </a>DCT() and IDCT()<br>


<p>
  <a name="192147"> </a>The DCT function can take one, two, or three arguments. In all three cases, the first argument is an array of length <img src="img/expressions43.gif" height="18" width="36" border="0" hspace="0" vspace="0">
 and the DCT returns an </font>
</p>

<div align="center">
<a name="192154"> </a>(4) <img src="img/expressions44.gif" height="52" width="204" border="0" hspace="0" vspace="0">
<br></font>
</div>

<a name="192167"> </a>for <img src="img/expressions53.gif" height="18" width="10" border="0" hspace="0" vspace="0">
 from 0 to <img src="img/expressions66.gif" height="18" width="36" border="0" hspace="0" vspace="0">
, where <img src="img/expressions67.gif" height="18" width="13" border="0" hspace="0" vspace="0">
 is the size of the specified array and <img src="img/expressions68.gif" height="18" width="14" border="0" hspace="0" vspace="0">
 is the size of the DCT. If only one argument is given, then <img src="img/expressions69.gif" height="18" width="14" border="0" hspace="0" vspace="0">
 is set to equal the next power of two larger than <img src="img/expressions70.gif" height="18" width="13" border="0" hspace="0" vspace="0">
. If a second argument is given, then its value is the <i>order</i> of the DCT, and the size of the DCT is <img src="img/expressions71.gif" height="23" width="38" border="0" hspace="0" vspace="0">
. If a third argument is given, then it specifies the scaling factors <img src="img/expressionsa.gif" height="21" width="14" border="0" hspace="0" vspace="0">
 according to the following table:

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="192182"> </a><font face="Times New Roman">TABLE 3:  Normalization options for the DCT function</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="192188"> </a>Name</th>
    <th><a name="192190"> </a>Third argument</th>
    <th><a name="192192"> </a>Normalization</th>
  </tr>
  <tr>
    <td><div align="center"><a name="192194"> </a>Normalized</div></td>
    <td><div align="center"><a name="192196"> </a>0</div></td>
    <td><a name="192201"> </a><img src="img/expressions3.gif" height="54" width="139" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><div align="center"><a name="192203"> </a>Unnormalized</div></td>
    <td><div align="center"><a name="192205"> </a>1</div></td>
    <td><a name="192210"> </a><img src="img/expressions4.gif" height="21" width="45" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><div align="center"><a name="192212"> </a>Orthonormal</div></td>
    <td><div align="center"><a name="192214"> </a>2</div></td>
    <td><a name="192219"> </a><img src="img/expressions6.gif" height="78" width="159" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
</table>



<br></font>


<a name="192220"> </a>The default, if a third argument is not given, is "Normalized."<br>


<p>
  <a name="192226"> </a>The IDCT function is similar, and can also take one, two, or three arguments. The formula in this case is
</p>

<div align="center">
<a name="192233"> </a>(5) <img src="img/expressions10.gif" height="52" width="203" border="0" hspace="0" vspace="0">
.<br></font>
</div>

<h3>
  <a name="171756"> </a>3.8   Fixed Point Numbers
</h3>


<a name="184401"> </a>Ptolemy II includes a preliminary fixed point data type. We represent a fixed point value in the expression language using the following format: <br>

<pre>
<a name="184402"> </a>
fix(value, totalBits, integerBits)<a name="171768"> </a>
<a name="171769"> </a>
</pre>

<a name="175209"> </a>Thus, a fixed point value of 5.375 that uses 8 bit precision of which 4 bits are used to represent the (signed) integer part can be represented as:<br>

<pre>
<a name="175210"> </a>
fix(5.375, 8, 4)<a name="171772"> </a>
<a name="171773"> </a>
</pre>

<a name="171777"> </a>The value can also be a matrix of doubles. The values are rounded, yielding the nearest value representable with the specified precision. If the value to represent is out of range, then it is saturated, meaning that the maximum or minimum fixed point value is returned, depending on the sign of the specified value. For example,<br>

<pre>
<a name="171778"> </a>
fix(5.375, 8, 3)<a name="171779"> </a>
<a name="171780"> </a>
</pre>

<a name="171781"> </a>will yield 3.968758, the maximum value possible with the (8/3) precision.<br>


<p>
  <a name="171783"> </a>In addition to the fix() function, the expression language offers a quantize() function. The arguments are the same as those of the fix() function, but the return type is a DoubleToken or DoubleMatrixToken instead of a FixToken or FixMatrixToken. This function can therefore be used to quantize double-precision values without ever explicitly working with the fixed-point representation.
</p>


<p>
  <a name="171805"> </a>To make the FixToken accessible within the expression language, the following functions are available: 
</p>


<a name="171806"> </a>	 To create a single FixPoint Token using the expression language:<br>

<pre>
fix(5.34, 10, 4)<a name="171807"> </a>
</pre>
<dl>
  <dt> <a name="175175"> </a>This will create a FixToken. In this case, we try to fit the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. 
</dl>

<a name="175176"> </a>	 To create a Matrix with FixPoint values using the expression language:<br>

<pre>
fix([ -.040609, -.001628, .17853 ], 10, 2) <a name="175177"> </a>
</pre>
<dl>
  <dt> <a name="175181"> </a>This will create a FixMatrixToken with 1 row and 3 columns, in which each element is a FixPoint value with precision(10/2). The resulting FixMatrixToken will try to fit each element of the given double matrix into a 10 bit representation with 2 bits used for the integer part. By default the round quantizer is used.
</dl>

<a name="175178"> </a>	 To create a single DoubleToken, which is the quantized version of the double value given, using the expression language:<br>

<pre>
quantize(5.34, 10, 4)<a name="171813"> </a>
</pre>
<dl>
  <dt> <a name="171814"> </a>This will create a DoubleToken. The resulting DoubleToken contains the double value obtained by fitting the number 5.34 into a 10 bit representation with 4 bits used in the integer part. This may lead to quantization errors. By default the round quantizer is used. 
</dl>

<a name="171815"> </a>	 To create a Matrix with doubles quantized to a particular precision using the expression language:<br>

<pre>
quantize([ -.040609, -.001628, .17853 ], 10, 2) <a name="171816"> </a>
</pre>
<dl>
  <dt> <a name="171817"> </a>This will create a DoubleMatrixToken with 1 row and 3 columns. The elements of the token are obtained by fitting the given matrix elements into a 10 bit representation with 2 bits used for the integer part. Instead of being a fixed point value, the values are converted back to their double representation and by default the round quantizer is used.
</dl>

<h3>
  <a name="175821"> </a>3.9   Units
</h3>


<a name="175825"> </a>Ptolemy II supports units systems, which are built on top of the expression language. Units systems allow parameter values to be expressed with units, such as "1.0 * cm", which is equal to "0.01 * meters". These are expressed this way (with the * for multiplication) because "cm" and "meters" are actually variables that become in scope when a units system icon is dragged in to a model. A few simple units systems are provided (mainly as examples) in the utilities library.<br>


<p>
  <a name="176062"> </a>A model using one of the simple provided units systems is shown in figure <img src="img/expressions2.gif" height="330" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="#176062">3.7</a>. This unit system is called BasicUnits; the units it defines can be examined by double clicking on its icon, or by invoking Configure, as shown in figure <img src="img/expressions5.gif" height="382" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="#176062">3.8</a>. In that figure, we see that "meters", "meter", and "m" are defined, and are all synonymous. Moreover, "cm" is defined, and given value "0.01*meters", and "in", "inch" and "inches" are defined, all with value "2.54*cm".</font>
</p>


<p>
  <a name="176135"> </a>In the example in figure <a href="#176062">3.7</a>, a constant with value "1.0 * meter" is fed into a Scale actor with scale factor equal to "2.0/ms". This produces a result with dimensions of length over time. If we feed this result directly into a Display actor, then it is displayed as "2000.0 meters/seconds", as shown in figure <img src="img/expressions11.gif" usemap="#expressions11_gif" height="264" width="600" align="center" border="0" hspace="0" vspace="0">
<map name="expressions11_gif">

<area href="#176062" shape=rect coords="1,238,598,263">
</map>
<a href="#176135">3.9</a>, top display. The canonical units for length are meters, and for time are seconds.</font>
</p>


<p>
  <a name="176145"> </a>In figure <a href="#176062">3.7</a>, we also take the result and feed it to the <i>InUnitsOf</i> actor, which performs divides its input by its argument, and checks to make sure that the result is unitless. This tells us that 2 meters/ms is equal to about 78,740 inches/second.
</p>


<p>
  <a name="176157"> </a>The <i>InUnitsOf</i> actor can be used to ensure that numbers are interpreted correctly in a model, which can be effective in catching certain kinds of critical errors. For example, if in figure <a href="#176062">3.7</a> we had entered "seconds/inch" instead of "inches/second" in the InUnitsOf actor, we would have gotten the exception in figure <img src="img/expressions8.gif" height="134" width="600" align="center" border="0" hspace="0" vspace="0">
<a href="#176157">3.10</a> instead of the execution in figure <a href="#176135">3.9</a>.</font>
</p>


<p>
  <a name="176191"> </a>Units systems are built entirely on the expression language infrastructure in Ptolemy II. The units system icons actually represent instances of <i>scope-extending attributes</i>, which are attributes whose parameters are in scope as if those parameters were directly contained by the container of the scope-extending attribute. That is, scope-extending attributes can define a collection of variables and constants that can be manipulated as a unit. In version 2.0 of Ptolemy II, two fairly extensive units systems are provided, CGSUnitBase and ElectronicUnitBase. Nonetheless, these are intended as examples only, and can no doubt be significantly improved and extended.
</p>


<a name="193871"> </a>Appendix A.  Tables of Functions<br>


<a name="194543"> </a>In this appendix, we tabulate the functions available in the expression language. Further explanation of many of these functions is given in section <a href="#184246">section 3.7</a> above.<br>


<a name="194547"> </a>A.1   Trigonometric Functions<br>


<a name="195083"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="194565"> </a><font face="Times New Roman">TABLE 4:  Trigonometric functions.</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="194573"> </a>function</th>
    <th><a name="194575"> </a>argument type(s)</th>
    <th><a name="194577"> </a>return type</th>
    <th><a name="194579"> </a>description</th>
  </tr>
  <tr>
    <td><a name="194582"> </a>acos</td>
    <td><a name="194584"> </a><i>double</i> in the range[-1.0, 1.0] or</font><a name="194585"> </a>complex</td>
    <td><a name="194587"> </a><i>double</i> in the range[0.0, pi] or NaN if out of range or</font><a name="194588"> </a><i>complex</i></td>
    <td><a name="194590"> </a>arc cosine<a name="194594"> </a><i>complex</i> case: <img src="img/expressions23.gif" height="17" width="173" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194597"> </a>asin</td>
    <td><a name="194599"> </a><i>double</i> in the range[-1.0, 1.0] or</font><a name="194600"> </a><i>complex</i></td>
    <td><a name="194602"> </a><i>double</i> in the range[-pi/2, pi/2] or NaN if out of range</font><a name="194603"> </a>or <i>complex</i></td>
    <td><a name="194605"> </a>arc sine<a name="194609"> </a><i>complex</i> case: <img src="img/expressions25.gif" height="17" width="172" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194612"> </a>atan</td>
    <td><a name="194614"> </a>double or</font></font><a name="194615"> </a>complex</td>
    <td><a name="194617"> </a><i>double</i> in the range [-pi/2, pi/2]</font><a name="194618"> </a>or <i>complex</i></td>
    <td><a name="194620"> </a>arc tangent<a name="194624"> </a><i>complex</i> case: <img src="img/expressions27.gif" height="34" width="121" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194627"> </a>atan2</td>
    <td><a name="194629"> </a><i>double</i>, <i>double</i></td>
    <td><a name="194631"> </a><i>double</i> in the range [-pi, pi]</td>
    <td><a name="194633"> </a>angle of a vector (note: the arguments are (<i>y</i>, <i>x</i>), not (<i>x</i>, <i>y</i>) as one might expect).</td>
  </tr>
  <tr>
    <td><a name="194636"> </a>acosh</td>
    <td><a name="194638"> </a>double greater than 1 or </font>complex</td>
    <td><a name="194640"> </a>double or</font></font><a name="194641"> </a><i>complex</i></td>
    <td><a name="194643"> </a>hyperbolic arc cosine, defined for both <i>double</i> and <i>complex</i> case by: <img src="img/expressions29.gif" height="17" width="166" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194649"> </a>asinh</td>
    <td><a name="194651"> </a>double or</font></font><a name="194652"> </a><i>complex</i></td>
    <td><a name="194654"> </a>double or</font></font><a name="194655"> </a><i>complex</i></td>
    <td><a name="194657"> </a>hyperbolic arc sine<a name="194661"> </a><i>complex</i> case: <img src="img/expressions31.gif" height="22" width="164" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194664"> </a>cos</td>
    <td><a name="194666"> </a>double or</font></font><a name="194667"> </a><i>complex</i></td>
    <td><a name="194672"> </a>double in the range <img src="img/expressions32.gif" height="16" width="38" border="0" hspace="0" vspace="0">
, or</font></font><a name="194673"> </a><i>complex</i></font></td>
    <td><a name="194675"> </a>cosine<a name="194679"> </a><i>complex</i> case: <img src="img/expressions33.gif" height="30" width="159" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194682"> </a>cosh</td>
    <td><a name="194684"> </a>double or</font></font><a name="194685"> </a><i>complex</i></td>
    <td><a name="194687"> </a>double or</font></font><a name="194688"> </a><i>complex</i></td>
    <td><a name="194690"> </a>hyperbolic cosine, defined for <i>double</i> or <i>complex</i> by: <img src="img/expressions34.gif" height="30" width="157" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194696"> </a>sin</td>
    <td><a name="194698"> </a>double or</font></font><a name="194699"> </a><i>complex</i></td>
    <td><a name="194701"> </a>double or</font></font><a name="194702"> </a><i>complex</i></td>
    <td><a name="194704"> </a>sine function<a name="194708"> </a><i>complex</i> case: <img src="img/expressions35.gif" height="30" width="156" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194711"> </a>sinh</td>
    <td><a name="194713"> </a>double or</font></font><a name="194714"> </a><i>complex</i></td>
    <td><a name="194716"> </a>double or</font></font><a name="194717"> </a><i>complex</i></td>
    <td><a name="194719"> </a>hyperbolic sine, defined for <i>double</i> or <i>complex</i> by: <img src="img/expressions36.gif" height="30" width="157" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194725"> </a>tan</td>
    <td><a name="194727"> </a>double or</font></font><a name="194728"> </a><i>complex</i></td>
    <td><a name="194730"> </a>double or</font></font><a name="194731"> </a><i>complex</i></td>
    <td><a name="194733"> </a>tangent function, defined for <i>double</i> or <i>complex</i> by: <img src="img/expressions37.gif" height="30" width="86" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194739"> </a>tanh</td>
    <td><a name="194741"> </a>double or</font></font><a name="194742"> </a><i>complex</i></td>
    <td><a name="194744"> </a>double or</font></font><a name="194745"> </a><i>complex</i></td>
    <td><a name="194747"> </a>hyperbolic tangent, defined for <i>double</i> or <i>complex</i> by: <img src="img/expressions38.gif" height="30" width="98" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
</table>



<br></font>


<a name="195076"> </a>A.2   Basic Mathematical Functions

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="194754"> </a><font face="Times New Roman">TABLE 5:  Basic mathematical functions</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="194762"> </a>function</th>
    <th><a name="194764"> </a>argument type(s)</th>
    <th><a name="194766"> </a>return type</th>
    <th><a name="194768"> </a>description</th>
  </tr>
  <tr>
    <td><a name="194771"> </a>abs</td>
    <td><a name="194773"> </a><i>double</i> or <i>int</i> or <i>long</i> or <i>complex</i></td>
    <td><a name="194775"> </a><i>double</i> or <i>int</i> or <i>long</i></font><a name="194776"> </a>(<i>complex</i> returns double)</td>
    <td><a name="194778"> </a>absolute value<a name="194782"> </a>complex case: <img src="img/expressions39.gif" height="23" width="150" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194785"> </a>angle</td>
    <td><a name="194787"> </a>complex</td>
    <td><a name="194789"> </a><i>double</i> in the range [-pi, pi]</td>
    <td><a name="194794"> </a>angle or argument of the complex number: <img src="img/expressions42.gif" height="16" width="17" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194797"> </a>ceil</td>
    <td><a name="194799"> </a>double</td>
    <td><a name="194801"> </a>double</td>
    <td><a name="194803"> </a>ceiling function, which returns the smallest (closest to negative infinity) <i>double</i> value that is not less than the argument and is an integer.</td>
  </tr>
  <tr>
    <td><a name="194806"> </a>compare</td>
    <td><a name="194808"> </a><i>double</i>, <i>double</i></td>
    <td><a name="194810"> </a>int</td>
    <td><a name="194812"> </a>compare two numbers, returning -1, 0, or 1 if the first argument is less than, equal to, or greater than the second.</td>
  </tr>
  <tr>
    <td><a name="194815"> </a>conjugate</td>
    <td><a name="194817"> </a>complex</td>
    <td><a name="194819"> </a>complex</td>
    <td><a name="194821"> </a>complex conjugate</td>
  </tr>
  <tr>
    <td><a name="194824"> </a>exp</td>
    <td><a name="194826"> </a><i>double</i> or</font><a name="194827"> </a>complex</td>
    <td><a name="194829"> </a><i>double</i> in the range[0.0, infinity] or complex</td>
    <td><a name="194831"> </a>exponential function (e^argument)<a name="194835"> </a>complex case: <img src="img/expressions45.gif" height="20" width="153" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194838"> </a>floor</td>
    <td><a name="194840"> </a>double</td>
    <td><a name="194842"> </a>double</td>
    <td><a name="194844"> </a>floor function, which is the largest (closest to positive infinity) value not greater than the argument that is an integer.</td>
  </tr>
  <tr>
    <td><a name="194847"> </a>gaussian</td>
    <td><a name="194849"> </a><i>double</i>, <i>double</i> or</font><a name="194850"> </a><i>double</i>, <i>double</i>, <i>int</i>, or</font><a name="194851"> </a><i>double</i>, <i>double</i>, <i>int</i>, <i>int</i></td>
    <td><a name="194853"> </a><i>double</i> or</font><a name="194854"> </a>{<i>double</i>} or</font><a name="194855"> </a>[<i>double</i>]</td>
    <td><a name="194857"> </a>one or more Gaussian random variables with the specified mean and standard deviation (see <a href="#192134">page 89</a>).</td>
  </tr>
  <tr>
    <td><a name="194863"> </a>imag</td>
    <td><a name="194865"> </a>complex</td>
    <td><a name="194867"> </a>double</td>
    <td><a name="194869"> </a>imaginary part</td>
  </tr>
  <tr>
    <td><a name="194872"> </a>isInfinite</td>
    <td><a name="194874"> </a>double</td>
    <td><a name="194876"> </a>boolean</td>
    <td><a name="194878"> </a>return true if the argument is infinite</td>
  </tr>
  <tr>
    <td><a name="194881"> </a>isNaN</td>
    <td><a name="194883"> </a>double</td>
    <td><a name="194885"> </a>boolean</td>
    <td><a name="194887"> </a>return true if the argument is "not a number"</td>
  </tr>
  <tr>
    <td><a name="194890"> </a>log</td>
    <td><a name="194892"> </a><i>double</i> or</font><a name="194893"> </a>complex</td>
    <td><a name="194895"> </a><i>double</i> or</font><a name="194896"> </a>complex</td>
    <td><a name="194898"> </a>natural logarithm<a name="194902"> </a>complex case: <img src="img/expressions51.gif" height="16" width="168" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="194905"> </a>log10</td>
    <td><a name="194907"> </a>double</td>
    <td><a name="194909"> </a>double</td>
    <td><a name="194911"> </a>log base 10</td>
  </tr>
  <tr>
    <td><a name="194914"> </a>log2</td>
    <td><a name="194916"> </a>double</td>
    <td><a name="194918"> </a>double</td>
    <td><a name="194920"> </a>log base 2</td>
  </tr>
  <tr>
    <td><a name="194923"> </a>max</td>
    <td><a name="194925"> </a><i>double</i>, <i>double</i> or</font><a name="194926"> </a><i>int</i>, <i>int</i> or</font><a name="194927"> </a><i>long</i>, <i>long </i>or</font><a name="194928"> </a><i>unsignedByte, unsignedByte</i> or</font><a name="194929"> </a>{<i>double</i>} or</font><a name="194930"> </a>{<i>int</i>} or</font><a name="194931"> </a>{<i>long</i>} or</font><a name="194932"> </a>{<i>unsignedByte</i>}</td>
    <td><a name="194934"> </a><i>double</i> or</font><a name="194935"> </a><i>int</i> or</font><a name="194936"> </a>long or</font></font><a name="194937"> </a>unsignedByte</td>
    <td><a name="194939"> </a>maximum</td>
  </tr>
  <tr>
    <td><a name="194942"> </a>min</td>
    <td><a name="194944"> </a><i>double</i>, <i>double</i> or</font><a name="194945"> </a><i>int</i>, <i>int</i> or</font><a name="194946"> </a><i>long</i>, <i>long </i>or</font><a name="194947"> </a><i>unsignedByte, unsignedByte</i> or</font><a name="194948"> </a>{<i>double</i>} or</font><a name="194949"> </a>{<i>int</i>} or</font><a name="194950"> </a>{<i>long</i>} or</font><a name="194951"> </a>{<i>unsignedByte</i>}</td>
    <td><a name="194953"> </a><i>double</i> or</font><a name="194954"> </a><i>int</i> or</font><a name="194955"> </a>long or</font></font><a name="194956"> </a>unsignedByte</td>
    <td><a name="194958"> </a>minimum</td>
  </tr>
  <tr>
    <td><a name="194961"> </a>neighborhood</td>
    <td><a name="194963"> </a>type, type, double</td>
    <td><a name="194965"> </a>boolean</td>
    <td><a name="194967"> </a>return true if the first argument is in the neighborhood of the second, meaning that the distance is less than or equal to the third argument. The first two arguments can be any type for which such a distance is defined. For composite types, arrays, records, and matrices, then return true if the first two arguments have the same structure, and each corresponding element is in the neighborhood.</td>
  </tr>
  <tr>
    <td><a name="194970"> </a>pow</td>
    <td><a name="194972"> </a><i>double</i>, <i>double</i> or</font><a name="194973"> </a><i>complex</i>, <i>complex</i></td>
    <td><a name="194975"> </a>double or</font><a name="194976"> </a>complex</td>
    <td><a name="194978"> </a>first argument to the power of the second</td>
  </tr>
  <tr>
    <td><a name="194981"> </a>random</td>
    <td><a name="194983"> </a>no arguments or</font><a name="194984"> </a><i>int</i> or</font><a name="194985"> </a><i>int, int</i></td>
    <td><a name="194987"> </a>double or</font></font><a name="194988"> </a>{<i>double</i>} or</font><a name="194989"> </a>[<i>double</i>]</td>
    <td><a name="194991"> </a>one or more random numbers between 0.0 and 1.0 (see <a href="#192134">page 89</a>)</td>
  </tr>
  <tr>
    <td><a name="194997"> </a>real</td>
    <td><a name="194999"> </a>complex</td>
    <td><a name="195001"> </a>double</td>
    <td><a name="195003"> </a>real part</td>
  </tr>
  <tr>
    <td><a name="195006"> </a>remainder</td>
    <td><a name="195008"> </a><i>double</i>, <i>double</i></td>
    <td><a name="195010"> </a>double</td>
    <td><a name="195012"> </a>remainder after division, according to the IEEE 754 floating-point standard (see <a href="#186842">page 90</a>).</td>
  </tr>
  <tr>
    <td><a name="195018"> </a>round</td>
    <td><a name="195020"> </a>double</td>
    <td><a name="195022"> </a>long</td>
    <td><a name="195024"> </a>round to the nearest <i>long</i>, choosing the next greater integer when exactly in between, and throwing an exception if out of range. If the argument is NaN, the result is 0L. If the argument is out of range, the result is either MaxLong or MinLong, depending on the sign.</td>
  </tr>
  <tr>
    <td><a name="195027"> </a>roundToInt</td>
    <td><a name="195029"> </a>double</td>
    <td><a name="195031"> </a>int</td>
    <td><a name="195033"> </a>round to the nearest <i>int</i>, choosing the next greater integer when exactly in between, and throwing an exception if out of range. If the argument is NaN, the result is 0. If the argument is out of range, the result is either MaxInt or MinInt, depending on the sign.</td>
  </tr>
  <tr>
    <td><a name="195036"> </a>sgn</td>
    <td><a name="195038"> </a>double</td>
    <td><a name="195040"> </a>int</td>
    <td><a name="195042"> </a>-1 if the argument is negative, 1 otherwise</td>
  </tr>
  <tr>
    <td><a name="195045"> </a>sqrt</td>
    <td><a name="195047"> </a><i>double</i> or</font><a name="195048"> </a>complex</td>
    <td><a name="195050"> </a><i>double</i> or</font><a name="195051"> </a>complex</td>
    <td><a name="195053"> </a>square root. If the argument is <i>double</i> with value less than zero, then the result is NaN.<a name="195057"> </a>complex case: <img src="img/expressions61.gif" height="34" width="187" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="195060"> </a>toDegrees</td>
    <td><a name="195062"> </a>double</td>
    <td><a name="195064"> </a>double</td>
    <td><a name="195066"> </a>convert radians to degrees</td>
  </tr>
  <tr>
    <td><a name="195069"> </a>toRadians</td>
    <td><a name="195071"> </a>double</td>
    <td><a name="195073"> </a>double</td>
    <td><a name="195075"> </a>convert degrees to radians</td>
  </tr>
</table>



<br></font>


<a name="194197"> </a>A.3   Matrix, Array, and Record Functions.

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="195091"> </a><font face="Times New Roman">TABLE 6:  Functions that take or return matrices, arrays, or records.</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="195099"> </a>function</th>
    <th><a name="195101"> </a>argument type(s)</th>
    <th><a name="195103"> </a>return type</th>
    <th><a name="195105"> </a>description</th>
  </tr>
  <tr>
    <td><a name="195108"> </a>arrayToMatrix</td>
    <td><a name="195110"> </a>{<i>type</i>}, int, int</td>
    <td><a name="195112"> </a>[<i>type</i>]</td>
    <td><a name="195114"> </a>Create a matrix from the specified array with the specified number of rows and columns</td>
  </tr>
  <tr>
    <td><a name="195117"> </a>conjugateTranspose</td>
    <td><a name="195119"> </a>[<i>complex</i>]</td>
    <td><a name="195121"> </a>[<i>complex</i>]</td>
    <td><a name="195123"> </a>Return the conjugate transpose of the specified matrix.</td>
  </tr>
  <tr>
    <td><a name="195126"> </a>createSequence</td>
    <td><a name="195128"> </a><i>type, type, </i>int</td>
    <td><a name="195130"> </a>{</font>type}</font></td>
    <td><a name="195132"> </a>Create an array with values starting with the first argument, incremented by the second argument, of length given by the third argument.</td>
  </tr>
  <tr>
    <td><a name="195135"> </a>crop</td>
    <td><a name="195137"> </a>[<i>int</i>], <i>int</i>, <i>int</i>, <i>int</i>, <i>int</i> or</font><a name="195138"> </a>[<i>double</i>], <i>int</i>, <i>int</i>, <i>int</i>, <i>int</i> or</font><a name="195139"> </a>[<i>complex</i>], <i>int</i>, <i>int</i>, <i>int</i>, <i>int</i> or</font><a name="195140"> </a>[<i>long</i>], <i>int</i>, <i>int</i>, <i>int</i>, <i>int</i> or</td>
    <td><a name="195142"> </a>[</font>int] or</font></font><a name="195143"> </a>[</font>double] or</font></font><a name="195144"> </a>[</font>complex] or</font></font><a name="195145"> </a>[</font>long] or</font></td>
    <td><a name="195147"> </a>Given a matrix of any <i>type</i>, return a submatrix starting at the specified row and column with the specified number of rows and columns.</td>
  </tr>
  <tr>
    <td><a name="195150"> </a>determinant</td>
    <td><a name="195152"> </a>[<i>double</i>] or </font><a name="195153"> </a>[<i>complex</i>]</td>
    <td><a name="195155"> </a><i>double</i> or</font><a name="195156"> </a>complex</td>
    <td><a name="195158"> </a>Return the determinant of the specified matrix.</td>
  </tr>
  <tr>
    <td><a name="195161"> </a>diag</td>
    <td><a name="195163"> </a>{<i>type</i>}</td>
    <td><a name="195165"> </a>[<i>type</i>]</td>
    <td><a name="195167"> </a>Return a diagonal matrix with the values along the diagonal given by the specified array.</td>
  </tr>
  <tr>
    <td><a name="195170"> </a>divideElements</td>
    <td><a name="195172"> </a>[<i>type</i>], [<i>type</i>]</td>
    <td><a name="195174"> </a>[<i>type</i>]</td>
    <td><a name="195176"> </a>Return the element-by-element division of two matrices</td>
  </tr>
  <tr>
    <td><a name="195179"> </a>hilbert</td>
    <td><a name="195181"> </a>int</td>
    <td><a name="195183"> </a>[<i>double</i>]</td>
    <td><a name="195185"> </a>Return a square Hilbert matrix, where <img src="img/expressions30.gif" height="19" width="94" border="0" hspace="0" vspace="0">
.</font><a name="195186"> </a>A Hilbert matrix is nearly, but not quite singular.</font></td>
  </tr>
  <tr>
    <td><a name="195189"> </a>identityMatrixComplex</td>
    <td><a name="195191"> </a>int</td>
    <td><a name="195193"> </a>[<i>complex</i>]</td>
    <td><a name="195195"> </a>Return an identity matrix with the specified dimension.</td>
  </tr>
  <tr>
    <td><a name="195198"> </a>identityMatrixDouble</td>
    <td><a name="195200"> </a>int</td>
    <td><a name="195202"> </a>[<i>double</i>]</td>
    <td><a name="195204"> </a>Return an identity matrix with the specified dimension.</td>
  </tr>
  <tr>
    <td><a name="195207"> </a>identityMatrixInt</td>
    <td><a name="195209"> </a>int</td>
    <td><a name="195211"> </a>[<i>int</i>]</td>
    <td><a name="195213"> </a>Return an identity matrix with the specified dimension.</td>
  </tr>
  <tr>
    <td><a name="195216"> </a>identityMatrixLong</td>
    <td><a name="195218"> </a>int</td>
    <td><a name="195220"> </a>[<i>long</i>]</td>
    <td><a name="195222"> </a>Return an identity matrix with the specified dimension.</td>
  </tr>
  <tr>
    <td><a name="195225"> </a>intersect</td>
    <td><a name="195227"> </a>record, record</td>
    <td><a name="195229"> </a>record</td>
    <td><a name="195231"> </a>Return a record that contains only fields that are present in both arguments, where the value of the field is taken from the first record.</td>
  </tr>
  <tr>
    <td><a name="195234"> </a>inverse</td>
    <td><a name="195236"> </a>[<i>double</i>] or </font><a name="195237"> </a>[<i>complex</i>]</td>
    <td><a name="195239"> </a>[<i>double</i>] or</font><a name="195240"> </a>[<i>complex</i>]</td>
    <td><a name="195242"> </a>Return the inverse of the specified matrix, or throw an exception if it is singular.</td>
  </tr>
  <tr>
    <td><a name="195245"> </a>matrixToArray</td>
    <td><a name="195247"> </a>[<i>type</i>]</td>
    <td><a name="195249"> </a>{<i>type</i>}</td>
    <td><a name="195251"> </a>Create an array containing the values in the matrix</td>
  </tr>
  <tr>
    <td><a name="195254"> </a>merge</td>
    <td><a name="195256"> </a><i>record</i>, <i>record</i></td>
    <td><a name="195258"> </a>record</td>
    <td><a name="195260"> </a>Merge two records, giving priority to the first one when they have matching record labels.</td>
  </tr>
  <tr>
    <td><a name="195263"> </a>multiplyElements</td>
    <td><a name="195265"> </a>[<i>type</i>]<i>, </i>[<i>type</i>]</td>
    <td><a name="195267"> </a>[<i>type</i>]</td>
    <td><a name="195269"> </a>Multiply element wise the two specified matrices.</td>
  </tr>
  <tr>
    <td><a name="195272"> </a>orthogonalizeColumns</td>
    <td><a name="195274"> </a>[<i>double</i>] or </font><a name="195275"> </a>[<i>complex</i>]</td>
    <td><a name="195277"> </a>[<i>double</i>] or </font><a name="195278"> </a>[<i>complex</i>]</td>
    <td><a name="195280"> </a>Return a similar matrix with orthogonal columns.</td>
  </tr>
  <tr>
    <td><a name="195283"> </a>orthogonalizeRows</td>
    <td><a name="195285"> </a>[<i>double</i>] or</font><a name="195286"> </a>[<i>complex</i>]</td>
    <td><a name="195288"> </a>[<i>double</i>] or</font><a name="195289"> </a>[<i>complex</i>]</td>
    <td><a name="195291"> </a>Return a similar matrix with orthogonal rows.</td>
  </tr>
  <tr>
    <td><a name="195294"> </a>orthonormalizeColumns</td>
    <td><a name="195296"> </a>[<i>double</i>] or</font><a name="195297"> </a>[<i>complex</i>]</td>
    <td><a name="195299"> </a>[<i>double</i>] or</font><a name="195300"> </a>[<i>complex</i>]</td>
    <td><a name="195302"> </a>Return a similar matrix with orthonormal columns.</td>
  </tr>
  <tr>
    <td><a name="195305"> </a>orthonormalizeRows</td>
    <td><a name="195307"> </a>[<i>double</i>] or</font><a name="195308"> </a>[<i>complex</i>]</td>
    <td><a name="195310"> </a>[<i>double</i>] or</font><a name="195311"> </a>[<i>complex</i>]</td>
    <td><a name="195313"> </a>Return a similar matrix with orthonormal rows.</td>
  </tr>
  <tr>
    <td><a name="195316"> </a>repeat</td>
    <td><a name="195318"> </a><i>int</i>, <i>type</i></td>
    <td><a name="195320"> </a>{<i>type</i>}</td>
    <td><a name="195322"> </a>Create an array by repeating the specified token the specified number of times.</td>
  </tr>
  <tr>
    <td><a name="195325"> </a>sum</td>
    <td><a name="195327"> </a>{<i>type</i>} or</font><a name="195328"> </a>[<i>type</i>]</td>
    <td><a name="195330"> </a>type</td>
    <td><a name="195332"> </a>Sum the elements of the specified array or matrix. This throws an exception if the elements do not support addition or if the array is empty (an empty matrix will return zero).</td>
  </tr>
  <tr>
    <td><a name="195335"> </a>trace</td>
    <td><a name="195337"> </a>[<i>type</i>]</td>
    <td><a name="195339"> </a>type</td>
    <td><a name="195341"> </a>Return the trace of the specified matrix.</td>
  </tr>
  <tr>
    <td><a name="195344"> </a>transpose</td>
    <td><a name="195346"> </a>[<i>type</i>]</td>
    <td><a name="195348"> </a>[<i>type</i>]</td>
    <td><a name="195350"> </a>Return the transpose of the specified matrix.</td>
  </tr>
  <tr>
    <td><a name="195353"> </a>zeroMatrixComplex</td>
    <td><a name="195355"> </a>int, </font>int</td>
    <td><a name="195357"> </a>[<i>complex</i>]</td>
    <td><a name="195359"> </a>Return a zero matrix with the specified number of rows and columns.</td>
  </tr>
  <tr>
    <td><a name="195362"> </a>zeroMatrixDouble</td>
    <td><a name="195364"> </a>int, </font>int</td>
    <td><a name="195366"> </a>[<i>double</i>]</td>
    <td><a name="195368"> </a>Return a zero matrix with the specified number of rows and columns.</td>
  </tr>
  <tr>
    <td><a name="195371"> </a>zeroMatrixInt</td>
    <td><a name="195373"> </a>int, </font>int</td>
    <td><a name="195375"> </a>[<i>int</i>]</td>
    <td><a name="195377"> </a>Return a zero matrix with the specified number of rows and columns.</td>
  </tr>
  <tr>
    <td><a name="195380"> </a>zeroMatrixLong</td>
    <td><a name="195382"> </a>int, </font>int</td>
    <td><a name="195384"> </a>[<i>long</i>]</td>
    <td><a name="195386"> </a>Return a zero matrix with the specified number of rows and columns.</td>
  </tr>
</table>



<br></font>


<p>
  <a name="195495"> </a>
</p>


<p>
  <a name="195935"> </a>
</p>


<a name="195928"> </a>A.4   Functions for Evaluating Expressions<br>


<p>
  <a name="195927"> </a>

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="195405"> </a><font face="Times New Roman">TABLE 7:  Utility functions for evaluating expressions</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="195413"> </a>function</th>
    <th><a name="195415"> </a>argument type(s)</th>
    <th><a name="195417"> </a>return type</th>
    <th><a name="195419"> </a>description</th>
  </tr>
  <tr>
    <td><a name="195422"> </a>eval</td>
    <td><a name="195424"> </a>string</td>
    <td><a name="195426"> </a>any type</td>
    <td><a name="195431"> </a>evaluate the specified expression (see <a href="#185006">page 89</a>).</td>
  </tr>
  <tr>
    <td><a name="195434"> </a>parseInt</td>
    <td><a name="195436"> </a>string or</font></font><a name="195437"> </a>string, </font>int</td>
    <td><a name="195439"> </a>int</td>
    <td><a name="195441"> </a>return an <i>int</i> read from a <i>string</i>, using the given radix if a second argument is provided.</td>
  </tr>
  <tr>
    <td><a name="195444"> </a>parseLong</td>
    <td><a name="195446"> </a>string or</font></font><a name="195447"> </a>string, </font>int</td>
    <td><a name="195449"> </a>int</td>
    <td><a name="195451"> </a>return a <i>long</i> read from a <i>string</i>, using the given radix if a second argument is provided.</td>
  </tr>
  <tr>
    <td><a name="195454"> </a>toBinaryString</td>
    <td><a name="195456"> </a>int or </font>long</td>
    <td><a name="195458"> </a>string</td>
    <td><a name="195460"> </a>return a binary representation of the argument</td>
  </tr>
  <tr>
    <td><a name="195463"> </a>toOctalString</td>
    <td><a name="195465"> </a><i>int</i> or <i>long</i></td>
    <td><a name="195467"> </a>string</td>
    <td><a name="195469"> </a>return an octal representation of the argument</td>
  </tr>
  <tr>
    <td><a name="195472"> </a>toString</td>
    <td><a name="195474"> </a><i>double</i> or</font><a name="195475"> </a><i>int</i> or</font><a name="195476"> </a><i>int</i>, <i>int</i> or</font><a name="195477"> </a><i>long</i> or</font><a name="195478"> </a><i>long</i>, <i>int</i></td>
    <td><a name="195480"> </a>string</td>
    <td><a name="195482"> </a>return a string representation of the argument, using the given radix if a second argument is provided.</td>
  </tr>
  <tr>
    <td><a name="195485"> </a>traceEvaluation</td>
    <td><a name="195487"> </a>string</td>
    <td><a name="195489"> </a>string</td>
    <td><a name="195491"> </a>evaluate the specified expression and report details on how it was evaluated (see <a href="#185006">page 89</a>).</td>
  </tr>
</table>



</font>
</p>


<a name="195809"> </a>A.5   Signal Processing Functions

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="195502"> </a><font face="Times New Roman">TABLE 8:  Functions performing signal processing operations</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="195510"> </a>function</th>
    <th><a name="195512"> </a>argument type(s)</th>
    <th><a name="195514"> </a>return type</th>
    <th><a name="195516"> </a>description</th>
  </tr>
  <tr>
    <td><a name="195519"> </a>convolve</td>
    <td><a name="195521"> </a>{</font>double}</font>, {</font>double} or</font></font><a name="195522"> </a>{</font>complex}, {</font>complex}</font></td>
    <td><a name="195524"> </a>{<i>double</i>} or </font><a name="195525"> </a>{<i>complex</i>}</td>
    <td><a name="195527"> </a>Convolve two arrays and return an array whose length is sum of the lengths of the two arguments minus one. Convolution of two arrays is the same as polynomial multiplication.</td>
  </tr>
  <tr>
    <td><a name="195531"> </a>DCT</td>
    <td><a name="195533"> </a>{</font>double} or</font></font><a name="195534"> </a>{</font>double}, </font>int or</font></font><a name="195535"> </a>{</font>double}, </font>int, int</td>
    <td><a name="195537"> </a>{</font>double}</font></td>
    <td><a name="195539"> </a>Return the discrete cosine transform of the specified array, using the specified (optional) length and normalization strategy (see <a href="#192146">page 90</a>).</td>
  </tr>
  <tr>
    <td><a name="195545"> </a>downsample</td>
    <td><a name="195547"> </a>{</font>double}, </font>int or</font></font><a name="195548"> </a>{</font>double}, </font>int, int</td>
    <td><a name="195550"> </a>{</font>double}</font></td>
    <td><a name="195555"> </a>Return a new array with every <img src="img/expressions46.gif" height="16" width="9" border="0" hspace="0" vspace="0">
-th element of the argument array, where <img src="img/expressions47.gif" height="16" width="9" border="0" hspace="0" vspace="0">
 is the second argument. If a third argument is given, then it must be between 0 and <img src="img/expressions48.gif" height="16" width="27" border="0" hspace="0" vspace="0">
, and it specifies an offset into the array (by giving the index of the first output).</font></font></td>
  </tr>
  <tr>
    <td><a name="195564"> </a>FFT</td>
    <td><a name="195566"> </a>{</font>double} or</font></font><a name="195567"> </a>{</font>complex} or</font></font><a name="195568"> </a>{</font>double}, </font>int</font><a name="195569"> </a>{</font>complex}, </font>int</td>
    <td><a name="195571"> </a>{</font>complex}</font></td>
    <td><a name="195574"> </a>Return the fast Fourier transform of the specified array. If the second argument is given with value <img src="img/expressions49.gif" height="16" width="9" border="0" hspace="0" vspace="0">
, then the length of the transform is <img src="img/expressions50.gif" height="20" width="15" border="0" hspace="0" vspace="0">
. Otherwise, the length is the next power of two greater than or equal to the length of the input array. If the input length does not match this length, then input is padded with zeros.</font></font></td>
  </tr>
  <tr>
    <td><a name="195583"> </a>generateBartlettWindow</td>
    <td><a name="195585"> </a>int</td>
    <td><a name="195587"> </a>{<i>double</i>}</td>
    <td><a name="195591"> </a>Return a Bartlett (rectangular) window with the specified length. The end points have value 0.0, and if the length is odd, the center point has value 1.0. For length <i>M + </i>1, the formula is: <img src="img/expressions52.gif" height="85" width="179" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="195597"> </a>generateBlackmanWindow</td>
    <td><a name="195599"> </a>int</td>
    <td><a name="195601"> </a>{<i>double</i>}</td>
    <td><a name="195604"> </a>Return a Blackman window with the specified length. For length <i>M + </i>1, the formula is: <img src="img/expressions56.gif" height="16" width="255" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="195610"> </a>generateBlackmanHarrisWindow</td>
    <td><a name="195612"> </a>int</td>
    <td><a name="195614"> </a>{<i>double</i>}</td>
    <td><a name="195616"> </a>Return a Blackman-Harris window with the specified length. For length <i>M + </i>1, the formula is: <img src="img/expressions57.gif" height="26" width="231" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="195622"> </a>generateGaussianCurve</td>
    <td><a name="195624"> </a>double, double, int</td>
    <td><a name="195626"> </a>{</font>double}</font></td>
    <td><a name="195628"> </a>Return a Gaussian curve with the specified standard deviation, extent, and length. The extent is a multiple of the standard deviation. For instance, to get 100 samples of a Gaussian curve with standard deviation 1.0 out to four standard deviations, use generateGaussianCurve(1.0, 4.0, 100).</td>
  </tr>
  <tr>
    <td><a name="195631"> </a>generateHammingWindow</td>
    <td><a name="195633"> </a>int</td>
    <td><a name="195635"> </a>{<i>double</i>}</td>
    <td><a name="195638"> </a>Return a Hamming window with the specified length. For length <i>M + </i>1, the formula is: <img src="img/expressions58.gif" height="16" width="164" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="195644"> </a>generateHanningWindow</td>
    <td><a name="195646"> </a>int</td>
    <td><a name="195648"> </a>{<i>double</i>}</td>
    <td><a name="195651"> </a>Return a Hanning window with the specified length. For length <i>M + </i>1, the formula is: <img src="img/expressions59.gif" height="16" width="152" border="0" hspace="0" vspace="0">
</font></font></td>
  </tr>
  <tr>
    <td><a name="195657"> </a>generatePolynomialCurve</td>
    <td><a name="195659"> </a>{<i>double</i>}, <i>double</i>, <i>double</i>, <i>int</i></td>
    <td><a name="195661"> </a>{<i>double</i>}</td>
    <td><a name="195663"> </a>Return samples of a curve specified by a polynomial. The first argument is an array with the polynomial coefficients, beginning with the constant term, the linear term, the squared term, etc. The second argument is the value of the polynomial variable at which to begin, and the third argument is the increment on this variable for each successive sample. The final argument is the length of the returned array.</td>
  </tr>
  <tr>
    <td><a name="195666"> </a>generateRaisedCosinePulse</td>
    <td><a name="195668"> </a><i>double</i>, <i>double</i>, <i>int</i></td>
    <td><a name="195670"> </a>{<i>double</i>}</td>
    <td><a name="195672"> </a>Return an array containing a symmetric raised-cosine pulse. This pulse is widely used in communication systems, and is called a "raised cosine pulse" because the magnitude its Fourier transform has a shape that ranges from rectangular (if the excess bandwidth is zero) to a cosine curved that has been raised to be non-negative (for excess bandwidth of 1.0). The elements of the returned array are samples of the function: <div align="center"><a name="195676"> </a><img src="img/expressions60.gif" height="35" width="163" border="0" hspace="0" vspace="0">
,</font></div><a name="195677"> </a>where <i>x</i> is the excess bandwidth (the first argument) and <i>T</i> is the number of samples from the center of the pulse to the first zero crossing (the second argument). The samples are taken with a sampling interval of 1.0, and the returned array is symmetric and has a length equal to the third argument. With an excessBandwidth of 0.0, this pulse is a sinc pulse.</font></td>
  </tr>
  <tr>
    <td><a name="195680"> </a>generateRectangularWindow</td>
    <td><a name="195682"> </a>int</td>
    <td><a name="195684"> </a>{<i>double</i>}</td>
    <td><a name="195686"> </a>Return an array filled with 1.0 of the specified length. This is a rectangular window.</td>
  </tr>
  <tr>
    <td><a name="195690"> </a>IDCT</td>
    <td><a name="195692"> </a>{</font>double} or</font></font><a name="195693"> </a>{</font>double}, </font>int or</font></font><a name="195694"> </a>{</font>double}, </font>int, int</td>
    <td><a name="195696"> </a>{</font>double}</font></td>
    <td><a name="195698"> </a>Return the inverse discrete cosine transform of the specified array, using the specified (optional) length and normalization strategy (see <a href="#192146">page 90</a>).</td>
  </tr>
  <tr>
    <td><a name="195704"> </a>IFFT</td>
    <td><a name="195706"> </a>{</font>double} or</font></font><a name="195707"> </a>{</font>complex} or</font></font><a name="195708"> </a>{</font>double}, </font>int</font><a name="195709"> </a>{</font>complex}, </font>int</td>
    <td><a name="195711"> </a>{</font>complex}</font></td>
    <td><a name="195715"> </a>Return the inverse fast Fourier transform of the specified array. If the second argument is given with value <img src="img/expressions7.gif" height="16" width="9" border="0" hspace="0" vspace="0">
, then the length of the transform is <img src="img/expressions9.gif" height="20" width="15" border="0" hspace="0" vspace="0">
. Otherwise, the length is the next power of two greater than or equal to the length of the input array. If the input length does not match this length, then input is padded with zeros.</font></font></td>
  </tr>
  <tr>
    <td><a name="195724"> </a>nextPowerOfTwo</td>
    <td><a name="195726"> </a>double</td>
    <td><a name="195728"> </a>int</td>
    <td><a name="195730"> </a>Return the next power of two larger than or equal to the argument.</td>
  </tr>
  <tr>
    <td><a name="195733"> </a>poleZeroToFrequency</td>
    <td><a name="195735"> </a>{</font>complex}, {</font>complex}, </font>complex, </font>int</td>
    <td><a name="195737"> </a>{</font>complex}</font></td>
    <td><a name="195739"> </a>Given an array of pole locations, an array of zero locations, a gain term, and a size, return an array of the specified size representing the frequency response specified by these poles, zeros, and gain. This is calculated by walking around the unit circle and forming the product of the distances to the zeros, dividing by the product of the distances to the poles, and multiplying by the gain.</td>
  </tr>
  <tr>
    <td><a name="195742"> </a>sinc</td>
    <td><a name="195744"> </a>double</td>
    <td><a name="195746"> </a>double</td>
    <td><a name="195751"> </a>Return the sinc function, <img src="img/expressions12.gif" height="16" width="44" border="0" hspace="0" vspace="0">
, where special care is taken to ensure that 1.0 is returned if the argument is 0.0.</font></font></td>
  </tr>
  <tr>
    <td><a name="195754"> </a>toDecibels</td>
    <td><a name="195756"> </a><i>double</i></td>
    <td><a name="195758"> </a>double</td>
    <td><a name="195766"> </a>Return <img src="img/expressions13.gif" height="19" width="68" border="0" hspace="0" vspace="0">
, where <img src="img/expressions15.gif" height="16" width="8" border="0" hspace="0" vspace="0">
 is the argument.</font></font></td>
  </tr>
  <tr>
    <td><a name="195769"> </a>unwrap</td>
    <td><a name="195771"> </a>{<i>double</i>}</td>
    <td><a name="195773"> </a>{<i>double</i>}</td>
    <td><a name="195775"> </a>Modify the specified array to unwrap the angles. That is, if the difference between successive values is greater than <img src="img/expressions16.gif" height="16" width="10" border="0" hspace="0" vspace="0">
 in magnitude, then the second value is modified by multiples of <img src="img/expressions18.gif" height="16" width="17" border="0" hspace="0" vspace="0">
 until the difference is less than or equal to <img src="img/expressions19.gif" height="16" width="10" border="0" hspace="0" vspace="0">
. In addition, the first element is modified so that its difference from zero is less than or equal to <img src="img/expressions21.gif" height="16" width="10" border="0" hspace="0" vspace="0">
 in magnitude. </font></font></td>
  </tr>
  <tr>
    <td><a name="195790"> </a>upsample</td>
    <td><a name="195792"> </a>{<i>double</i>}, <i>int</i></td>
    <td><a name="195794"> </a>{<i>double</i>}</td>
    <td><a name="195799"> </a>Return a new array that is the result of inserting <img src="img/expressions22.gif" height="16" width="27" border="0" hspace="0" vspace="0">
 zeroes between each successive sample in the input array, where <img src="img/expressions24.gif" height="16" width="9" border="0" hspace="0" vspace="0">
 is the second argument. The returned array has length <img src="img/expressions26.gif" height="16" width="17" border="0" hspace="0" vspace="0">
, where <i>L</i> is the length of the argument array. It is required that <img src="img/expressions28.gif" height="16" width="28" border="0" hspace="0" vspace="0">
.</font></font></td>
  </tr>
</table>



<br></font>


<p>
  <a name="195918"> </a>
</p>


<a name="195938"> </a>A.6   I/O Functions and Other Miscellaneous Functions

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="195813"> </a><font face="Times New Roman">TABLE 9:  Miscellaneous functions.</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="195821"> </a>function</th>
    <th><a name="195823"> </a>argument type(s)</th>
    <th><a name="195825"> </a>return type</th>
    <th><a name="195827"> </a>description</th>
  </tr>
  <tr>
    <td><a name="195830"> </a>cast</td>
    <td><a name="195832"> </a>type1, </font>type2</td>
    <td><a name="195834"> </a>type1</td>
    <td><a name="195836"> </a>Return the second argument converted to the type of the first, or throw an exception if the conversion is invalid.</td>
  </tr>
  <tr>
    <td><a name="195839"> </a>constants</td>
    <td><a name="195841"> </a>none</td>
    <td><a name="195843"> </a>record</td>
    <td><a name="195845"> </a>Return a record identifying all the globally defined constants in the expression language.</td>
  </tr>
  <tr>
    <td><a name="195848"> </a>findFile</td>
    <td><a name="195850"> </a>string</td>
    <td><a name="195852"> </a>string</td>
    <td><a name="195854"> </a>Given a file name relative to the user directory, current directory, or classpath, return the absolute file name of the first match, or return the name unchanged if no match is found.</td>
  </tr>
  <tr>
    <td><a name="195857"> </a>freeMemory</td>
    <td><a name="195859"> </a>none</td>
    <td><a name="195861"> </a>long</td>
    <td><a name="195863"> </a>Return the approximate number of bytes available for future memory allocation.</td>
  </tr>
  <tr>
    <td><a name="195866"> </a>iterate</td>
    <td><a name="195868"> </a>function, </font>int, </font>type</td>
    <td><a name="195870"> </a>{<i>type</i>}</td>
    <td><a name="195872"> </a>Return an array that results from first applying the specified function to the third argument, then applying it to the result of that application, and repeating to get an array whose length is given by the second argument.</td>
  </tr>
  <tr>
    <td><a name="195875"> </a>map</td>
    <td><a name="195877"> </a>function, {</font>type}</font></td>
    <td><a name="195879"> </a>{<i>type</i>}</td>
    <td><a name="195881"> </a>Return an array that results from applying the specified function to the elements of the specified array.</td>
  </tr>
  <tr>
    <td><a name="195884"> </a>property</td>
    <td><a name="195886"> </a>string</td>
    <td><a name="195888"> </a>string</td>
    <td><a name="195890"> </a>Return a system property with the specified name from the environment, or an empty string if there is none. Some useful properties are java.version, ptolemy.ptII.dir, ptolemy.ptII.dirAsURL, and user.dir.</td>
  </tr>
  <tr>
    <td><a name="195893"> </a>readFile</td>
    <td><a name="195895"> </a>string</td>
    <td><a name="195897"> </a>string</td>
    <td><a name="195899"> </a>Get the string text in the specified file, or throw an exception if the file cannot be found. The file can be absolute, or relative to the current working directory (user.dir), the user's home directory (user.home), or the classpath.</td>
  </tr>
  <tr>
    <td><a name="195902"> </a>readResource</td>
    <td><a name="195904"> </a>string</td>
    <td><a name="195906"> </a>string</td>
    <td><a name="195908"> </a>Get the string text in the specified resource (which is a file found relative to the classpath), or throw an exception if the file cannot be found.</td>
  </tr>
  <tr>
    <td><a name="195911"> </a>totalMemory</td>
    <td><a name="195913"> </a>none</td>
    <td><a name="195915"> </a>long</td>
    <td><a name="195917"> </a>Return the approximate number of bytes used by current objects plus those available for future object allocation.</td>
  </tr>
</table>



<br></font>


  
<a name="175811"> </a><a href="#175578"><sup>1</sup></a>
<a name="175811"> </a>The exceptions are parameters that are strictly string parameters, in which case the value of the parameter is the literal string, not the string interpreted as an expression, as for example the <i>function</i> parameter of the <i>TrigFunction</i> actor, which can take on only "sin," "cos," "tan", "asin", "acos", and "atan" as values.<br>

<br></font>


<a name="190502"> </a><a href="#190441"><sup>2</sup></a>
<a name="190502"> </a>Moreover, the set of available can easily be extended if you are writing Java code by registering another class that includes static methods (see the PtParser class in the ptolemy.data.expr package).<br>

<br></font>

</body>
</html>
