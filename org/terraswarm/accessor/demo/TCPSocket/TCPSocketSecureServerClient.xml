<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="TCPSocketSecureServerClient" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="68.0, 32.0">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={84, 157, 1328, 960}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1094, 850]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.2733100013949763">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{440.66224988903826, 334.0306165537752}">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Demonstrate the secure servers and clients over SSL/TLS.&#10;SSL/TLS is enabled for both the servers and clients.&#10;Required files are strored under certs/.&#10;See certs/README for generation of required files.&#10;&#10;ServerA does not require a certificate for the client in this demo.&#10;&#10;ServerB requires a certificate for the client.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[135.0, 5.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Port number 41018">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[120.0, 75.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="ClientA">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Port number 41018">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[195.0, 55.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="ServerA">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Port number 41019">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[145.0, 85.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="ServerB">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <property name="Annotation5" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Port number 41019">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[120.0, 110.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="ClientB">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <entity name="ClientA" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. Upon initialization, it initiates a connection to the&#10; *  specified server. When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *&#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *&#10; *  If the connection is dropped midway, the client will attempt to reconnect if&#10; *  `reconnectOnClose` is true. This does not apply after the accessor wraps up.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port on the server to connect to. Defaults to 4000.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the password for the pfx key-cert&#10; *    file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the fully qualified filename for &#10; *    the file that stores the private key and certificate that this client will use to authenticate&#10; *    itself to the server. This path can be any of those understood by the Ptolemy host, &#10; *    e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 1000 (1 second).&#10; *  @parameter {boolean} reconnectOnClose If true, then if the connection is closed&#10; *    before this accessor is wrapped up, then attempt to reconnect.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and trustAll is&#10; *    set to false, then this option needs to specify the fully qualified filename&#10; *    for the file that stores the certificate of a certificate authority (CA) that&#10; *    this client will use to verify server certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, send, require*/&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var client = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    output('received');&#10;&#10;    // The most used parameters are listed first.&#10;    parameter('host', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    &#10;    // The remaining parameters are in alphabetical order.&#10;    parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('reconnectAttempts', {&#10;        type : 'int',&#10;        value : 10&#10;    });&#10;    parameter('reconnectInterval', {&#10;        type : 'int',&#10;        value : 1000&#10;    });&#10;    parameter('reconnectOnClose', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustAll', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    &#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;/** Handle input on 'toSend' by sending the specified data to the server. */&#10;exports.toSendInputHandler = function () {&#10;    client.send(get('toSend'));&#10;};&#10;&#10;/** Initiate a connection to the server using the current parameter values,&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server, and set up a handler for inputs&#10; *  on the toSend() input port.&#10; */&#10;exports.initialize = function () {&#10;&#10;    client = new socket.SocketClient(getParameter('port'), getParameter('host'),&#10;        {&#10;            'connectTimeout' : getParameter('connectTimeout'),&#10;            'discardMessagesBeforeOpen' : getParameter('discardMessagesBeforeOpen'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'maxUnsentMessages' : getParameter('maxUnsentMessages'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'pfxKeyCertPassword' : getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath' : getParameter('pfxKeyCertPath'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'reconnectAttempts' : getParameter('reconnectAttempts'),&#10;            'reconnectInterval' : getParameter('reconnectInterval'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls'),&#10;            'trustAll' : getParameter('trustAll'),&#10;            'trustedCACertPath' : getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;&#10;    client.on('open', function() {&#10;        console.log('Status: Connection established');&#10;        send('connected', true);&#10;    });&#10;    client.on('data', function(data) {&#10;        send('received', data);&#10;    });&#10;&#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;&#10;    // Bind onClose() to caller's object, so that 'this' is defined&#10;    // in onClose() to be the object on which this initialize() function&#10;    // is called.&#10;    client.on('close', onClose.bind(callObj));&#10;    client.on('error', function (message) {&#10;        error(message);&#10;    });&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;    console.log('Status: Connection closed: ' + message);&#10;    if (client) {&#10;        // wrapup() has not been called.&#10;        // Probably the server closed the connection.&#10;        send('connected', false);&#10;&#10;        // Close and unregister everything.&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client = null;&#10;&#10;        // Reconnect if reconnectOnClose is true.&#10;        if (getParameter('reconnectOnClose')) {&#10;            // Use 'this' rather than 'export' so initialize() can be overridden.&#10;            this.initialize();&#10;        }&#10;    }&#10;}&#10;&#10;/** Return true if this client has an open connection to the server. */&#10;exports.isOpen = function () {&#10;    return client.isOpen();&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        client = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketClient.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a TCP socket at&#10; the specified host and port. Upon initialization, it initiates a connection to the&#10; specified server. When the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt; input,&#10; the data on that input is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when the socket opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;received&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; connection.&lt;/p&gt;&#10;&lt;p&gt; If the connection is dropped midway, the client will attempt to reconnect if&#10; &lt;code&gt;reconnectOnClose&lt;/code&gt; is true. This does not apply after the accessor wraps up.&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item provided on &lt;code&gt;toSend&lt;/code&gt;,&#10; of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'socket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="host (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to 4000.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time to wait (in milliseconds) before declaring&#10;   a connection attempt to have failed. This defaults to 6000.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any messages&#10;   passed to SocketClient.send() before the socket is opened. If false,&#10;   then queue the messages to be sent when the socket opens. This&#10;   defaults to false.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="maxUnsentMessages (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The maximum number of unsent messages to queue before&#10;   further calls to send() will fail. A value of 0 means no limit.&#10;   This defaults to 100.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available (the default).&#10;   If false, data may be accumulated until a reasonable packet size is formed&#10;   in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="reconnectAttempts (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The number of times to try to reconnect.&#10;   If this is greater than 0, then a failure to attempt will trigger&#10;   additional attempts. This defaults to 10.">
            </property>
            <property name="reconnectInterval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time between reconnect attempts, in&#10;   milliseconds. This defaults to 1000 (1 second).">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then if the connection is closed&#10;   before this accessor is wrapped up, then attempt to reconnect.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to trust servers. This defaults to false.&#10;   Setting it to true means that if sslTls is set to true, then&#10;   any certificate provided by the server will be trusted.&#10;   FIXME: Need to provide a trusted list if this is false.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and trustAll is&#10;   set to false, then this option needs to specify the fully qualified filename&#10;   for the file that stores the certificate of a certificate authority (CA) that&#10;   this client will use to verify server certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the password for the pfx key-cert&#10;   file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the fully qualified filename for &#10;   the file that stores the private key and certificate that this client will use to authenticate&#10;   itself to the server. This path can be any of those understood by the Ptolemy host, &#10;   e.g. paths beginning with $CLASSPATH/.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="host" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="$CLASSPATH/org/terraswarm/accessor/demo/TCPSocket/certs/CACert.pem">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{390.0, 190.0}">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="41018">
        </property>
        <property name="sslTls" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ServerA" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor establishes a server that can accept connection requests for&#10; *  a TCP socket and can send and/or receives messages from the client that makes the&#10; *  request.&#10; *&#10; *  When the server is listening and accepting connections, the port on which it is&#10; *  listening is emitted on the `listening` output port.&#10; *&#10; *  When a connection is established, this accessor outputs on the `connection` output&#10; *  an object with the following fields:&#10; *&#10; *  * **id**: A unique ID identifying the connection (a positive integer).&#10; *  * **remoteHost**: The IP address of the remote host for the socket (a string).&#10; *  * **remotePort**: The port of the remote host for the socket (an integer).&#10; *  * **status**: The string 'open'.&#10; *&#10; *&#10; *  When the connection is closed, the same object as above is produced on the&#10; *  `connection` output, except with status being 'closed'.&#10; *&#10; *  When data is received from the connection, two outputs are produced.&#10; *  The data itself is produced on the `received` output.  The ID of the connection&#10; *  over which the data arrived is produced on the `receivedID` output.&#10; *&#10; *  To send data over a connection, provide the data on the `toSend` input port&#10; *  and the ID of the connection on the `toSendID` input port.  To send to all open&#10; *  connections, provide an ID of 0 (zero).&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item that arrives on&#10; *  `toSend`, of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The client might similarly lose messages by the same two mechanisms occurring&#10; *  on the client side. In that case, messages will presumably be displayed on the&#10; *  client side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. &#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketServer&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @input toSendID The ID of the connection over which to send the data, where 0 means&#10; *    to send to all open connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *    (this is useful if the port is specified to be 0).&#10; *  @output connection Output an object with the fields specified above when a&#10; *     connection is established.&#10; *  @output received The data received from the web socket server.&#10; *  @output receivedID The ID of the connection over which data produced on the received&#10; *    output was received. This is a positive integer, as indicated in the connection&#10; *    output.&#10; *&#10; *  @parameter {string} clientAuth One of 'none', 'request', or 'required', meaning&#10; *    whether it requires that a certificate be presented.&#10; *  @parameter {boolean} discardSendToUnopenedSocket If true, then discard any data&#10; *   sent to a socket that is not open. The data will be logged using console.log()&#10; *   instead. This defaults to false.&#10; *  @parameter {string} hostInterface The name of the network interface to use for&#10; *    listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10; *    listen on all available interfaces.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available&#10; *    (the default). If false, data may be accumulated until a reasonable packet size is&#10; *    formed in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true, then this option&#10; *    needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true, then this option&#10; *    needs to specify the fully qualified filename for the file that stores the&#10; *    private key and certificate that this server will use to identify itself. This path can be&#10; *    any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {int} port The default port to listen on. This defaults to 4000.&#10; *    a value of 0 means to choose a random ephemeral free port.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See below.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See below.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and this server&#10; *    requests/requires a certificate from the client, then this option needs to specify&#10; *    the filename for the file that stores the certificate of a certificate authority (CA) that&#10; *    this server will use to verify client certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, require, send */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    input('toSendID', {&#10;        type: 'int',&#10;        value: 0&#10;    });&#10;    output('listening', {&#10;        type: 'int'&#10;    });&#10;    output('connection');&#10;    output('received');&#10;    output('receivedID');&#10;&#10;    // The parameters below are listed alphabetically.&#10;    parameter('clientAuth', {&#10;        type : 'string',&#10;        value : 'none'    // Indicates no SSL/TSL will be used.&#10;    });&#10;    parameter('discardSendToUnopenedSocket', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('hostInterface', {&#10;        type : 'string',&#10;        value : '0.0.0.0' // Means listen on all available interfaces.&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,         // In seconds. 0 means don't timeout.&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false      // Means to use a messaging protocol.&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;var server = null;&#10;var connectionCount = 0;&#10;var sockets = [];&#10;&#10;/** Handle input on 'toSend' by sending to one or all of the open sockets, depending&#10; *  on the most recently received value on the `toSendID` input.&#10; */&#10;exports.toSendInputHandler = function () {&#10;    var dataToSend = get('toSend');&#10;    var idToSendTo = get('toSendID');&#10;    if (idToSendTo === 0) {&#10;        // Broadcast to all sockets.&#10;        for (var i = 0; i &lt; sockets.length; i++) {&#10;            if (sockets[i]) {&#10;                sockets[i].send(dataToSend);&#10;            }&#10;        }&#10;    } else if (sockets[idToSendTo]) {&#10;        sockets[idToSendTo].send(dataToSend);&#10;    } else {&#10;        var discardSendToUnopenedSocket = getParameter('discardSendToUnopenedSocket');&#10;        if (discardSendToUnopenedSocket) {&#10;            console.log('Socket with ID ' + idToSendTo +&#10;                        ' is not open. Discarding data: ' +&#10;                        dataToSend);&#10;        } else {&#10;            error('Attempting to send data over socket with id ' + idToSendTo +&#10;                    ', but this socket is not open.');&#10;        }&#10;    }&#10;};&#10;&#10;/** Initialize the accessor by starting the server with the current parameter values&#10; *  specifying the options, setting up listeners to be notified when the server is&#10; *  is listening for connections, when a client requests and connection,&#10; *  and when errors occur, and setting up an input handler&#10; *  for data arriving on the toSend input. When a client requests a connection, the&#10; *  handler will open the socket, send a `connection` output, and and set up listeners&#10; *  for incoming data, errors, and closing of the socket from the remote site.&#10; */&#10;exports.initialize = function () {&#10;&#10;    server = new socket.SocketServer(&#10;        {&#10;            'clientAuth' : getParameter('clientAuth'),&#10;            'hostInterface' : getParameter('hostInterface'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'pfxKeyCertPassword' : getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath' : getParameter('pfxKeyCertPath'),&#10;            'port' : getParameter('port'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls'),&#10;            'trustedCACertPath' : getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;&#10;    server.on('error', function(message) {&#10;        error(message);&#10;    });&#10;    &#10;    server.on('listening', function(port) {&#10;        console.log('Server: Listening for socket connection requests.');&#10;        send('listening', port);&#10;    });&#10;    &#10;    server.on('connection', function(serverSocket) {&#10;        connectionCount++;&#10;        var socketID = {&#10;            'id': connectionCount,&#10;            'remoteHost': serverSocket.remoteHost(),&#10;            'remotePort': serverSocket.remotePort(),&#10;            'status': 'open'&#10;        };&#10;        send('connection', socketID);&#10;        &#10;        sockets[connectionCount] = serverSocket;&#10;&#10;        serverSocket.on('close', function() {&#10;            serverSocket.removeAllListeners();&#10;            socketID.status = 'closed';&#10;            send('connection', socketID);&#10;            // Avoid a memory leak here.&#10;            sockets[connectionCount] = null;&#10;        });&#10;        serverSocket.on('data', function(data) {&#10;            send('received', data);&#10;            send('receivedID', connectionCount);&#10;        });&#10;        serverSocket.on('error', function(message) {&#10;            error(message);&#10;        });&#10;    });&#10;    &#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;    // Bind the input handler to caller's object so that when it is invoked,&#10;    // it is invoked in the context of that object and not this one.&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Close all sockets, unregister event listeners, and close the server.&#10; */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        if (sockets[i]) {&#10;            sockets[i].close();&#10;            sockets[i].removeAllListeners();&#10;        }&#10;    }&#10;&#10;    sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor establishes a server that can accept connection requests for&#10; a TCP socket and can send and/or receives messages from the client that makes the&#10; request.&lt;/p&gt;&#10;&lt;p&gt; When the server is listening and accepting connections, the port on which it is&#10; listening is emitted on the &lt;code&gt;listening&lt;/code&gt; output port.&lt;/p&gt;&#10;&lt;p&gt; When a connection is established, this accessor outputs on the &lt;code&gt;connection&lt;/code&gt; output&#10; an object with the following fields:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;id&lt;/strong&gt;: A unique ID identifying the connection (a positive integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remoteHost&lt;/strong&gt;: The IP address of the remote host for the socket (a string).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remotePort&lt;/strong&gt;: The port of the remote host for the socket (an integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt;: The string 'open'.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; When the connection is closed, the same object as above is produced on the&#10; &lt;code&gt;connection&lt;/code&gt; output, except with status being 'closed'.&lt;/p&gt;&#10;&lt;p&gt; When data is received from the connection, two outputs are produced.&#10; The data itself is produced on the &lt;code&gt;received&lt;/code&gt; output.  The ID of the connection&#10; over which the data arrived is produced on the &lt;code&gt;receivedID&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; To send data over a connection, provide the data on the &lt;code&gt;toSend&lt;/code&gt; input port&#10; and the ID of the connection on the &lt;code&gt;toSendID&lt;/code&gt; input port.  To send to all open&#10; connections, provide an ID of 0 (zero).&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item that arrives on&#10; &lt;code&gt;toSend&lt;/code&gt;, of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/p&gt;&#10;&lt;p&gt;The client might similarly lose messages by the same two mechanisms occurring&#10;on the client side. In that case, messages will presumably be displayed on the&#10;client side.&lt;/p&gt;&#10;&lt;p&gt;Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10;to customize what is sent. &lt;/p&gt;&#10;&lt;p&gt;This accessor requires the 'socket' module.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="toSendID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which to send the data, where 0 means&#10;   to send to all open connections.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on&#10;   (this is useful if the port is specified to be 0).">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="Output an object with the fields specified above when a&#10;    connection is established.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="receivedID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which data produced on the received&#10;   output was received. This is a positive integer, as indicated in the connection&#10;   output.">
            </property>
            <property name="clientAuth (parameter)" class="ptolemy.kernel.util.StringAttribute" value="One of 'none', 'request', or 'required', meaning&#10;   whether it requires that a certificate be presented.">
            </property>
            <property name="discardSendToUnopenedSocket (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any data&#10;  sent to a socket that is not open. The data will be logged using console.log()&#10;  instead. This defaults to false.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The name of the network interface to use for&#10;   listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10;   listen on all available interfaces.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available&#10;   (the default). If false, data may be accumulated until a reasonable packet size is&#10;   formed in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the fully qualified filename for the file that stores the&#10;   private key and certificate that this server will use to identify itself. This path can be&#10;   any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The default port to listen on. This defaults to 4000.&#10;   a value of 0 means to choose a random ephemeral free port.">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and this server&#10;   requests/requires a certificate from the client, then this option needs to specify&#10;   the filename for the file that stores the certificate of a certificate authority (CA) that&#10;   this server will use to verify client certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="clientAuth" class="ptolemy.data.expr.Parameter" value="none">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="asdf">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="$CLASSPATH/org/terraswarm/accessor/demo/TCPSocket/certs/Server.pfx">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[175.0, 270.0]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="41018">
        </property>
        <property name="sslTls" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="toSendID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="receivedID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ServerReceived" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={152, 1047, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[315.0, 280.0]">
        </property>
    </entity>
    <entity name="ClientConnected" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={1157, 964, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[490.0, 180.0]">
        </property>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.Clock">
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="1.0">
        </property>
        <property name="offsets" class="ptolemy.data.expr.Parameter" value="{0.0}">
        </property>
        <property name="values" class="ptolemy.data.expr.Parameter" value="{true}">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[165.0, 190.0]">
        </property>
    </entity>
    <entity name="Sequence" class="ptolemy.actor.lib.Sequence">
        <property name="values" class="ptolemy.data.expr.Parameter" value="{&quot;this&quot;, &quot;message&quot;, &quot;is received&quot;, &quot;over SSL/TLS&quot;}">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[265.0, 190.0]">
        </property>
    </entity>
    <entity name="ServerB" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor establishes a server that can accept connection requests for&#10; *  a TCP socket and can send and/or receives messages from the client that makes the&#10; *  request.&#10; *&#10; *  When the server is listening and accepting connections, the port on which it is&#10; *  listening is emitted on the `listening` output port.&#10; *&#10; *  When a connection is established, this accessor outputs on the `connection` output&#10; *  an object with the following fields:&#10; *&#10; *  * **id**: A unique ID identifying the connection (a positive integer).&#10; *  * **remoteHost**: The IP address of the remote host for the socket (a string).&#10; *  * **remotePort**: The port of the remote host for the socket (an integer).&#10; *  * **status**: The string 'open'.&#10; *&#10; *&#10; *  When the connection is closed, the same object as above is produced on the&#10; *  `connection` output, except with status being 'closed'.&#10; *&#10; *  When data is received from the connection, two outputs are produced.&#10; *  The data itself is produced on the `received` output.  The ID of the connection&#10; *  over which the data arrived is produced on the `receivedID` output.&#10; *&#10; *  To send data over a connection, provide the data on the `toSend` input port&#10; *  and the ID of the connection on the `toSendID` input port.  To send to all open&#10; *  connections, provide an ID of 0 (zero).&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item that arrives on&#10; *  `toSend`, of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The client might similarly lose messages by the same two mechanisms occurring&#10; *  on the client side. In that case, messages will presumably be displayed on the&#10; *  client side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. &#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketServer&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @input toSendID The ID of the connection over which to send the data, where 0 means&#10; *    to send to all open connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *    (this is useful if the port is specified to be 0).&#10; *  @output connection Output an object with the fields specified above when a&#10; *     connection is established.&#10; *  @output received The data received from the web socket server.&#10; *  @output receivedID The ID of the connection over which data produced on the received&#10; *    output was received. This is a positive integer, as indicated in the connection&#10; *    output.&#10; *&#10; *  @parameter {string} clientAuth One of 'none', 'request', or 'required', meaning&#10; *    whether it requires that a certificate be presented.&#10; *  @parameter {boolean} discardSendToUnopenedSocket If true, then discard any data&#10; *   sent to a socket that is not open. The data will be logged using console.log()&#10; *   instead. This defaults to false.&#10; *  @parameter {string} hostInterface The name of the network interface to use for&#10; *    listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10; *    listen on all available interfaces.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available&#10; *    (the default). If false, data may be accumulated until a reasonable packet size is&#10; *    formed in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true, then this option&#10; *    needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true, then this option&#10; *    needs to specify the fully qualified filename for the file that stores the&#10; *    private key and certificate that this server will use to identify itself. This path can be&#10; *    any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {int} port The default port to listen on. This defaults to 4000.&#10; *    a value of 0 means to choose a random ephemeral free port.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See below.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See below.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and this server&#10; *    requests/requires a certificate from the client, then this option needs to specify&#10; *    the filename for the file that stores the certificate of a certificate authority (CA) that&#10; *    this server will use to verify client certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;/* These are needed by JSLint, see https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSLint */&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, require, send */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    input('toSendID', {&#10;        type: 'int',&#10;        value: 0&#10;    });&#10;    output('listening', {&#10;        type: 'int'&#10;    });&#10;    output('connection');&#10;    output('received');&#10;    output('receivedID');&#10;&#10;    // The parameters below are listed alphabetically.&#10;    parameter('clientAuth', {&#10;        type : 'string',&#10;        value : 'none'    // Indicates no SSL/TSL will be used.&#10;    });&#10;    parameter('discardSendToUnopenedSocket', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('hostInterface', {&#10;        type : 'string',&#10;        value : '0.0.0.0' // Means listen on all available interfaces.&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,         // In seconds. 0 means don't timeout.&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false      // Means to use a messaging protocol.&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;var server = null;&#10;var connectionCount = 0;&#10;var sockets = [];&#10;&#10;/** Handle input on 'toSend' by sending to one or all of the open sockets, depending&#10; *  on the most recently received value on the `toSendID` input.&#10; */&#10;exports.toSendInputHandler = function () {&#10;    var dataToSend = get('toSend');&#10;    var idToSendTo = get('toSendID');&#10;    if (idToSendTo === 0) {&#10;        // Broadcast to all sockets.&#10;        for (var i = 0; i &lt; sockets.length; i++) {&#10;            if (sockets[i]) {&#10;                sockets[i].send(dataToSend);&#10;            }&#10;        }&#10;    } else if (sockets[idToSendTo]) {&#10;        sockets[idToSendTo].send(dataToSend);&#10;    } else {&#10;        var discardSendToUnopenedSocket = getParameter('discardSendToUnopenedSocket');&#10;        if (discardSendToUnopenedSocket) {&#10;            console.log('Socket with ID ' + idToSendTo +&#10;                        ' is not open. Discarding data: ' +&#10;                        dataToSend);&#10;        } else {&#10;            error('Attempting to send data over socket with id ' + idToSendTo +&#10;                    ', but this socket is not open.');&#10;        }&#10;    }&#10;};&#10;&#10;/** Initialize the accessor by starting the server with the current parameter values&#10; *  specifying the options, setting up listeners to be notified when the server is&#10; *  is listening for connections, when a client requests and connection,&#10; *  and when errors occur, and setting up an input handler&#10; *  for data arriving on the toSend input. When a client requests a connection, the&#10; *  handler will open the socket, send a `connection` output, and and set up listeners&#10; *  for incoming data, errors, and closing of the socket from the remote site.&#10; */&#10;exports.initialize = function () {&#10;&#10;    server = new socket.SocketServer(&#10;        {&#10;            'clientAuth' : getParameter('clientAuth'),&#10;            'hostInterface' : getParameter('hostInterface'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'pfxKeyCertPassword' : getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath' : getParameter('pfxKeyCertPath'),&#10;            'port' : getParameter('port'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls'),&#10;            'trustedCACertPath' : getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;&#10;    server.on('error', function(message) {&#10;        error(message);&#10;    });&#10;    &#10;    server.on('listening', function(port) {&#10;        console.log('Server: Listening for socket connection requests.');&#10;        send('listening', port);&#10;    });&#10;    &#10;    server.on('connection', function(serverSocket) {&#10;        connectionCount++;&#10;        var socketID = {&#10;            'id': connectionCount,&#10;            'remoteHost': serverSocket.remoteHost(),&#10;            'remotePort': serverSocket.remotePort(),&#10;            'status': 'open'&#10;        };&#10;        send('connection', socketID);&#10;        &#10;        sockets[connectionCount] = serverSocket;&#10;&#10;        serverSocket.on('close', function() {&#10;            serverSocket.removeAllListeners();&#10;            socketID.status = 'closed';&#10;            send('connection', socketID);&#10;            // Avoid a memory leak here.&#10;            sockets[connectionCount] = null;&#10;        });&#10;        serverSocket.on('data', function(data) {&#10;            send('received', data);&#10;            send('receivedID', connectionCount);&#10;        });&#10;        serverSocket.on('error', function(message) {&#10;            error(message);&#10;        });&#10;    });&#10;    &#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;    // Bind the input handler to caller's object so that when it is invoked,&#10;    // it is invoked in the context of that object and not this one.&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Close all sockets, unregister event listeners, and close the server.&#10; */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        if (sockets[i]) {&#10;            sockets[i].close();&#10;            sockets[i].removeAllListeners();&#10;        }&#10;    }&#10;&#10;    sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor establishes a server that can accept connection requests for&#10; a TCP socket and can send and/or receives messages from the client that makes the&#10; request.&lt;/p&gt;&#10;&lt;p&gt; When the server is listening and accepting connections, the port on which it is&#10; listening is emitted on the &lt;code&gt;listening&lt;/code&gt; output port.&lt;/p&gt;&#10;&lt;p&gt; When a connection is established, this accessor outputs on the &lt;code&gt;connection&lt;/code&gt; output&#10; an object with the following fields:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;id&lt;/strong&gt;: A unique ID identifying the connection (a positive integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remoteHost&lt;/strong&gt;: The IP address of the remote host for the socket (a string).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remotePort&lt;/strong&gt;: The port of the remote host for the socket (an integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt;: The string 'open'.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; When the connection is closed, the same object as above is produced on the&#10; &lt;code&gt;connection&lt;/code&gt; output, except with status being 'closed'.&lt;/p&gt;&#10;&lt;p&gt; When data is received from the connection, two outputs are produced.&#10; The data itself is produced on the &lt;code&gt;received&lt;/code&gt; output.  The ID of the connection&#10; over which the data arrived is produced on the &lt;code&gt;receivedID&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; To send data over a connection, provide the data on the &lt;code&gt;toSend&lt;/code&gt; input port&#10; and the ID of the connection on the &lt;code&gt;toSendID&lt;/code&gt; input port.  To send to all open&#10; connections, provide an ID of 0 (zero).&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item that arrives on&#10; &lt;code&gt;toSend&lt;/code&gt;, of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/p&gt;&#10;&lt;p&gt;The client might similarly lose messages by the same two mechanisms occurring&#10;on the client side. In that case, messages will presumably be displayed on the&#10;client side.&lt;/p&gt;&#10;&lt;p&gt;Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10;to customize what is sent. &lt;/p&gt;&#10;&lt;p&gt;This accessor requires the 'socket' module.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="toSendID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which to send the data, where 0 means&#10;   to send to all open connections.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on&#10;   (this is useful if the port is specified to be 0).">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="Output an object with the fields specified above when a&#10;    connection is established.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="receivedID (port)" class="ptolemy.kernel.util.StringAttribute" value="The ID of the connection over which data produced on the received&#10;   output was received. This is a positive integer, as indicated in the connection&#10;   output.">
            </property>
            <property name="clientAuth (parameter)" class="ptolemy.kernel.util.StringAttribute" value="One of 'none', 'request', or 'required', meaning&#10;   whether it requires that a certificate be presented.">
            </property>
            <property name="discardSendToUnopenedSocket (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any data&#10;  sent to a socket that is not open. The data will be logged using console.log()&#10;  instead. This defaults to false.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The name of the network interface to use for&#10;   listening, e.g. 'localhost'. The default is '0.0.0.0', which means to&#10;   listen on all available interfaces.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available&#10;   (the default). If false, data may be accumulated until a reasonable packet size is&#10;   formed in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option&#10;   needs to specify the fully qualified filename for the file that stores the&#10;   private key and certificate that this server will use to identify itself. This path can be&#10;   any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The default port to listen on. This defaults to 4000.&#10;   a value of 0 means to choose a random ephemeral free port.">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See below.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and this server&#10;   requests/requires a certificate from the client, then this option needs to specify&#10;   the filename for the file that stores the certificate of a certificate authority (CA) that&#10;   this server will use to verify client certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="clientAuth" class="ptolemy.data.expr.Parameter" value="required">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="asdf">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="$CLASSPATH/org/terraswarm/accessor/demo/TCPSocket/certs/Server.pfx">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[175.0, 510.0]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="41019">
        </property>
        <property name="sslTls" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="$CLASSPATH/org/terraswarm/accessor/demo/TCPSocket/certs/CACert.pem">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="toSendID" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="receivedID" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ClientB" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a TCP socket at&#10; *  the specified host and port. Upon initialization, it initiates a connection to the&#10; *  specified server. When the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *&#10; *  Whenever an input is received on the `toSend` input,&#10; *  the data on that input is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `received` output.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *&#10; *  If the connection is dropped midway, the client will attempt to reconnect if&#10; *  `reconnectOnClose` is true. This does not apply after the accessor wraps up.&#10; *&#10; *  The send and receive types can be any of those supported by the host.&#10; *  The list of supported types will be provided as options for the `sendType`&#10; *  and `receiveType` parameter. For the Ptolemy II host, these include at&#10; *  least 'string', 'number', 'image', and a variety of numeric types.&#10; *&#10; *  If both ends of the socket are known to be JavaScript clients,&#10; *  then you should use the 'number' data type for numeric data.&#10; *  If one end or the other is not JavaScript, then&#10; *  you can use more specified types such as 'float' or 'int', if they&#10; *  are supported by the host. In all cases, received numeric&#10; *  data will be converted to JavaScript 'number' when emitted.&#10; *  For sent data, this will try to convert a JavaScript number&#10; *  to the specified type. The type 'number' is equivalent&#10; *  to 'double'.&#10; *&#10; *  When type conversions are needed, e.g. when you send a double&#10; *  with `sendType` set to int, or an int with `sendType` set to byte,&#10; *  then a &quot;primitive narrowing conversion&quot; will be applied, as specified here:&#10; *  https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&#10; *&#10; *  For numeric types, you can also send an array with a single call&#10; *  to send(). The elements of the array will be sent in sequence all&#10; *  at once, and may be received in one batch. If both ends have&#10; *  `rawBytes` set to false (specifying message framing), then these&#10; *  elements will be emitted at the receiving end all at once in a single&#10; *  array. Otherwise, they will be emitted one at a time.&#10; *&#10; *  For strings, you can also send an array of strings in a single call,&#10; *  but these will be simply be concatenated and received as a single string.&#10; *&#10; *  If the `rawBytes` option is set to false, then each data item provided on `toSend`,&#10; *  of any type or array of types, will be coalesced into a single message and&#10; *  the receiving end (if it also has `rawBytes` set to false) will emit the entire&#10; *  message, and only the message, exactly once.  Otherwise, a message may get&#10; *  fragmented, emitted in pieces, or coalesced with subsequent messages.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent.&#10; *&#10; *  This accessor requires the 'socket' module.&#10; *&#10; *  @accessor net/TCPSocketClient&#10; *&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *&#10; *  @parameter {string} host The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port on the server to connect to. Defaults to 4000.&#10; *&#10; *  @parameter {int} connectTimeout The time to wait (in milliseconds) before declaring&#10; *    a connection attempt to have failed. This defaults to 6000.&#10; *  @parameter {int} idleTimeout The amount of idle time in seconds that will cause&#10; *    a disconnection of a socket. This defaults to 0, which means no&#10; *    timeout.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then discard any messages&#10; *    passed to SocketClient.send() before the socket is opened. If false,&#10; *    then queue the messages to be sent when the socket opens. This&#10; *    defaults to false.&#10; *  @parameter {boolean} keepAlive Whether to keep a connection alive and reuse it. This&#10; *    defaults to true.&#10; *  @parameter {int} maxUnsentMessages The maximum number of unsent messages to queue before&#10; *    further calls to send() will fail. A value of 0 means no limit.&#10; *    This defaults to 100.&#10; *  @parameter {boolean} noDelay If true, data as sent as soon as it is available (the default).&#10; *    If false, data may be accumulated until a reasonable packet size is formed&#10; *    in order to make more efficient use of the network (using Nagle's algorithm).&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the password for the pfx key-cert&#10; *    file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true and the server requires&#10; *    client authentication, then this option needs to specify the fully qualified filename for &#10; *    the file that stores the private key and certificate that this client will use to authenticate&#10; *    itself to the server. This path can be any of those understood by the Ptolemy host, &#10; *    e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {boolean} rawBytes If true (the default), then transmit only the data bytes provided&#10; *    to send() without any header. If false, then prepend sent data with length&#10; *    information and assume receive data starts with length information.&#10; *    Setting this false on both ends will ensure that each data item passed to&#10; *    send() is emitted once in its entirety at the receiving end, as a single&#10; *    message. When this is false, the receiving end can emit a partially received&#10; *    message or could concatenate two messages and emit them together.&#10; *  @parameter {int} receiveBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} receiveType See above.&#10; *  @parameter {int} reconnectAttempts The number of times to try to reconnect.&#10; *    If this is greater than 0, then a failure to attempt will trigger&#10; *    additional attempts. This defaults to 10.&#10; *  @parameter {int} reconnectInterval The time between reconnect attempts, in&#10; *    milliseconds. This defaults to 1000 (1 second).&#10; *  @parameter {boolean} reconnectOnClose If true, then if the connection is closed&#10; *    before this accessor is wrapped up, then attempt to reconnect.&#10; *  @parameter {int} sendBufferSize The size of the receive buffer. Defaults to&#10; *    65536.&#10; *  @parameter {string} sendType See above.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @parameter {boolean} trustAll Whether to trust servers. This defaults to false.&#10; *    Setting it to true means that if sslTls is set to true, then&#10; *    any certificate provided by the server will be trusted.&#10; *    FIXME: Need to provide a trusted list if this is false.&#10; *  @parameter {string} trustedCACertPath If sslTls is set to true and trustAll is&#10; *    set to false, then this option needs to specify the fully qualified filename&#10; *    for the file that stores the certificate of a certificate authority (CA) that&#10; *    this client will use to verify server certificates. This path can be any of those&#10; *    understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *    FIXME: Need to be a list of paths for certificates rather than a single path.&#10; *&#10; *  @author Edward A. Lee, Hokeun Kim&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, send, require*/&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var socket = require('socket');&#10;var client = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    input('toSend');&#10;    output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    output('received');&#10;&#10;    // The most used parameters are listed first.&#10;    parameter('host', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    parameter('port', {&#10;        type : 'int',&#10;        value : 4000&#10;    });&#10;    &#10;    // The remaining parameters are in alphabetical order.&#10;    parameter('connectTimeout', {&#10;        value: 6000,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('idleTimeout', {&#10;        value: 0,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('keepAlive', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('maxUnsentMessages', {&#10;        value: 100,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('noDelay', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('pfxKeyCertPassword', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('pfxKeyCertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    parameter('rawBytes', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('receiveBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('reconnectAttempts', {&#10;        type : 'int',&#10;        value : 10&#10;    });&#10;    parameter('reconnectInterval', {&#10;        type : 'int',&#10;        value : 1000&#10;    });&#10;    parameter('reconnectOnClose', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    parameter('sendBufferSize', {&#10;        value: 65536,&#10;        type: &quot;int&quot;&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'string',&#10;    });&#10;    parameter('sslTls', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustAll', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    parameter('trustedCACertPath', {&#10;        type : 'string',&#10;        value : ''&#10;    });&#10;    &#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        parameter('receiveType', {&#10;            options : socket.supportedReceiveTypes()&#10;        });&#10;        parameter('sendType', {&#10;            options : socket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;/** Handle input on 'toSend' by sending the specified data to the server. */&#10;exports.toSendInputHandler = function () {&#10;    client.send(get('toSend'));&#10;};&#10;&#10;/** Initiate a connection to the server using the current parameter values,&#10; *  set up handlers for for establishment of the connection, incoming data,&#10; *  errors, and closing from the server, and set up a handler for inputs&#10; *  on the toSend() input port.&#10; */&#10;exports.initialize = function () {&#10;&#10;    client = new socket.SocketClient(getParameter('port'), getParameter('host'),&#10;        {&#10;            'connectTimeout' : getParameter('connectTimeout'),&#10;            'discardMessagesBeforeOpen' : getParameter('discardMessagesBeforeOpen'),&#10;            'idleTimeout' : getParameter('idleTimeout'),&#10;            'keepAlive' : getParameter('keepAlive'),&#10;            'maxUnsentMessages' : getParameter('maxUnsentMessages'),&#10;            'noDelay' : getParameter('noDelay'),&#10;            'pfxKeyCertPassword' : getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath' : getParameter('pfxKeyCertPath'),&#10;            'rawBytes' : getParameter('rawBytes'),&#10;            'receiveBufferSize' : getParameter('receiveBufferSize'),&#10;            'receiveType' : getParameter('receiveType'),&#10;            'reconnectAttempts' : getParameter('reconnectAttempts'),&#10;            'reconnectInterval' : getParameter('reconnectInterval'),&#10;            'sendBufferSize' : getParameter('sendBufferSize'),&#10;            'sendType' : getParameter('sendType'),&#10;            'sslTls' : getParameter('sslTls'),&#10;            'trustAll' : getParameter('trustAll'),&#10;            'trustedCACertPath' : getParameter('trustedCACertPath')&#10;        }&#10;    );&#10;&#10;    client.on('open', function() {&#10;        console.log('Status: Connection established');&#10;        send('connected', true);&#10;    });&#10;    client.on('data', function(data) {&#10;        send('received', data);&#10;    });&#10;&#10;    // Record the object that calls it (could be a derived accessor).&#10;    var callObj = this;&#10;&#10;    // Bind onClose() to caller's object, so that 'this' is defined&#10;    // in onClose() to be the object on which this initialize() function&#10;    // is called.&#10;    client.on('close', onClose.bind(callObj));&#10;    client.on('error', function (message) {&#10;        error(message);&#10;    });&#10;    this.addInputHandler('toSend', exports.toSendInputHandler.bind(callObj));&#10;};&#10;&#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;    console.log('Status: Connection closed: ' + message);&#10;    if (client) {&#10;        // wrapup() has not been called.&#10;        // Probably the server closed the connection.&#10;        send('connected', false);&#10;&#10;        // Close and unregister everything.&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client = null;&#10;&#10;        // Reconnect if reconnectOnClose is true.&#10;        if (getParameter('reconnectOnClose')) {&#10;            // Use 'this' rather than 'export' so initialize() can be overridden.&#10;            this.initialize();&#10;        }&#10;    }&#10;}&#10;&#10;/** Return true if this client has an open connection to the server. */&#10;exports.isOpen = function () {&#10;    return client.isOpen();&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (client) {&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        client = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/TCPSocketClient.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a TCP socket at&#10; the specified host and port. Upon initialization, it initiates a connection to the&#10; specified server. When the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt; input,&#10; the data on that input is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when the socket opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;received&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; connection.&lt;/p&gt;&#10;&lt;p&gt; If the connection is dropped midway, the client will attempt to reconnect if&#10; &lt;code&gt;reconnectOnClose&lt;/code&gt; is true. This does not apply after the accessor wraps up.&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least 'string', 'number', 'image', and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the 'number' data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as 'float' or 'int', if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript 'number' when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type 'number' is equivalent&#10; to 'double'.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item provided on &lt;code&gt;toSend&lt;/code&gt;,&#10; of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the 'socket' module.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="host (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to 4000.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time to wait (in milliseconds) before declaring&#10;   a connection attempt to have failed. This defaults to 6000.">
            </property>
            <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then discard any messages&#10;   passed to SocketClient.send() before the socket is opened. If false,&#10;   then queue the messages to be sent when the socket opens. This&#10;   defaults to false.">
            </property>
            <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
            </property>
            <property name="maxUnsentMessages (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The maximum number of unsent messages to queue before&#10;   further calls to send() will fail. A value of 0 means no limit.&#10;   This defaults to 100.">
            </property>
            <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, data as sent as soon as it is available (the default).&#10;   If false, data may be accumulated until a reasonable packet size is formed&#10;   in order to make more efficient use of the network (using Nagle's algorithm).">
            </property>
            <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true (the default), then transmit only the data bytes provided&#10;   to send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
            </property>
            <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="reconnectAttempts (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The number of times to try to reconnect.&#10;   If this is greater than 0, then a failure to attempt will trigger&#10;   additional attempts. This defaults to 10.">
            </property>
            <property name="reconnectInterval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time between reconnect attempts, in&#10;   milliseconds. This defaults to 1000 (1 second).">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then if the connection is closed&#10;   before this accessor is wrapped up, then attempt to reconnect.">
            </property>
            <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The size of the receive buffer. Defaults to&#10;   65536.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="See above.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
            <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether to trust servers. This defaults to false.&#10;   Setting it to true means that if sslTls is set to true, then&#10;   any certificate provided by the server will be trusted.&#10;   FIXME: Need to provide a trusted list if this is false.">
            </property>
            <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and trustAll is&#10;   set to false, then this option needs to specify the fully qualified filename&#10;   for the file that stores the certificate of a certificate authority (CA) that&#10;   this client will use to verify server certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the password for the pfx key-cert&#10;   file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the fully qualified filename for &#10;   the file that stores the private key and certificate that this client will use to authenticate&#10;   itself to the server. This path can be any of those understood by the Ptolemy host, &#10;   e.g. paths beginning with $CLASSPATH/.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="host" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="string">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="trustedCACertPath" class="ptolemy.data.expr.Parameter" value="$CLASSPATH/org/terraswarm/accessor/demo/TCPSocket/certs/CACert.pem">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{400.0, 420.0}">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="41019">
        </property>
        <property name="sslTls" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="asdf">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="$CLASSPATH/org/terraswarm/accessor/demo/TCPSocket/certs/Client.pfx">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Sequence2" class="ptolemy.actor.lib.Sequence">
        <property name="values" class="ptolemy.data.expr.Parameter" value="{'This great wonderful awesome','server','requires','a client certificate'}">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[270.0, 420.0]">
        </property>
    </entity>
    <entity name="ClientConnected2" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={322, 692, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[555.0, 410.0]">
        </property>
    </entity>
    <entity name="ServerReceived2" class="ptolemy.actor.lib.gui.TimedDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={45, 692, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[359.58740234375, 520.096435546875]">
        </property>
    </entity>
    <entity name="DiscreteClock2" class="ptolemy.actor.lib.Clock">
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="1.0">
        </property>
        <property name="offsets" class="ptolemy.data.expr.Parameter" value="{0.0}">
        </property>
        <property name="values" class="ptolemy.data.expr.Parameter" value="{true}">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[170.0, 420.0]">
        </property>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="ClientA.toSend" relation="relation4"/>
    <link port="ClientA.connected" relation="relation2"/>
    <link port="ServerA.received" relation="relation"/>
    <link port="ServerReceived.input" relation="relation"/>
    <link port="ClientConnected.input" relation="relation2"/>
    <link port="DiscreteClock.output" relation="relation3"/>
    <link port="Sequence.enable" relation="relation3"/>
    <link port="Sequence.output" relation="relation4"/>
    <link port="ServerB.received" relation="relation6"/>
    <link port="ClientB.toSend" relation="relation7"/>
    <link port="ClientB.connected" relation="relation5"/>
    <link port="Sequence2.enable" relation="relation8"/>
    <link port="Sequence2.output" relation="relation7"/>
    <link port="ClientConnected2.input" relation="relation5"/>
    <link port="ServerReceived2.input" relation="relation6"/>
    <link port="DiscreteClock2.output" relation="relation8"/>
</entity>
