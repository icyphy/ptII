<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="WebSocketImageReversed" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="100.0">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{75.0, 50.0}">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={7, 23, 934, 634}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.1060461854430697">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{333.078125, 254.5408344655797}">
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="true">
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="bold" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This model starts a server that sends images to clients&#10;10 times per second.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[140.0, 30.0]">
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Note that the images sent here&#10;exceed the default frame size of&#10;65536 bytes, but this is no problem.&#10;They are automatically chunked&#10;into messages.">
        </property>
        <property name="_location" class="ptolemy.vergil.basic.RelativeLocation" value="[-130.0, 70.0]">
            <property name="relativeTo" class="ptolemy.kernel.util.StringAttribute" value="WebSocketClient">
            </property>
            <property name="relativeToElementName" class="ptolemy.kernel.util.StringAttribute" value="entity">
            </property>
        </property>
    </property>
    <entity name="Ramp" class="ptolemy.actor.lib.Ramp">
        <doc>Create a sequence of tokens with increasing value</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[205.0, 325.0]">
        </property>
    </entity>
    <entity name="Display" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={780, 23, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Server Status">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[465.0, 180.0]">
        </property>
    </entity>
    <entity name="Display2" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={782, 441, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Client Status">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[520.0, 315.0]">
        </property>
    </entity>
    <entity name="Display3" class="ptolemy.actor.lib.gui.Display">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={782, 651, 499, 208}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[499, 164]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Client Received">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[465.0, 105.0]">
        </property>
    </entity>
    <entity name="MicrostepDelay" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[105.0, 375.0]">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="DiscreteClock" class="ptolemy.actor.lib.DiscreteClock">
        <property name="period" class="ptolemy.actor.parameters.PortParameter" value="0.1">
        </property>
        <property name="values" class="ptolemy.data.expr.Parameter" value="{true}">
        </property>
        <doc>Create periodic timed events.</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[75.0, 155.0]">
        </property>
    </entity>
    <entity name="Camera" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** An accessor for a camera on the local host. This can be a built-in camera or&#10; *  a USB-connected camera. This accessor has two modes of operation, &quot;triggered&quot;&#10; *  and &quot;open loop.&quot; In triggered mode, it captures an image whenever a trigger&#10; *  input is received and produces that image on its output. In open-loop mode,&#10; *  it captures every image produced by the camera, at the speed of the camera,&#10; *  and produces on the output a stream of such images.&#10; * &#10; *  @accessor cameras/Camera&#10; *  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *  @input trigger A trigger input for triggered mode.&#10; *   The value is ignored and can be anything.&#10; *  @output {Object} image A stream of captured images.&#10; *  @parameter {boolean} triggered If true, use triggered mode.&#10; *   Otherwise, use open-loop mode. This is a boolean that defaults to true.&#10; *  @parameter {string} camera The name of the camera to use.&#10; *   A list of available cameras is presented as options.&#10; *   This is a string that defaults to &quot;default camera&quot;,&#10; *   which uses the system default, if there is one.&#10; *  @parameter {{width: number, height: number}} viewSize The view size&#10; *   to use for capture, in pixels. A list of available view sizes for&#10; *   the selected camara is presented as options. This is a JSON specification&#10; *   with a &quot;width&quot; and &quot;height&quot; field, as in for example {&quot;width&quot;:640, &quot;height&quot;:480}.&#10; *  @version $$Id$$ &#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should be no&#10;// space between the / and the * and global. See https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*global addInputHandler, exports, getParameter, input, output, parameter, removeInputHandler, require, send */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var cameras = require(&quot;cameras&quot;);&#10;var camera;&#10;var handle = null;&#10;&#10;/** Create the inputs, outputs, and parameters, and update the parameters for the selected camera. */&#10;exports.setup = function () {&#10;    this.input('trigger');&#10;    this.output('image');&#10;    this.parameter('triggered', {&#10;        'type' : 'boolean',&#10;        'value' : true&#10;    });&#10;    // NOTE: The following assumes that setup() is reinvoked whenever a parameter&#10;    // value changes, since the camera will change and so will the available options.&#10;    this.parameter('camera', {&#10;        'type' : 'string',&#10;        'value' : 'default camera',&#10;    });&#10;    this.parameter('viewSize', {&#10;        'type' : 'JSON',&#10;    });&#10;    // This is in a try-catch so that this accessor can be instantiated even if the&#10;    // host does not provide a cameras module.&#10;    try {&#10;        this.parameter('camera', {&#10;            'options' : cameras.cameras()&#10;        });&#10;        camera = new cameras.Camera(getParameter('camera'));&#10;        this.parameter('viewSize', {&#10;            'value' : camera.getViewSize(),&#10;            'options' : camera.viewSizes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;/** Set the view size of the camera, open it, and depending on the triggered mode, either&#10; *  set up an input handler for the trigger input or set up a handler for the 'image'&#10; *  event notification from the camera.&#10; */&#10;exports.initialize = function () {&#10;    camera.setViewSize(getParameter('viewSize'));&#10;    camera.open();&#10;    var self = this;&#10;    if (getParameter('triggered')) {&#10;        handle = this.addInputHandler('trigger', function () {&#10;            self.send('image', camera.snapshot());&#10;        });&#10;    } else {&#10;        camera.on('image', function (image) {&#10;            self.send('image', image);&#10;        });&#10;    }&#10;};&#10;&#10;/** Remove handlers and close the camera. */&#10;exports.wrapup = function () {&#10;    camera.removeAllListeners('image');&#10;    if (handle !== null) {&#10;        this.removeInputHandler(handle);&#10;    }&#10;    camera.close();&#10;};&#10;">
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://www.terraswarm.org/accessors/cameras/Camera.js">
        </property>
        <property name="triggered" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="camera" class="ptolemy.data.expr.StringParameter" value="default camera">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="viewSize" class="ptolemy.data.expr.StringParameter" value="{&quot;width&quot;:640, &quot;height&quot;:480}">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[175.0, 155.0]">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;An accessor for a camera on the local host. This can be a built-in camera or&#10; a USB-connected camera. This accessor has two modes of operation, &amp;quot;triggered&amp;quot;&#10; and &amp;quot;open loop.&amp;quot; In triggered mode, it captures an image whenever a trigger&#10; input is received and produces that image on its output. In open-loop mode,&#10; it captures every image produced by the camera, at the speed of the camera,&#10; and produces on the output a stream of such images.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="triggered (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, use triggered mode.&#10;  Otherwise, use open-loop mode. This is a boolean that defaults to true.">
            </property>
            <property name="camera (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The name of the camera to use.&#10;  A list of available cameras is presented as options.&#10;  This is a string that defaults to &quot;default camera&quot;,&#10;  which uses the system default, if there is one.">
            </property>
            <property name="viewSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The view size&#10;  to use for capture, in pixels. A list of available view sizes for&#10;  the selected camara is presented as options. This is a JSON specification&#10;  with a &quot;width&quot; and &quot;height&quot; field, as in for example {&quot;width&quot;:640, &quot;height&quot;:480}.">
            </property>
            <property name="trigger (port)" class="ptolemy.kernel.util.StringAttribute" value="A trigger input for triggered mode.&#10;  The value is ignored and can be anything.">
            </property>
            <property name="image (port)" class="ptolemy.kernel.util.StringAttribute" value="A stream of captured images.">
            </property>
        </property>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="image" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ImageDisplay" class="ptolemy.actor.lib.image.ImageDisplay">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={8, 23, 640, 524}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="_pictureSize" class="ptolemy.actor.gui.SizeAttribute" value="[640, 480]">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[515.0, 375.0]">
        </property>
    </entity>
    <entity name="WebSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  The output `connection` reports the when a&#10; *  connection is opened or closed.&#10; *&#10; *  When a message arrives on a connection, a `received`&#10; *  output is produced with that message. Note that the message may arrive in&#10; *  multiple frames, but it will be produced as a single message.&#10; *&#10; *  When an input arrives on `toSend`, then a message is&#10; *  sent to one or all of the open socket connections.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  server and all connections.&#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The this.send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to this.send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  This accessor requires the module webSocket.&#10; *&#10; *  @accessor net/WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen to for connections.&#10; *  @parameter {string} receiveType The MIME type for incoming messages, &#10; *    which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages,&#10; *    which defaults to 'application/json'.&#10; *  @input toSend The data to be sent to open sockets. &#10; *    If this is an object with 'socketID' field and a 'message' field,&#10; *    then send the value of the message field to the socket identified&#10; *    by the socketID field. If the input has any other form, then the&#10; *    message is broadcast to all open socket connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *  @output connection An output produced when a connection opens or closes.&#10; *    The output is an object with two fields, a 'socketID',&#10; *    which is a unique ID for this client connection, and a 'status' field,&#10; *    which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals addInputHandler, console, get, getParameter, error, exports, input, output, removeInputHandler, require, parameter, send */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    this.parameter('hostInterface', {&#10;        value: &quot;localhost&quot;,&#10;        type: &quot;string&quot;&#10;    });&#10;    this.parameter('port', {&#10;        value: 8080,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'application/json',&#10;    });&#10;    this.parameter('sendType', {&#10;        type : 'string',&#10;        value : 'application/json',&#10;    });&#10;    this.input('toSend');&#10;    this.output('received');&#10;    this.output('listening', {'type':'int'});&#10;    this.output('connection');&#10;    &#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options : WebSocket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options : WebSocket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs.&#10;  * Adds an input handler on toSend that sends the input received to the right socket. */&#10;exports.initialize = function() {&#10;    var self = this;&#10;    if (!server) {&#10;        server = new WebSocket.Server({&#10;                'port': this.getParameter('port'),&#10;                'hostInterface': this.getParameter('hostInterface'),&#10;                'receiveType': this.getParameter('receiveType'),&#10;                'sendType': this.getParameter('sendType')&#10;        });&#10;        server.on('listening', onListening.bind(this));&#10;        server.on('connection', onConnection.bind(this));&#10;        server.on('error', function (message) {&#10;            self.error(message);&#10;        });&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = this.addInputHandler('toSend', function() {&#10;        var data = self.get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;&#10;            // JSHint WARNING: Do not change dataSocketID != null to&#10;            // data.socketID !== null because it will cause&#10;            // org/terraswarm/accessor/test/auto/WebSocketClient.xml&#10;            // to fail upon reloading.  See&#10;            // org/terraswarm/accessor/test/WebSocketClientTest.tcl&#10;            if ((data.socketID != null)  &amp;&amp; (data.message !== null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    /*&#10;                    console.log(&quot;Sending to socket id &quot; +&#10;                                data.socketID +&#10;                                &quot; message: &quot; +&#10;                                data.message);&#10;                    */&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID +&#10;                                ' is not open. Discarding message.');&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                // var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        // console.log(&quot;Broadcasting to socket id &quot; + id&#10;                        //         + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        // success = true;&#10;                    }&#10;                }&#10;                // if (!success) {&#10;                //     console.log('No open sockets. Discarding message: ' + data.message);&#10;                // }&#10;            }&#10;        }&#10;    });&#10;};&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;    this.send('listening', this.getParameter('port'));&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;    var self = this;&#10;    //socketID is the index of the socket in the sockets array.&#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    this.send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        self.send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        self.send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;    socket.on('error', function(message) {&#10;        self.error(message);&#10;    });&#10;&#10;    sockets.push(socket);&#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server.&#10; */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    this.removeInputHandler(handle);&#10;&#10;    if (server !== null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor starts a server that listens for web socket&#10; connection requests on the specified hostInterface and port.  The&#10; hostInterface is needed only if the host machine has more than one&#10; network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; not resolve to the desired interface.&lt;/p&gt;&#10;&lt;p&gt; The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; connection is opened or closed.&lt;/p&gt;&#10;&lt;p&gt; When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; output is produced with that message. Note that the message may arrive in&#10; multiple frames, but it will be produced as a single message.&lt;/p&gt;&#10;&lt;p&gt; When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; sent to one or all of the open socket connections.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; server and all connections.&lt;/p&gt;&#10;&lt;p&gt; The default type for both sending and receiving&#10; is 'application/json', which allows sending and receiving anything that has&#10; a string representation in JSON. The types supported by this implementation&#10; include at least:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;application/json&lt;/strong&gt;: The send() function uses JSON.stringify() and sends the&#10;result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10;and if the parsing fails, will be provided as a string interpretation of the byte&#10;stream.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;text/*&lt;/strong&gt;: Any text type is sent as a string encoded in UTF-8.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;image/x&lt;/strong&gt;: Where &lt;strong&gt;x&lt;/strong&gt; is one of &lt;strong&gt;json&lt;/strong&gt;, &lt;strong&gt;png&lt;/strong&gt;, &lt;strong&gt;gif&lt;/strong&gt;,&#10;and more.&#10;In this case, the data passed to send() is assumed to be an image, as encoded&#10;on the host, and the image will be encoded as a byte stream in the specified&#10;format before sending.  A received byte stream will be decoded as an image,&#10;if possible.&lt;/p&gt;&#10;&lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Edward Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent to open sockets. &#10;   If this is an object with 'socketID' field and a 'message' field,&#10;   then send the value of the message field to the socket identified&#10;   by the socketID field. If the input has any other form, then the&#10;   message is broadcast to all open socket connections.">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="An output produced when a connection opens or closes.&#10;   The output is an object with two fields, a 'socketID',&#10;   which is a unique ID for this client connection, and a 'status' field,&#10;   which is the string 'open' or 'closed'.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of the&#10;   network interface to listen to.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to listen to for connections.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for incoming messages, &#10;   which defaults to 'application/json'.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for outgoing messages,&#10;   which defaults to 'application/json'.">
            </property>
            <property name="maxFrameSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The maximum frame size for a received message (default is 65536).">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="image/jpeg">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{290.0, 155.0}">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="WebSocketClient" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor sends and/or receives messages from a web socket at&#10; *  the specified host and port. In `initialize()`, it&#10; *  begins connecting to the web socket server.&#10; *  Once the connection is established, a `true` boolean is sent to&#10; *  the `connected` output.&#10; *  If connection is not established immediately, the accessor will attempt to&#10; *  reconnect (numberOfRetries) times at an interval of (reconnectInterval)&#10; *&#10; *  Whenever an input is received on the `toSend`&#10; *  input, the message is sent to the socket. If the socket is not yet open,&#10; *  this accessor will, by default, queue the message to send when the socket opens,&#10; *  unless the `discardMessagesBeforeOpen` parameter is true, in which case,&#10; *  input messages that are received before the socket is opened will be&#10; *  discarded. If messages are queued and `throttleFactor` is non-zero, then&#10; *  whenever a message is queued to be later sent, the accessor's input handler will stall&#10; *  by a number of milliseconds given by the queue size times the throttleFactor.&#10; *  The longer the queue, the longer the stall. Note that this will likely block&#10; *  the host from executing, so this feature should be used with caution.&#10; *&#10; *  Whenever a message is received from the socket, that message is&#10; *  produced on the `'received'` output. Note that the message may actually be sent&#10; *  over multiple 'frames', but the frames will be aggregated and produced as one&#10; *  message.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  connection.&#10; *&#10; *  If the connection is dropped midway, the client will attempt to reconnect if&#10; *  (reconnectOnClose) is true. This does not apply when the accessor wraps up.&#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The this.send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to this.send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  When a model with an instance of this accessor stops executing, there&#10; *  are two mechanisms by which data in transit can be lost. In both cases, warning&#10; *  messages or error messages will be issued to the host to be displayed or otherwise&#10; *  handled as the host sees fit.&#10; *&#10; *  * First, there might be queued messages that were received on `toSend` but have not yet&#10; *    been sent, either because the socket has not yet been opened or because&#10; *    it was closed from the other side.&#10; *  * Second, a message might be received from the server after shutdown has commenced.&#10; *    In particular, received messages are handled asynchronously by a handler function&#10; *    that can be invoked at any time, and that handler might be invoked after it is no&#10; *    longer possible for this accessor to produce outputs (it has entered its wrapup&#10; *    phase of execution).&#10; *&#10; *  The server might similarly lose messages by the same two mechanisms occurring&#10; *  on the server side. In that case, messages will presumably be displayed on the&#10; *  server side.&#10; *&#10; *  Accessors that extend this one can override the `toSendInputHandler` function&#10; *  to customize what is sent. See `RosPublisher.js` for an example.&#10; *&#10; *  This accessor requires the 'webSocket' module.&#10; *&#10; *  @accessor net/WebSocketClient&#10; *  @parameter {string} server The IP address or domain name of server. Defaults to 'localhost'.&#10; *  @parameter {int} port The port on the server to connect to. Defaults to 8080.&#10; *  @parameter {string} receiveType The MIME type for incoming messages, which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages, which defaults to 'application/json'.&#10; *  @parameter {int} connectTimeout The time in milliseconds to wait before giving up on a connection (default is 60000).&#10; *  @parameter {int} numberOfRetries The number of times to retry if a connection fails. Defaults to 5.&#10; *  @parameter {int} timeBetweenRetries The time between retries in milliseconds. Defaults to 100.&#10; *  @parameter {boolean} reconnectOnClose The option of whether or not to reconnect when disconnected.&#10; *  @parameter {boolean} discardMessagesBeforeOpen If true, then any messages received on `toSend` before the socket is open will be discarded. This defaults to false.&#10; *  @parameter {int} throttleFactor If non-zero, specifies a time (in milliseconds) to stall when a message is queued because the socket is not yet open. The time of the stall will be the queue size (after adding the message) times the throttleFactor. This defaults to 100. Making it non-zero causes the input handler to take time if there are pending unsent messages.&#10; *  @input toSend The data to be sent over the socket.&#10; *  @output {boolean} connected Output `true` on connected and `false` on disconnected.&#10; *  @output received The data received from the web socket server.&#10; *  @author Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*global addInputHandler, console, error, exports, get, getParameter, input, onClose, output, parameter, removeInputHandler, require, send */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;&#10;var WebSocket = require('webSocket');&#10;var client = null;&#10;var inputHandle = null;&#10;&#10;/** Set up the accessor by defining the parameters, inputs, and outputs. */&#10;exports.setup = function () {&#10;    this.parameter('server', {&#10;        type : 'string',&#10;        value : 'localhost'&#10;    });&#10;    this.parameter('port', {&#10;        type : 'int',&#10;        value : 8080&#10;    });&#10;    this.parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'application/json',&#10;    });&#10;    this.parameter('sendType', {&#10;        type : 'string',&#10;        value : 'application/json',&#10;    });&#10;    this.parameter('connectTimeout', {&#10;        value: 60000,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('numberOfRetries', {&#10;        type : 'int',&#10;        value : 5&#10;    });&#10;    this.parameter('timeBetweenRetries', {&#10;        type : 'int',&#10;        value : 100&#10;    });&#10;    this.parameter('reconnectOnClose', {&#10;        type : 'boolean',&#10;        value : true&#10;    });&#10;    this.parameter('discardMessagesBeforeOpen', {&#10;        type : 'boolean',&#10;        value : false&#10;    });&#10;    this.parameter('throttleFactor', {&#10;        type : 'int',&#10;        value : 100&#10;    });&#10;    this.input('toSend');&#10;    this.output('connected', {&#10;        type : 'boolean'&#10;    });&#10;    this.output('received');&#10;    &#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options : WebSocket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options : WebSocket.supportedSendTypes()&#10;        });&#10;    } catch(err) {&#10;        this.error(err);&#10;    }&#10;};&#10;&#10;/** Initializes accessor by attaching functions to inputs. */&#10;exports.initialize = function () {&#10;&#10;    client = new WebSocket.Client(&#10;        {&#10;            'host' : this.getParameter('server'),&#10;            'port' : this.getParameter('port'),&#10;            'receiveType' : this.getParameter('receiveType'),&#10;            'sendType' : this.getParameter('sendType'),&#10;            'connectTimeout' : this.getParameter('connectTimeout'),&#10;            'numberOfRetries' : this.getParameter('numberOfRetries'),&#10;            'timeBetweenRetries' : this.getParameter('timeBetweenRetries'),&#10;            'discardMessagesBeforeOpen' : this.getParameter('discardMessagesBeforeOpen'),&#10;            'throttleFactor' : this.getParameter('throttleFactor')&#10;        }&#10;    );&#10;&#10;    client.on('open', exports.onOpen.bind(this));&#10;    client.on('message', exports.onMessage.bind(this));&#10;    client.on('close', onClose.bind(this));&#10;&#10;    client.on('error', function (message) {&#10;        console.log(message);&#10;    });&#10;    //only execute once, and not when trying to reconnect.&#10;    if (inputHandle === null) {&#10;        inputHandle = this.addInputHandler('toSend', exports.toSendInputHandler.bind(this));&#10;    }&#10;};&#10;&#10;/** Handles input on 'toSend'. */&#10;exports.toSendInputHandler = function () {&#10;    exports.sendToWebSocket(this.get('toSend'));&#10;};&#10;&#10;/** Sends JSON data to the web socket. */&#10;exports.sendToWebSocket = function (data) {&#10;    if (client !== null) {&#10;        client.send(data);&#10;        // console.log(&quot;Sending to web socket: &quot; + data);&#10;    } else {&#10;        console.log(&quot;Client is null. Could not send message: &quot; + data);&#10;    }&#10;};&#10;&#10;/** Executes once  web socket establishes a connection.&#10; *  Sets 'connected' output to true.&#10; */&#10;exports.onOpen = function () {&#10;    console.log('Status: Connection established');&#10;    this.send('connected', true);&#10;};&#10;&#10;/** Send false to 'connected' output, and if 'reconnectOnClose'&#10; *  parameter evaluates to true and wrapup() has not been called,&#10; *  then invoke initialize().&#10; *  This will be called if either side closes the connection.&#10; *  @param message Possible message about the closure.&#10; */&#10;function onClose(message) {&#10;    console.log('Status: Connection closed: ' + message);&#10;    if (inputHandle) {&#10;        // wrapup() has not been called.&#10;        // Probably the server closed the connection.&#10;        this.send('connected', false);&#10;        &#10;        // Close and unregister everything.&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client = null;&#10;&#10;        // Reconnect if reconnectOnClose is true.&#10;        if (getParameter('reconnectOnClose')) {&#10;            // Use 'this' rather than 'export' so initialize() can be overridden.&#10;            this.initialize();&#10;        }&#10;    }&#10;}&#10;&#10;/** Send the message received from web socket to the 'received' output. */&#10;exports.onMessage = function (message) {&#10;    this.send('received', message);&#10;};&#10;&#10;/** Export the isOpen() function */&#10;exports.isOpen = function () {&#10;    return client.isOpen();&#10;};&#10;&#10;/** Close the web socket connection. */&#10;exports.wrapup = function () {&#10;    if (inputHandle !== null) {&#10;        this.removeInputHandler(inputHandle);&#10;        inputHandle = null;&#10;    }&#10;    if (client) {&#10;        client.removeAllListeners('open');&#10;        client.removeAllListeners('message');&#10;        client.removeAllListeners('close');&#10;        client.close();&#10;        console.log('Status: Connection closed in wrapup.');&#10;        client = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketClient.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a web socket at&#10; the specified host and port. In &lt;code&gt;initialize()&lt;/code&gt;, it&#10; begins connecting to the web socket server.&#10; Once the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output.&#10; If connection is not established immediately, the accessor will attempt to&#10; reconnect (numberOfRetries) times at an interval of (reconnectInterval)&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt;&#10; input, the message is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when the socket opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded. If messages are queued and &lt;code&gt;throttleFactor&lt;/code&gt; is non-zero, then&#10; whenever a message is queued to be later sent, the accessor's input handler will stall&#10; by a number of milliseconds given by the queue size times the throttleFactor.&#10; The longer the queue, the longer the stall. Note that this will likely block&#10; the host from executing, so this feature should be used with caution.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;'received'&lt;/code&gt; output. Note that the message may actually be sent&#10; over multiple 'frames', but the frames will be aggregated and produced as one&#10; message.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; connection.&lt;/p&gt;&#10;&lt;p&gt; If the connection is dropped midway, the client will attempt to reconnect if&#10; (reconnectOnClose) is true. This does not apply when the accessor wraps up.&lt;/p&gt;&#10;&lt;p&gt; The default type for both sending and receiving&#10; is 'application/json', which allows sending and receiving anything that has&#10; a string representation in JSON. The types supported by this implementation&#10; include at least:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;application/json&lt;/strong&gt;: The send() function uses JSON.stringify() and sends the&#10;result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10;and if the parsing fails, will be provided as a string interpretation of the byte&#10;stream.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;text/*&lt;/strong&gt;: Any text type is sent as a string encoded in UTF-8.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;image/x&lt;/strong&gt;: Where &lt;strong&gt;x&lt;/strong&gt; is one of &lt;strong&gt;json&lt;/strong&gt;, &lt;strong&gt;png&lt;/strong&gt;, &lt;strong&gt;gif&lt;/strong&gt;,&#10;and more.&#10;In this case, the data passed to send() is assumed to be an image, as encoded&#10;on the host, and the image will be encoded as a byte stream in the specified&#10;format before sending.  A received byte stream will be decoded as an image,&#10;if possible.&lt;/p&gt;&#10;&lt;p&gt;When a model with an instance of this accessor stops executing, there&#10;are two mechanisms by which data in transit can be lost. In both cases, warning&#10;messages or error messages will be issued to the host to be displayed or otherwise&#10;handled as the host sees fit.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/p&gt;&#10;&lt;p&gt;The server might similarly lose messages by the same two mechanisms occurring&#10;on the server side. In that case, messages will presumably be displayed on the&#10;server side.&lt;/p&gt;&#10;&lt;p&gt;Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10;to customize what is sent. See &lt;code&gt;RosPublisher.js&lt;/code&gt; for an example.&lt;/p&gt;&#10;&lt;p&gt;This accessor requires the 'webSocket' module.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent over the socket.">
            </property>
            <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" value="Output `true` on connected and `false` on disconnected.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="The data received from the web socket server.">
            </property>
            <property name="server (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of server. Defaults to 'localhost'.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port on the server to connect to. Defaults to 8080.">
            </property>
            <property name="numberOfRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The number of times to retry if a connection fails. Defaults to 5.">
            </property>
            <property name="timeBetweenRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time between retries in milliseconds. Defaults to 100.">
            </property>
            <property name="reconnectOnClose (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The option of whether or not to reconnect when disconnected.">
            </property>
            <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If true, then any messages received on `toSend` before the socket is open will be discarded. This defaults to false.">
            </property>
            <property name="throttleFactor (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If non-zero, specifies a time (in milliseconds) to stall when a message is queued because the socket is not yet open. The time of the stall will be the queue size (after adding the message) times the throttleFactor. This defaults to 100. Making it non-zero causes the input handler to take time if there are pending unsent messages.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for incoming messages, which defaults to 'application/json'.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for outgoing messages, which defaults to 'application/json'.">
            </property>
            <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The time in milliseconds to wait before giving up on a connection (default is 60000).">
            </property>
            <property name="maxFrameSize (parameter)" class="ptolemy.kernel.util.StringAttribute" value="({names:[&quot;int&quot;]}) The maximum frame size for a received message (default is 65536).">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="server" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8080">
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="image/jpeg">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="numberOfRetries" class="ptolemy.data.expr.Parameter" value="5">
        </property>
        <property name="timeBetweenRetries" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="reconnectOnClose" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="discardMessagesBeforeOpen" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="throttleFactor" class="ptolemy.data.expr.Parameter" value="100">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[355.0, 325.0]">
        </property>
        <property name="connectTimeout" class="ptolemy.data.expr.Parameter" value="60000">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="connected" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[395.0, 375.0]">
        </vertex>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="Ramp.output" relation="relation6"/>
    <link port="Ramp.trigger" relation="relation"/>
    <link port="Display.input" relation="relation5"/>
    <link port="Display2.input" relation="relation3"/>
    <link port="Display3.input" relation="relation9"/>
    <link port="MicrostepDelay.input" relation="relation7"/>
    <link port="MicrostepDelay.output" relation="relation"/>
    <link port="DiscreteClock.output" relation="relation4"/>
    <link port="Camera.trigger" relation="relation4"/>
    <link port="Camera.image" relation="relation2"/>
    <link port="ImageDisplay.input" relation="relation7"/>
    <link port="WebSocketServer.toSend" relation="relation2"/>
    <link port="WebSocketServer.received" relation="relation9"/>
    <link port="WebSocketServer.connection" relation="relation5"/>
    <link port="WebSocketClient.toSend" relation="relation6"/>
    <link port="WebSocketClient.connected" relation="relation3"/>
    <link port="WebSocketClient.received" relation="relation7"/>
</entity>
