<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="BrowserUpdate" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="10.0">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="68.0, 32.0">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={131, 207, 934, 634}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{350.0, 262.0}">
    </property>
    <property name="wsPort" class="ptolemy.data.expr.Parameter" value="8081">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[30.0, 110.0]">
        </property>
    </property>
    <property name="serverPort" class="ptolemy.data.expr.Parameter" value="8080">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{30.0, 90.0}">
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="The following ports must be different:">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[15.0, 55.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="18">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Open a web page and update it using a web socket.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[130.0, 20.0]">
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This port is used for the web server that serves the page the browser displays.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[140.0, 80.0]">
        </property>
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This port is used for the web socket that communicates with the page.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[140.0, 100.0]">
        </property>
    </property>
    <property name="Annotation5" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Produce a counting&#10;sequence, one value&#10;per second.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[15.0, 225.0]">
        </property>
    </property>
    <property name="Annotation6" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Send the counting&#10;sequence to any&#10;listener to a web&#10;socket on wsPort.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[170.0, 225.0]">
        </property>
    </property>
    <property name="Annotation7" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Once the web socket&#10;server is listening,&#10;create an HTML page&#10;to display a header&#10;followed by the&#10;messages.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[320.0, 225.0]">
        </property>
    </property>
    <property name="Annotation8" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Provide a script in&#10;head section of the&#10;page to open a web&#10;socket on wsPort and&#10;display messages.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[480.0, 225.0]">
        </property>
    </property>
    <property name="Annotation9" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Note that this pattern delays opening the&#10;web page until after the web socket server&#10;is listening for connections. If we open the&#10;web page too early, then it will fail to open&#10;the web socket.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[320.0, 330.0]">
        </property>
    </property>
    <property name="Annotation10" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.4,0.4,0.4,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Author: Edward A. Lee">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[20.0, 415.0]">
        </property>
    </property>
    <entity name="Clock" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Accessor that spontaneously produces outputs once per time interval.&#10;//&#10;// Copyright (c) 2015-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Accessor that spontaneously produces outputs once per time interval.&#10; *  This implementation produces a counting sequence.&#10; *&#10; *  @accessor test/Clock&#10; *  @parameter interval The interval between outputs in milliseconds.&#10; *  @output output Output for the counting sequence, of type number.&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals clearInterval, exports, require, setInterval */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;exports.setup = function () {&#10;    this.parameter('interval', {&#10;        'type': 'number',&#10;        'value': 1000&#10;    });&#10;    this.output('output', {&#10;        'type': 'number'&#10;    });&#10;};&#10;&#10;// These variables will not be visible to subclasses.&#10;var handle = null;&#10;var count = 0;&#10;&#10;exports.initialize = function () {&#10;    count = 0;&#10;    // Need to record 'this' for use in the callback.&#10;    var thiz = this;&#10;&#10;    // Send an output and then call setInterval&#10;    thiz.send('output', count);&#10;    count += 1;&#10;    &#10;    handle = setInterval(function () {&#10;        thiz.send('output', count);&#10;        count += 1;&#10;    }, this.getParameter('interval'));&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (handle) {&#10;        clearInterval(handle);&#10;        handle = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/Clock.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor that spontaneously produces outputs once per time interval.&#10; This implementation produces a counting sequence.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="Output for the counting sequence, of type number.">
            </property>
            <property name="interval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The interval between outputs in milliseconds.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[40.0, 175.0]">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Browser" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Accessor that connects with a browser on the local host.&#10;//&#10;// Copyright (c) 2016-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Accessor that uses a browser on the local host for interaction with a user.&#10; *  The initial content on the page may be specified using the *content*&#10; *  parameter and HTML header content may be specified using *header*.&#10; *  &#10; *  Whatever text is received on the *html* input port will replace the content&#10; *  of the web page. Normally, this will be HTML text without any DOCTYPE or&#10; *  header and without a body tag. Each time new text is received, the content&#10; *  of the page will be replaced.&#10; *  &#10; *  The page will be opened upon initialize if *content* is not empty.&#10; *  Otherwise, it will be opened when the first *html* input is received.&#10; *  &#10; *  The *resources* input can be used to provide resources, such as images,&#10; *  that will be used by the HTML content provided on the *html* input.&#10; *  Note that you probably will also have to provide an *update* input (see below)&#10; *  to force the browser to update the page using the specified resource.&#10; *  &#10; *  The *update* input can be used to instruct the browser to replace content&#10; *  within the page, vs. the *html* input which replaces the entire page.&#10; *  The value of an *update* input is expected to be an object with three properties,&#10; *  *id*, *property*, and *content*.&#10; *  &#10; *  The *id* property refers to a the ID of&#10; *  a DOM element in the content of the page, where the content has been provided&#10; *  either via the *content* parameter or the *html* input. For example, your&#10; *  page may include:&#10; *  &lt;pre&gt;&#10; *     &amp;lt;div id=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;&#10; *  &lt;/pre&gt;&#10; *  or&#10; *  &lt;pre&gt;&#10; *     &amp;lt;img id=&quot;bar&quot; src=&quot;image.jpg&quot;/&amp;gt;&#10; *  &lt;/pre&gt;&#10; *   *  @param id The ID.&#10; *  The *property* field specifies what property of the DOM element with the&#10; *  specified ID is to be updated. If *property* is &quot;html&quot;, then the&#10; *  DOM object is updated by invoking the jQuery html() function&#10; *  with the specified *content* as an argument. For example, if *id* is &quot;foo&quot;,&#10; *  *property* is &quot;html&quot;, and *content* is &quot;Hello World!&quot;, then the above div&#10; *  will be populated with the text &quot;Hello World!&quot; on the web page.&#10; *  The *content* can include any HTML markup or even scripts, which will be executed.&#10; *  &#10; *  If *property* is anything other than 'html', then the DOM element's *property*&#10; *  attribute will be assigned the value of *content*.&#10; *  A *property* value of 'src', however, is treated specially.&#10; *  A *property* value of 'src' can be used, for example, to replace the image in the above img tag.&#10; *  Just send the updated image to the *resources* input and send this to the&#10; *  *update* input:&#10; *  &lt;pre&gt;&#10; *     {'id':'bar', 'property':'src', 'content':'image.jpg'}&#10; *  &lt;/pre&gt;&#10; *  &#10; *  Note that to get the browser to actually replace the image, we have to play some tricks.&#10; *  A browser normally caches an image that it has previously retrieved&#10; *  and it will use the cached version of the image rather than obtaining the new image&#10; *  from the server.  To force the browser to refresh the image, this accessor&#10; *  treats a *property* value of 'src' specially.&#10; *  Specifically, it appends to the *content* a suffix of the form '?count=*n*',&#10; *  where *n* is a unique number. This forces the browser to retrieve the image&#10; *  from the server rather than use its cached version because the URI is&#10; *  different from that of the cached version. The server, on the other hand, ignores&#10; *  the parameter 'count' that has been appended to this URI and simply returns the&#10; *  updated image.&#10; *&#10; *  The way this accessor works on most hosts is that it starts a web server on localhost&#10; *  at the specified port that serves the specified web page and then instructs&#10; *  the system default browser to load the default page from that server.&#10; *  The page served by the server includes a script that listens for websocket&#10; *  connections that are used to provide HTML content and udpates to display on the page.&#10; *  Some hosts, however, such as the cordova and browser hosts, natively use&#10; *  a browser as part of the host, so in these cases, no web server nor socket&#10; *  connection is needed and the *port* parameter will be ignored.&#10; *  &#10; *  @accessor utilities/Browser&#10; *  @input {string} html HTML content to render in the body of the page displayed&#10; *   by the browser.&#10; *  @input resources An object where each named property is an object containing&#10; *   two properties, 'data' and 'contentType'. The name of the named property is&#10; *   the path to be used to access the resource. The 'data' property is the resource&#10; *   itself, an arbitrary collection of bytes. The 'contentType' is the MIME&#10; *   type of the data.&#10; *  @input update An object with three properties, 'id', 'property', and 'content',&#10; *   that specifies an update to a DOM element on the page.&#10; *  @parameter {string} header HTML content to include in the header part of the web page.&#10; *   This is a good place to script definitions.&#10; *  @parameter {string} content HTML content to include in the main body of the page.&#10; *   If this is non-empty, then the page is opened upon initialize.&#10; *   Otherwise, the page is opened when the first *html* input is received.&#10; *  @parameter {int} port The port to use, if needed, for websocket communication between this&#10; *   accessor (which updates the HTML content of the web page) and the browser.&#10; *   The web page will listen on this socket for content and display whatever arrives&#10; *   on that port. This is ignored on hosts that do not need to invoke an external browser.&#10; *  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should be no&#10;// space between the / and the * and global. See https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*global  exports, require */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var Browser = require('browser');&#10;var browser = null;&#10;&#10;exports.setup = function () {&#10;    this.parameter('header', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    this.parameter('content', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    this.input('html', {&#10;        'type': 'string'&#10;    });&#10;    this.input('resources');&#10;    this.input('update');&#10;    this.output('post', {&#10;        'type': 'JSON'&#10;    });&#10;    this.parameter('port', {&#10;        'type': 'int',&#10;        'value': 8080&#10;    });&#10;};&#10;&#10;/** Display the HTML contents retrieved from the *html* input in the main body&#10; *  of the browser page replacing whatever was there before.&#10; *  Before doing this, check for any *resources* input and add those resources&#10; *  to the browser in case the HTML references them. &#10; */&#10;function display() {&#10;    // Check for any new resources.&#10;    var resources = this.get('resources');&#10;    if (resources) {&#10;        for (var name in resources) {&#10;            browser.addResource(name, resources[name].data, resources[name].contentType);&#10;        }&#10;    }&#10;&#10;    var toDisplay = this.get('html');&#10;    browser.display(toDisplay);&#10;};&#10;&#10;/** Update the specified property of the DOM element of the current page,&#10; *  if it exists, with the specified content.&#10; *  @param id The ID.&#10; *  @param property The type of the update. If this is &quot;html&quot;, then the&#10; *   DOM object is updated by invoking the jQuery html() function it&#10; *   with the specified content as an argument. Otherwise, the property&#10; *   with name *property* is assigned the value of the content.&#10; *   If *property* is 'src', then in addition, the content is augmented&#10; *   with a suffix of the form '?count=*n*', where *n* is a unique number.&#10; *   This is so that the browser will be forced to reload the src rather than&#10; *   using any cached version it may have. This can be used, for example,&#10; *   to force an update to an img tag where a new image has been provided&#10; *   using addResource().&#10; *  @param content The content of the update, typically HTML to insert or&#10; *   a property value like src to set.&#10; */&#10;function update() {&#10;    var update = this.get('update');&#10;    if (!update.id || !update.property || !update.content) {&#10;        error('Malformed update input. Expected an object with id, property, and content properties.'&#10;                + 'Got instead: ' + util.inspect(update));&#10;        return;&#10;    }&#10;    browser.update(update.id, update.property, update.content);&#10;}&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    browser = new Browser.Browser(&#10;            {'port': self.getParameter('port')},&#10;            self.getParameter('header'),&#10;            self.getParameter('content')&#10;    );&#10;    // Listen for any POST to the server.&#10;    browser.addListener('/', function(data) {&#10;        self.send('post', JSON.parse(data));&#10;    });&#10;&#10;    this.addInputHandler('html', display.bind(this));&#10;&#10;    this.addInputHandler('update', update.bind(this));&#10;&#10;    this.addInputHandler('resources', function() {&#10;        var resources = this.get('resources');&#10;        for (var name in resources) {&#10;            browser.addResource(name, resources[name].data, resources[name].contentType);&#10;        }&#10;    });&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (browser) {&#10;        browser.stop();&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/Browser.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor that uses a browser on the local host for interaction with a user.&#10; The initial content on the page may be specified using the &lt;em&gt;content&lt;/em&gt;&#10; parameter and HTML header content may be specified using &lt;em&gt;header&lt;/em&gt;.&lt;/p&gt;&#10;&lt;p&gt; Whatever text is received on the &lt;em&gt;html&lt;/em&gt; input port will replace the content&#10; of the web page. Normally, this will be HTML text without any DOCTYPE or&#10; header and without a body tag. Each time new text is received, the content&#10; of the page will be replaced.&lt;/p&gt;&#10;&lt;p&gt; The page will be opened upon initialize if &lt;em&gt;content&lt;/em&gt; is not empty.&#10; Otherwise, it will be opened when the first &lt;em&gt;html&lt;/em&gt; input is received.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;resources&lt;/em&gt; input can be used to provide resources, such as images,&#10; that will be used by the HTML content provided on the &lt;em&gt;html&lt;/em&gt; input.&#10; Note that you probably will also have to provide an &lt;em&gt;update&lt;/em&gt; input (see below)&#10; to force the browser to update the page using the specified resource.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;update&lt;/em&gt; input can be used to instruct the browser to replace content&#10; within the page, vs. the &lt;em&gt;html&lt;/em&gt; input which replaces the entire page.&#10; The value of an &lt;em&gt;update&lt;/em&gt; input is expected to be an object with three properties,&#10; &lt;em&gt;id&lt;/em&gt;, &lt;em&gt;property&lt;/em&gt;, and &lt;em&gt;content&lt;/em&gt;.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;id&lt;/em&gt; property refers to a the ID of&#10; a DOM element in the content of the page, where the content has been provided&#10; either via the &lt;em&gt;content&lt;/em&gt; parameter or the &lt;em&gt;html&lt;/em&gt; input. For example, your&#10; page may include:&#10; &lt;pre&gt;&#10;    &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#10; &lt;/pre&gt;&#10; or&#10; &lt;pre&gt;&#10;    &amp;lt;img id=&amp;quot;bar&amp;quot; src=&amp;quot;image.jpg&amp;quot;/&amp;gt;&#10; &lt;/pre&gt;&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;p&gt;@param id The ID.&#10;The &lt;em&gt;property&lt;/em&gt; field specifies what property of the DOM element with the&#10;specified ID is to be updated. If &lt;em&gt;property&lt;/em&gt; is &amp;quot;html&amp;quot;, then the&#10;DOM object is updated by invoking the jQuery html() function&#10;with the specified &lt;em&gt;content&lt;/em&gt; as an argument. For example, if &lt;em&gt;id&lt;/em&gt; is &amp;quot;foo&amp;quot;,&#10;&lt;em&gt;property&lt;/em&gt; is &amp;quot;html&amp;quot;, and &lt;em&gt;content&lt;/em&gt; is &amp;quot;Hello World!&amp;quot;, then the above div&#10;will be populated with the text &amp;quot;Hello World!&amp;quot; on the web page.&#10;The &lt;em&gt;content&lt;/em&gt; can include any HTML markup or even scripts, which will be executed.&lt;/p&gt;&#10;&lt;p&gt;If &lt;em&gt;property&lt;/em&gt; is anything other than 'html', then the DOM element's &lt;em&gt;property&lt;/em&gt;&#10;attribute will be assigned the value of &lt;em&gt;content&lt;/em&gt;.&#10;A &lt;em&gt;property&lt;/em&gt; value of 'src', however, is treated specially.&#10;A &lt;em&gt;property&lt;/em&gt; value of 'src' can be used, for example, to replace the image in the above img tag.&#10;Just send the updated image to the &lt;em&gt;resources&lt;/em&gt; input and send this to the&#10;&lt;em&gt;update&lt;/em&gt; input:&lt;/p&gt;&#10;&lt;pre&gt;&#10;{'id':'bar', 'property':'src', 'content':'image.jpg'}&#10;&lt;/pre&gt;&#10;&#10;&lt;p&gt;Note that to get the browser to actually replace the image, we have to play some tricks.&#10;A browser normally caches an image that it has previously retrieved&#10;and it will use the cached version of the image rather than obtaining the new image&#10;from the server.  To force the browser to refresh the image, this accessor&#10;treats a &lt;em&gt;property&lt;/em&gt; value of 'src' specially.&#10;Specifically, it appends to the &lt;em&gt;content&lt;/em&gt; a suffix of the form '?count=&lt;em&gt;n&lt;/em&gt;',&#10;where &lt;em&gt;n&lt;/em&gt; is a unique number. This forces the browser to retrieve the image&#10;from the server rather than use its cached version because the URI is&#10;different from that of the cached version. The server, on the other hand, ignores&#10;the parameter 'count' that has been appended to this URI and simply returns the&#10;updated image.&lt;/p&gt;&#10;&lt;p&gt;The way this accessor works on most hosts is that it starts a web server on localhost&#10;at the specified port that serves the specified web page and then instructs&#10;the system default browser to load the default page from that server.&#10;The page served by the server includes a script that listens for websocket&#10;connections that are used to provide HTML content and udpates to display on the page.&#10;Some hosts, however, such as the cordova and browser hosts, natively use&#10;a browser as part of the host, so in these cases, no web server nor socket&#10;connection is needed and the &lt;em&gt;port&lt;/em&gt; parameter will be ignored.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="html (port)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to render in the body of the page displayed&#10;  by the browser.">
            </property>
            <property name="resources (port)" class="ptolemy.kernel.util.StringAttribute" value="An object where each named property is an object containing&#10;  two properties, 'data' and 'contentType'. The name of the named property is&#10;  the path to be used to access the resource. The 'data' property is the resource&#10;  itself, an arbitrary collection of bytes. The 'contentType' is the MIME&#10;  type of the data.">
            </property>
            <property name="header (parameter)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to include in the header part of the web page.&#10;  This is a good place to script definitions.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to use, if needed, for websocket communication between this&#10;  accessor (which updates the HTML content of the web page) and the browser.&#10;  The web page will listen on this socket for content and display whatever arrives&#10;  on that port. This is ignored on hosts that do not need to invoke an external browser.">
            </property>
            <property name="content (parameter)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to include in the main body of the page.&#10;  If this is non-empty, then the page is opened upon initialize.&#10;  Otherwise, the page is opened when the first *html* input is received.">
            </property>
            <property name="update (port)" class="ptolemy.kernel.util.StringAttribute" value="An object with three properties, 'id', 'property', and 'content',&#10;  that specifies an update to a DOM element on the page.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="header" class="ptolemy.data.expr.Parameter" value="&lt;script&gt;&#10;// Append a message to the web page.&#10;var first = true;&#10;function display(message) {&#10;    var div = document.getElementById(&quot;data&quot;);&#10;    if (first) {&#10;        first = false;&#10;    } else {&#10;        div.appendChild(document.createElement('br'));&#10;    }&#10;    div.appendChild(document.createTextNode(message));&#10;}&#10;// Upon loading the page, display any messages previously received.&#10;var loaded = false;&#10;var pending = [];&#10;// This leverages the fact that the Browser accessor uses jQuery.&#10;// This shorthand will invoke the function when the page is loaded.&#10;// The $$ is needed here because CapeCode will convert this to a single dollar sign.&#10;$$(function() {&#10;    loaded = true;&#10;    for (var i = 0; i &lt; pending.length; i++) {&#10;        display(pending[i]);&#10;    }&#10;    pending = [];&#10;});&#10;// Open the web socket and listen for messages.&#10;// This leverages that the Browser accessor can require any module of the browser host.&#10;var ws = require('web-socket-client.js');&#10;// Note that the wsPort parameter of the containing model is used.&#10;var client = new ws.Client({'host': 'localhost', 'port': $wsPort});&#10;client.on('message', function(message) {&#10;    if (loaded) {&#10;        display(message);&#10;    } else {&#10;        pending.push(message);&#10;    }&#10;});&#10;client.open();&#10;&lt;/script&gt;">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="30">
                </property>
            </property>
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{545.0, 185.0}">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="serverPort">
        </property>
        <property name="content" class="ptolemy.data.expr.Parameter" value="">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="30">
                </property>
            </property>
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="html" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="resources" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="post" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="update" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="WebSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2016-2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  The output `connection` reports the when a&#10; *  connection is opened or closed.&#10; *&#10; *  When a message arrives on a connection, a `received`&#10; *  output is produced with that message. Note that the message may arrive in&#10; *  multiple frames, but it will be produced as a single message.&#10; *&#10; *  When an input arrives on `toSend`, then a message is&#10; *  sent to one or all of the open socket connections.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  server and all connections.&#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The this.send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to this.send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  This accessor requires the module webSocket.&#10; *&#10; *  @accessor net/WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen to for connections.&#10; *  @parameter {string} pfxKeyCertPassword If sslTls is set to true, then this option needs&#10; *   to specify the password for the pfx key-cert file specified by pfxKeyCertPath.&#10; *  @parameter {string} pfxKeyCertPath If sslTls is set to true, then this option needs to&#10; *   specify the fully qualified filename for the file that stores the private key and certificate&#10; *   that this server will use to identify itself. This path can be any of those understood by the&#10; *   Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10; *  @parameter {string} receiveType The MIME type for incoming messages,&#10; *    which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages,&#10; *    which defaults to 'application/json'.&#10; *  @parameter {boolean} sslTls Whether SSL/TLS is enabled. This defaults to false.&#10; *  @input toSend The data to be sent to open sockets.&#10; *    If this is an object with 'socketID' field and a 'message' field,&#10; *    then send the value of the message field to the socket identified&#10; *    by the socketID field. If the input has any other form, then the&#10; *    message is broadcast to all open socket connections.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *  @output connection An output produced when a connection opens or closes.&#10; *    The output is an object with two fields, a 'socketID',&#10; *    which is a unique ID for this client connection, and a 'status' field,&#10; *    which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;/*jslint plusplus: true */&#10;&#10;var WebSocket = require('@accessors-modules/web-socket-server');&#10;var server = null;&#10;var running = false;&#10;var debug = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function () {&#10;    this.parameter('hostInterface', {&#10;        value: &quot;localhost&quot;,&#10;        type: &quot;string&quot;&#10;    });&#10;    this.parameter('port', {&#10;        value: 8080,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.parameter('pfxKeyCertPassword', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('pfxKeyCertPath', {&#10;        value: '',&#10;        type: 'string'&#10;    });&#10;    this.parameter('receiveType', {&#10;        type: 'string',&#10;        value: 'application/json'&#10;    });&#10;    this.parameter('sendType', {&#10;        type: 'string',&#10;        value: 'application/json'&#10;    });&#10;    this.parameter('sslTls', {&#10;        type: 'boolean',&#10;        value: false&#10;    });&#10;    this.input('toSend');&#10;    this.output('received', {&#10;        'spontaneous': true        &#10;    });&#10;    this.output('listening', {&#10;        'type': 'int',&#10;        'spontaneous': true&#10;    });&#10;    this.output('connection', {&#10;        'spontaneous': true&#10;    });&#10;&#10;    // Attempt to add a list of options for types, but do not error out&#10;    // if the socket module is not supported by the host.&#10;    try {&#10;        this.parameter('receiveType', {&#10;            options: WebSocket.supportedReceiveTypes()&#10;        });&#10;        this.parameter('sendType', {&#10;            options: WebSocket.supportedSendTypes()&#10;        });&#10;    } catch (err) {&#10;        error(err);&#10;    }&#10;};&#10;&#10;//var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs.&#10; * Adds an input handler on toSend that sends the input received to the right socket. */&#10;exports.initialize = function () {&#10;    var self = this;&#10;    self.sockets = [];&#10;&#10;    if (!server) {&#10;        server = new WebSocket.Server({&#10;            'port': this.getParameter('port'),&#10;            'hostInterface': this.getParameter('hostInterface'),&#10;            'pfxKeyCertPassword': this.getParameter('pfxKeyCertPassword'),&#10;            'pfxKeyCertPath': this.getParameter('pfxKeyCertPath'),&#10;            'receiveType': this.getParameter('receiveType'),&#10;            'sendType': this.getParameter('sendType'),&#10;            'sslTls': this.getParameter('sslTls')&#10;        });&#10;        // Using 'this.exports' rather than just 'exports' in the following allows&#10;        // these functions to be overridden in derived accessors.&#10;        server.on('listening', this.exports.onListening.bind(this));&#10;        server.on('connection', this.exports.onConnection.bind(this));&#10;        server.on('error', function (message) {&#10;            self.error(message);&#10;        });&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    this.addInputHandler('toSend', function () {&#10;        var data = self.get('toSend'),&#10;            id;&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;&#10;            // JSHint WARNING: Do not change dataSocketID != null to&#10;            // data.socketID !== null because it will cause&#10;            // org/terraswarm/accessor/test/auto/WebSocketClient.xml&#10;            // to fail upon reloading.  See&#10;            // org/terraswarm/accessor/test/WebSocketClientTest.tcl&#10;            if ((data.socketID != null) &amp;&amp; (data.message !== null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (self.sockets[data.socketID] &amp;&amp; self.sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    /*&#10;                      console.log(self.accessorName + ': WebSocketServer: Sending to socket id ' +&#10;                      data.socketID +&#10;                      &quot; message: &quot; +&#10;                      data.message);&#10;                    */&#10;                    self.sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log(self.accessorName + ': WebSocketServer.js: Socket with ID ' + data.socketID +&#10;                        ' is not open. Discarding message.');&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                // var success = false;&#10;                for (id = 0; id &lt; self.sockets.length; id += 1) {&#10;                    if (self.sockets[id].isOpen()) {&#10;                        // console.log(self.accessorName + 'WebSocketServer.js: Broadcasting to socket id ' + id&#10;                        //         + ' message: ' + data);&#10;                        self.sockets[id].send(data);&#10;                        // success = true;&#10;                    }&#10;                }&#10;                // if (!success) {&#10;                //     console.log(self.accessorName + 'WebSocketServer.js: No open sockets. Discarding message: ' + data.message);&#10;                // }&#10;            }&#10;        }&#10;    });&#10;};&#10;&#10;exports.onListening = function () {&#10;    if (debug) {&#10;        console.log(this.accessorName + 'WebSocketServer.js: Listening for socket connection requests.');&#10;    }&#10;    this.send('listening', this.getParameter('port'));&#10;};&#10;&#10;/** Executes when a connection has been established.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;exports.onConnection = function (socket) {&#10;    // socketID is the index of the socket in the sockets array.&#10;    var self = this,&#10;        socketID = self.sockets.length;&#10;    if (debug) {&#10;        console.log(this.accessorName + 'WebSocketServer.js: new socket established with ID: ' + socketID);&#10;    }&#10;    this.send('connection', {&#10;        'socketID': socketID,&#10;        'status': 'open'&#10;    });&#10;&#10;    self.sockets.push(socket);&#10;&#10;    self.sockets[socketID].on('message', function (message) {&#10;        console.log('WebSocketServer message(): ' + message + ', typeof message: ' + typeof message);&#10;        // For some reason, under the Node Host, the message is an&#10;        // object.  Under CapeCode, it is a string?&#10;        var isObjectWithQuotes = (typeof message === 'object' &amp;&amp; message.toString().startsWith('&quot;') &amp;&amp; message.toString().endsWith('&quot;'));&#10;        // If message is a string, strip leading and trailing &quot;&#10;        if (typeof message === 'string' || isObjectWithQuotes) {&#10;            if (isObjectWithQuotes) {&#10;                message = message.toString();&#10;            }&#10;            message = message.replace(/^&quot;(.*)&quot;$/, '$1');&#10;        }&#10;        self.send('received', {&#10;            'message': message,&#10;            'socketID': socketID&#10;        });&#10;    });&#10;    self.sockets[socketID].on('close', function () {&#10;        self.send('connection', {&#10;            'socketID': socketID,&#10;            'status': 'closed'&#10;        });&#10;    });&#10;    self.sockets[socketID].on('error', function (message) {&#10;        console.log(self.accessorName + ': WebSocketServer.js: error ' + message);&#10;        self.error(message);&#10;    });&#10;&#10;&#10;};&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server.&#10; */&#10;exports.wrapup = function () {&#10;    this.sockets = [];&#10;&#10;    if (server !== null) {&#10;        server.stop();&#10;        server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/WebSocketServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor starts a server that listens for web socket&#10; connection requests on the specified hostInterface and port.  The&#10; hostInterface is needed only if the host machine has more than one&#10; network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; not resolve to the desired interface.&lt;/p&gt;&#10;&lt;p&gt; The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; connection is opened or closed.&lt;/p&gt;&#10;&lt;p&gt; When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; output is produced with that message. Note that the message may arrive in&#10; multiple frames, but it will be produced as a single message.&lt;/p&gt;&#10;&lt;p&gt; When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; sent to one or all of the open socket connections.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; server and all connections.&lt;/p&gt;&#10;&lt;p&gt; The default type for both sending and receiving&#10; is 'application/json', which allows sending and receiving anything that has&#10; a string representation in JSON. The types supported by this implementation&#10; include at least:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;application/json&lt;/strong&gt;: The this.send() function uses JSON.stringify() and sends the&#10;result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10;and if the parsing fails, will be provided as a string interpretation of the byte&#10;stream.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;text/*&lt;/strong&gt;: Any text type is sent as a string encoded in UTF-8.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;image/x&lt;/strong&gt;: Where &lt;strong&gt;x&lt;/strong&gt; is one of &lt;strong&gt;json&lt;/strong&gt;, &lt;strong&gt;png&lt;/strong&gt;, &lt;strong&gt;gif&lt;/strong&gt;,&#10;and more.&#10;In this case, the data passed to this.send() is assumed to be an image, as encoded&#10;on the host, and the image will be encoded as a byte stream in the specified&#10;format before sending.  A received byte stream will be decoded as an image,&#10;if possible.&lt;/p&gt;&#10;&lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Edward Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" value="The data to be sent to open sockets.&#10;   If this is an object with 'socketID' field and a 'message' field,&#10;   then send the value of the message field to the socket identified&#10;   by the socketID field. If the input has any other form, then the&#10;   message is broadcast to all open socket connections.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on">
            </property>
            <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" value="An output produced when a connection opens or closes.&#10;   The output is an object with two fields, a 'socketID',&#10;   which is a unique ID for this client connection, and a 'status' field,&#10;   which is the string 'open' or 'closed'.">
            </property>
            <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" value="A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of the&#10;   network interface to listen to.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to listen to for connections.">
            </property>
            <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option needs&#10;  to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
            </property>
            <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" value="If sslTls is set to true, then this option needs to&#10;  specify the fully qualified filename for the file that stores the private key and certificate&#10;  that this server will use to identify itself. This path can be any of those understood by the&#10;  Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
            </property>
            <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for incoming messages,&#10;   which defaults to 'application/json'.">
            </property>
            <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The MIME type for outgoing messages,&#10;   which defaults to 'application/json'.">
            </property>
            <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" value="Whether SSL/TLS is enabled. This defaults to false.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPassword" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="pfxKeyCertPath" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[215.0, 175.0]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="wsPort">
        </property>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="JavaScript" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('trigger');&#10;	this.output('html', {'type':'string'});&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('trigger', function() {&#10;		var html = '&lt;h1&gt;Data Received:&lt;/h1&gt;&lt;div id=&quot;data&quot;&gt;&lt;/div&gt;';&#10;		self.send('html', html);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[395.0, 175.0]">
        </property>
        <port name="trigger" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="html" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="Clock.output" relation="relation"/>
    <link port="Browser.html" relation="relation3"/>
    <link port="WebSocketServer.toSend" relation="relation"/>
    <link port="WebSocketServer.listening" relation="relation4"/>
    <link port="JavaScript.trigger" relation="relation4"/>
    <link port="JavaScript.html" relation="relation3"/>
</entity>
