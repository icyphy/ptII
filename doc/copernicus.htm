<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="Quadralay WebWorks Publisher Standard Edition 6.0.6">
<meta name="TEMPLATEBASE" content="Portable HTML Standard Edition">
<meta name="LASTUPDATED" content="07/18/05 10:17:43">
<title>7 Copernicus  </title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>

<body link="#3366CC" vlink="#9999CC" text="#000000" alink="#0000CC" bgcolor="#FFFFFF"





<blockquote>
<div align="center">
<h2>
  <a name="149600"> </a>7  Copernicus
</h2>
</div>
<!-- see expression.htm for notes about converting from Framemaker to html-->

<p>This version is in HTML, a PDF version can be found in Chapter 8 of 
<a href="http://ptolemy.eecs.berkeley.edu/ptolemyII/designdoc.htm#in_browser" target="_top">Volume 2: Software Architecture</a>


<p><a name="161048"> </a>Authors: Steve Neuendorffer<br>		Christopher Brooks<br>


<a name="166235"> </a>		Ankush Varma<br>


<a name="166236"> </a>		Shuvra S. Bhattacharyya<br>


<h3>
  <a name="161042"> </a>7.1   Introduction
</h3>


<a name="164034"> </a>The copernicus package is an infrastructure for building code generators for Ptolemy II models. The basic design goal was to provide a common interface to different code generators and consolidate some of the basic argument handling and default parameters. Several different code generators of varying complexity have been implemented. There is also quite a bit of testing infrastructure for integrating code generation with the nightly build system.<br>


<p>
  <a name="163738"> </a>The basic infrastructure is implemented in the copernicus.kernel package. The Copernicus class contains a main function suitable for invocation from the command line. The GeneratorAttribute class represents code generation parameters that can be persistently added to a model for unusual configurations of a code generator. The KernelMain class is a base class from which classes for various code generators can be derived. Instances of these subclasses are instantiated and executed in a code generation job. 
</p>


<p>
  <a name="164042"> </a>The Copernicus class itself is invoked to begin code generation from a model. If invoked from the command line, it reads command line arguments to determine various code generation options and an MoML file to load a model from. If invoked via various static methods, code generation options are assumed to be passed in through a GeneratorAttribute. Default code generation options are specified in the Generator.xml file. One of the code generation parameters determines the code generator to execute. The class representing the code generator is loaded through reflection and invoked through the KernelMain base class.
</p>


<p>
  <a name="164047"> </a>The KernelMain base class provides default behavior for most code generators. It performs static analysis, such as type resolution and scheduling by invoking the Manager.preinitalizeAndResolveTypes() method and then passes control to the specific code generator.
</p>


<h4>
  <a name="164113"> </a>7.1.1   Default options
</h4>


<a name="164120"> </a>Most code generators share common options. The following options are defined by default in generator.xml.<br>


<p>
  <a name="164123"> </a>codeGenerator: The code generator to run.
</p>


<p>
  <a name="164127"> </a>
</p>


<p>
  <a name="164128"> </a>codeGeneratorClassName: The class that is instantiated to execute a particular code generator.  This class is expected to be a subclass of ptolemy.copernicus.kernel.KernelMain.
</p>


<p>
  <a name="164134"> </a>
</p>


<p>
  <a name="164135"> </a>compile: If true, compile the generated code.  The default is true.
</p>


<p>
  <a name="164139"> </a>
</p>


<p>
  <a name="164140"> </a>show: If true, then show the generated code.  The default is true.
</p>


<p>
  <a name="164144"> </a>
</p>


<p>
  <a name="164145"> </a>run:  If true, then run the generated code.  The default is true.
</p>


<p>
  <a name="164149"> </a>
</p>


<p>
  <a name="164150"> </a>ptII: The location of the Ptolemy II classes.  The default is the value of the ptolemy.ptII.dir Java system property
</p>


<p>
  <a name="164155"> </a>
</p>


<p>
  <a name="164156"> </a>ptIIUserDirectory: The top level directory to write the code in. The default is the value of the ptII parameter. The code will appear in 'ptIIUserDirectory/targetpath'.
</p>


<p>
  <a name="164162"> </a>
</p>


<p>
  <a name="164163"> </a>targetPackage: The package to generate code in. The default is the model name
</p>


<p>
  <a name="164167"> </a>
</p>


<p>
  <a name="164168"> </a>targetPath: The path relative to the ptIIUserDirectory to generate code in. The default is the "cg" subdirectory of the particular code generator.
</p>


<p>
  <a name="164316"> </a>
</p>


<p>
  <a name="164269"> </a>outputDirectory: The directory that code will be generated in. By default this is the targetPath parameter appended to the ptIIUserDirectory path.
</p>


<p>
  <a name="164274"> </a>
</p>


<p>
  <a name="164275"> </a>modelPath: The path to the model, including the .xml extension. The modelPath parameter is converted to a URL internally before use.
</p>


<p>
  <a name="164299"> </a>
</p>


<p>
  <a name="164300"> </a>compileOptions: User supplied arguments to be passed to the code generator.  Defaults to the empty string.
</p>


<p>
  <a name="164305"> </a>
</p>


<p>
  <a name="17.2.devel"> </a>javaClassPath: The Java class path, converted to a string.
</p>


<p>
  <a name="164417"> </a>
</p>


<p>
  <a name="164362"> </a>runCommandTemplateFile: The template file that contains the command to run the generated code.
</p>


<p>
  <a name="164367"> </a>
</p>


<p>
  <a name="164368"> </a>runOptions: User supplied arguments to be passed to the command that will run the generated code. Defaults to the empty string.
</p>


<p>
  <a name="164373"> </a>
</p>


<p>
  <a name="164374"> </a>sootDir: The directory that contains the soot jar files. Defaults to the value of the ptII parameter  + "/lib"
</p>


<p>
  <a name="164379"> </a>
</p>


<p>
  <a name="164380"> </a>sootClasses: The location of sootclasses.jar, jasminclasses.jar and the Java system jar (usually rt.jar).  The necessaryClassPath parameter may end up duplicating some of the elements of this parameter.
</p>


<p>
  <a name="164462"> </a>
</p>


<p>
  <a name="164463"> </a>watchDogTimeout: The number of milliseconds that code generation will run for. Defaults to 720000, which is 12 minutes. The watchdog is used to prevent the code generator and the generated code from hanging the nightly build.
</p>


<p>
  <a name="164400"> </a>
</p>


<p>
  <a name="164401"> </a>output: The filename to redirect the standard output stream of the code generator to.  This is used, for example, in the nightly build to provide easily parseable error messages.  If the value is not set, then the output will not be redirected.
</p>


<p>
  <a name="164360"> </a>
</p>


<h3>
  <a name="164057"> </a>7.2   Java Code Generator
</h3>


<a name="164071"> </a>The Java code generator is implemented by the copernicus.java package. This code generator targets the generation of self-contained Java code optimized for code size, memory usage and execution speed. The Java code generator leverages the Soot compiler framework to parse the bytecode for each atomic actor in the model. The actors are then specialized according to their context in the model.<br>


<p>
  <a name="164509"> </a>The Java code generator operates in several phases, and the output of each phase is a partially specialized model. The output from the intermediate phases can be generated by setting the <i>snapshots</i> parameter to be true. The first snapshot consists of self-contained code specialized to the domains in the model. The second snapshot is additionally specialized to the parameter values in the model, while the third is specialized to the structure of the model. The fourth snapshot eliminates all references to Ptolemy named objects in the model, resulting in self-contained code without component interfaces. The final generated code has also been specialized for data types and contains no references to Ptolemy tokens.
</p>


<p>
  <a name="164531"> </a>One of the goals of the Java code generator was to avoid separate specifications for simulation and code generation wherever possible. The Java code generator operates by transforming Java actor specifications (actor classes) and on Java data type specifications (token classes). In most cases, new actor and token classes will be leveraged transparently by the code generator. Unfortunately, domain specifications are not as easily reused and the Java code generator contains "re-implementations" of domains for code generation. This allows for more efficient code to be generated, at the expense of duplicating aspects of existing Director and Receiver code, and making it more difficult for new domains to be implemented in code generation.
</p>


<p>
  <a name="164576"> </a>In order for existing actor code to be leveraged by the code generator, it assumes that the code is written according to the Ptolemy style for writing actors. This style assumes naming conventions for the public fields of an actor class that refer to parameters and ports of the actor. The code generator also assumes that the ports and parameters of an actor are created in the class constructor and not modified later. Some actors do not fit these constraints and cannot be used directly in the code generator. Such actor classes cannot be used directly by the code generator, although in some cases we have been able to have the code generator deal specially with such actors. In other cases, the actor class fits the constraints but cannot be effectively specialized using generic techniques. Such actors can also be dealt with specially by the code generator to more effectively generate code.
</p>


<h4>
  <a name="164584"> </a>7.2.1   Software Architecture
</h4>


<p>
  <a name="164568"> </a>The Java code generator consists of a large number of individual transformation steps, which will not be described here. These transformation steps are implemented by classes extending the SceneTransformer class, or the BodyTransformer class. Two key points of extensibility are provided for generating domain code and for generating actor code to replace unspecializable actor classes.
</p>


<p>
  <a name="164603"> </a>Code generation for specific domains is handled by various implementations of the DomainCodeGenerator interface. An implementation of this interface is responsible for generating domain interaction code for a particular composite actor in the hierarchy, including code to invoke the methods of various actors and domain-specific communication structures. Currently, the following domains are handled:
</p>


<p>
  <a name="164607"> </a>Synchronous Dataflow (SDF): The SDF implementation transforms the SDF schedule into Java code that invokes the actors in a model. Fixed size arrays are generated for communication buffers dedicated to each relation in the model, and communication methods are replaced with circularly indexed addressing into the communication buffers.
</p>


<p>
  <a name="164623"> </a>Hybrid Systems (HS): The hybrid systems director deals with modal models. Currently, only the subset that is useful in modal SDF models is implemented.
</p>


<p>
  <a name="164624"> </a>Giotto: The Giotto implementation interfaces directly with the Java output of the Giotto compiler. It generates classes with static methods used for communication by the Giotto compiler and generates a .giotto file that describes the classes implementing the various Giotto tasks. The Giotto compiler compiles this file into a class that implements the Giotto task scheduling model.
</p>


<p>
  <a name="164627"> </a>Code Generation for actors is handled various implementations of the AtomicActorCreator interface. An implementation of this interface generates a self-contained class for a particular actor. The default implementation of this interface, the GenericAtomicActorCreator class, simply copies the existing actor specification code. Other implementations of the interface deal with generating code for specific actors. Currently the following actors are handled specially:
</p>


<p>
  <a name="164637"> </a>Expression: The standard implementation of this actor builds a parse tree for the expression and traverses the parse tree to evaluate it at run time. This actor is handled specifically by the ExpressionCreator class for two reasons. Primarily, the parse tree is convenient way of representing an arbitrary expression, but much simpler code can be generated for a specific expression. Secondarily, the parse tree complicates other transformations that specialize communication between actors and data types.
</p>


<p>
  <a name="164638"> </a>FSMActor: The standard implementation of this actor builds parse trees for every expression in a model, and suffers from the same drawbacks as the Expression actor. The FSMActor also attempts to deal with run-time modifications of the finite-state machine in an efficient manner, which is not necessary in generated code. This actor is handled specifically by the FSMCreator class.
</p>


<p>
  <a name="164639"> </a>Many actors are not handled specifically, but should be. Here is a short list:
</p>


<p>
  <a name="164640"> </a>MathFunction: This actor creates and deletes its ports based on a parameter value. In generated code will likely not happen (since the parameter value is not likely to change), but the GenericAtomicActorCreator is not smart enough to deal with ports that are not created in the constructor. It is likely easiest to handle this actor by handling it specially and checking that the parameter value does not change using reconfiguration analysis.
</p>


<p>
  <a name="164641"> </a>TypeTest: This actor tests the type system, but has no run-time behavior. It is problematic because it iterates over all of the actors in a model, which is currently not supported by the code generation mechanism. It could probably be checked statically and ignored in generated code.
</p>


<p>
  <a name="164642"> </a>RecordAssembler and RecordDisassembler: These actors iterator over their input and output ports to construct a record. They could either be dealt with specially, or the code generator could be improved to unroll iterators over ports.
</p>


<p>
  <a name="164643"> </a>ExpressionToToken and ExpressionReader: These actors operate in a similar way to the expression actor, except that the expression is received from an input port. Because of this, code generation will not work. It is not clear how to make this actor work nicely with type specialization.
</p>


<h4>
  <a name="164644"> </a>7.2.2   Generated Code
</h4>


<p>
  <a name="164645"> </a>The code generated from the Java code generator is a set of self-contained Java .class files with a command-line interface. A makefile is automatically generated with a large number of rules for manipulating the generated code. The makefile rules are:
</p>


<p>
  <a name="164959"> </a>	runJava: Run the generated code.
</p>


<p>
  <a name="164676"> </a>compareAll: Run a series of comparisons between the simulation model, the generated code, and the obfuscated version of the generated code comparing code size, execution speed, and memory usage.
</p>


<p>
  <a name="164707"> </a>treeShake: Generate a self-contained .jar file containing only code necessary for the generated code. This rule uses reachable method information gained through static analysis in the code generator, if possible. 
</p>


<p>
  <a name="164974"> </a>treeShakeByRunning: Generate a self-contained .jar file containing only code necessary for the generated code. This rule executes the generated code and extracts information from the virtual machine about which classes were loaded at runtime.
</p>


<p>
  <a name="164732"> </a>runTreeShake: Run the generated code from the self-contained .jar file.
</p>


<p>
  <a name="164739"> </a>profileTreeShake: Run the generated code from the self-contained .jar file with profiling options to report runtime memory usage. An average of several runs is reported.
</p>


<p>
  <a name="165000"> </a>treeShakeWithoutCodegen: Generate a self-contained .jar file containing only code necessary for executing the simulation model. This rule executes the generated code and extracts information from the virtual machine about which classes were loaded at runtime.
</p>


<p>
  <a name="164768"> </a>runTreeShakeWithoutCodegen: Run the original simulation model from the self-contained .jar file.
</p>


<p>
  <a name="165017"> </a>profileTreeShakeWithoutCodegen: Run the original simulation model from the self-contained .jar file with profiling options to report runtime memory usage. An average of several runs is reported.
</p>


<p>
  <a name="164862"> </a>obfuscate: Run the Jode obfuscator on the generated code, to minimize the size of the generated .jar file.
</p>


<p>
  <a name="164867"> </a>runObfuscate: Run the obfuscated version of the generated code.
</p>


<p>
  <a name="165066"> </a>profileObfuscate: Run the obfuscated version of the generated code from the self-contained .jar file with profiling options to report runtime memory usage. An average of several runs is reported.
</p>


<p>
  <a name="164909"> </a>gcj: Compile the generated code into a native executable using gcj. Note: this will likely only work for simple models, as the gcj standard Java libraries are far from complete.
</p>


<h4>
  <a name="170809"> </a>7.2.3   Java Code Generation Demonstrations
</h4>


<a name="170822"> </a>Below are several demonstrations of the Java code generator. Our canonical Java code generation model is the OrthogonalCom model located in $PTII/ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xm, see Figure <a href="#170822">7.1</a>l<img src="img/copernicus2.gif" height="467" width="599" align="left" border="0" hspace="0" vspace="0">
.<br>


<p>
  <a name="170839"> </a>We use the copernicus shell script, located at $PTII/bin/copernicus to run the Java code generator:
</p>

<pre>
$PTII/bin/copernicus -codeGenerator java $PTII/ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml<a name="170855"> </a>
</pre>

<p>
  <a name="170853"> </a>
</p>


<p>
  <a name="170877"> </a>The above command will generate voluminous output and eventually create .class files in $PTII/ptolemy/copernicus/java/cg/OrthogonalCom and run the generated code.
</p>


<h5>
  <a name="171000"> </a><i>Treeshaking</i>
</h5>


<a name="171004"> </a><br>


<p>
  <a name="170939"> </a>The copernicus script also generates a makefile in the output directory that contain rules to perform operations like treeshaking and obfuscation. Treeshaking is an optimization where we run the model, note what .class files are loaded and then place those .class files in a jar file. Treeshaking is not perfect, since if the model is running from the jar file and later throws an exception the error handlers and other .class files might not be present. Obfuscation is an optimization that shortens class and method names so as to decrease the size of the jar file. 
</p>


<p>
  <a name="170953"> </a>We use Jode to obfuscate the code. Jode is available from http://jode.sourceforge.net/. Unfortunately, Jode is distributed under the GNU General Public License (GPL), so we do not include it in the Ptolemy release. To set up Jode:
</p>

<ol type="1">
  <li value="1"><a name="170956"> </a>Download Jode so that $PTII/vendors/jode/1.1.1/jode.jar is present.
  <li value="2"><a name="170957"> </a>Re run configure with:
</ol>
<pre>
cd $PTII
./configure<a name="170958"> </a>
</pre>

<p>
  <a name="170978"> </a>Then go back to the output directory and run make:
</p>

<pre>
$PTII/ptolemy/copernicus/java/cg/OrthogonalCom
make compareAll<a name="171298"> </a>
</pre>

<h5>
  <a name="171005"> </a><i></i>
</h5>


<h5>
  <a name="171214"> </a><i>Setting the iterations</i>
</h5>


<a name="171009"> </a><br>


<p>
  <a name="171010"> </a>The truly observant will have noticed that the various versions of the model ran very quickly and that it is difficult to compare the time performance of the different versions. The solution is to increase the number of iterations so that we can see differences in time performance. $PTII/ptolemy/copernicus/kernel/KernelMain.java describes how to set the iterations:
</p>

<pre>
*  If the director is an SDF director, then the number of               <a name="171088"> </a>
*  iterations is handled specially.  If the director is an SDF             <a name="171089"> </a>
*  director and a parameter called "copernicus_iterations" is              <a name="171129"> </a>
*  present, then the value of that parameter is used as the                <a name="171130"> </a>
*  number of iterations.  If the director is an SDF director, and          <a name="171131"> </a>
*  there is no "copernicus_iterations" parameter but the                <a name="171148"> </a>
*  "ptolemy.ptII.copernicusIterations" Java property is set, then          <a name="171149"> </a>
*  the value of that property is used as the number of                     <a name="171150"> </a>
*  iterations. <a name="171086"> </a>
</pre>

<p>
  <a name="17.2.devel"> </a>So, we can either edit the model and add a copernicus_iterations parameter, or else we can run copernicus with the ptolemy.ptII.copernicusIterations property set. In this example, we set the property and rerun copernicus
</p>


<p>
  <a name="171305"> </a>:
</p>

<pre>
export USERJAVAPROPERTIES=-Dptolemy.ptII.copernicusIterations=100<a name="171161"> </a>
$PTII/bin/copernicus -codeGenerator java $PTII/ptolemy/domains/sdf/demo/OrthogonalCom/OrthogonalCom.xml<a name="171170"> </a>
<a name="171304"> </a>
</pre>

<p>
  <a name="171168"> </a>Then, we cd to the generated directory and re run the comparison:
</p>

<pre>
cd $PTII/ptolemy/copernicus/java/cg/OrthogonalCom<a name="171180"> </a>
make compareAll<a name="171181"> </a>
</pre>

<p>
  <a name="171283"> </a>The results is that the different versions of the models run for 1000 iterations and we can compare the times:

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><a name="171254"> </a><font face="Helvetica">Table 11:  Jar file sizes and elapsed time</font></i></b></caption>
  <tr align="center" bgcolor="#CCCCCC">
    <th><a name="171260"> </a>Optimizations</th>
    <th><a name="171262"> </a>Jar file size</th>
    <th><a name="171264"> </a>Time</th>
  </tr>
  <tr>
    <td><a name="171266"> </a>interpreted code with treeshaking</td>
    <td><a name="171268"> </a>~750 k bytes</td>
    <td><a name="171270"> </a>4787 ms.</td>
  </tr>
  <tr>
    <td><a name="171272"> </a>copernicus generated code with treeshaking</td>
    <td><a name="171274"> </a>~77 k bytes</td>
    <td><a name="171276"> </a>230 ms.</td>
  </tr>
  <tr>
    <td><a name="171278"> </a>copernicus generated code with treeshaking and obfuscation</td>
    <td><a name="171280"> </a>~40 k bytes</td>
    <td><a name="171282"> </a>217 ms.</td>
  </tr>
</table>




</p>


<p>
  <a name="171288"> </a>Note that these results are not particularly rigorous, see [112] for a more formal analysis. 
</p>


<p>
  <a name="171185"> </a>
</p>


<h3>
  <a name="170940"> </a>7.3   C Code Generator
</h3>


<a name="165981"> </a>The C code generator [137] is implemented by the copernicus.c package. This code generator targets the generation of self-contained C code by post-processing the result of the Java code generator, and performing further code size optimizations. The C code generator leverages the Soot compiler framework to parse the bytecode representation for each class to be compiled.<br>


<p>
  <a name="165982"> </a>Within the Ptolemy II framework, the C code generator takes the class files generated by copernicus.java as input.The C code generator can also be used as a stand-alone Java-to-C compiler to generate C code for arbitrary Java programs.
</p>


<h4>
  <a name="165983"> </a>7.3.1   Code Generation
</h4>


<a name="165984"> </a>The main steps in the code generation algorithm are as follows:<br>

<ol type="1">
  <li value="1"><a name="165985"> </a>Read in main class file using Soot.
  <li value="2"><a name="165986"> </a>Use CallGraphPruner to compute the set of required methods, classes and fields.
  <li value="3"><a name="165987"> </a>Generate .c and .h files for the main class(es).
  <li value="4"><a name="165988"> </a>Generate a .c file containing code for initialization and setup.
  <li value="5"><a name="165989"> </a>Generate .c and .h files for all required Java library classes in a separate directory (named j2c_lib by default). Note that these only contain code for required methods and fields, to minimize code size. The code for each method is generated by converting the jimple statements for the method's body atomically into the appropriate C constructs.
  <li value="6"><a name="165990"> </a>Generate a makefile for compiling the code into an executable.
</ol>

<h4>
  <a name="165991"> </a>7.3.2   The Code Pruning Algorithm
</h4>


<p>
  <a name="165992"> </a>The Soot framework is used to create a Call Graph of the application. This is a graph with methods as the nodes, and calls from one method to another as directed edges.
</p>


<p>
  <a name="165993"> </a>At first glance, it seems that the transitive closure of the methods in the main class should represent all methods that can be called. However, this is not so, because the first time the field or method of a class is referenced, its class initialization method is also invoked, and this can reference other methods or fields in turn.
</p>


<p>
  <a name="165994"> </a>The method call graph also contains an edge from a method to every possible target of method calls in it. The number of such targets can be large for polymorphic method calls. A more sophisticated analysis can trim the method call graph by removing some of the edges corresponding to polymorphic invocations.
</p>


<p>
  <a name="165995"> </a>We use Soot's Variable Type Analysis (VTA) to perform this call graph trimming. This analysis computes the possible runtime types of each variable using a reaching type analysis, and uses this information to remove spurious edges.
</p>


<h5>
  <a name="165996"> </a><i>Computing the Set of Required Entities</i>
</h5>


<p>
  <a name="165997"> </a>
</p>


<p>
  <a name="165998"> </a>From the analysis mentioned above, the set of all possible required classes, methods and fields (collectively grouped as <i>entities</i>) can be statically computed. We use a set of rules to determine which classes are required. 
</p>

<ol type="1">
  <li value="1"><a name="165999"> </a>A set of compulsory entities is always required. This includes the System.initializeSystemClass()</font> method, all methods and fields of the java.lang.Object class (since it is the global superclass) and the main method of the main class to be compiled.
  <li value="2"><a name="166000"> </a>If a method<i> m</i> is required, the following also become required: the class declaring <i>m</i>, all methods that may possibly be called by <i>m</i>, all fields accessed in the body of <i>m</i>, the classes of all local variables and arguments of m, the classes corresponding to all exceptions that may be caught or thrown by <i>m</i>, and the method corresponding to <i>m</i> in all required subclasses of the class declaring <i>m</i>.
  <li value="3"><a name="166001"> </a>If a field <i>f</i> is required, the following also become required: the class declaring <i>f</i>, the class corresponding to the type of <i>f</i> (if any) and the field corresponding to <i>f</i> in all required subclasses of the class declaring it.
  <li value="4"><a name="166002"> </a>If a class <i>c</i> is required, the following also become required: all superclasses of <i>c</i>, the class initialization method of <i>c</i>, and the instance initialization method of <i>c</i>.
</ol>

<p>
  <a name="166003"> </a>Interfaces are treated as classes. A worklist-based algorithm can be used to add to the set of required entities until no additional entities can be found by application of these rules. Together, rules 2, 3 and 4 encapsulate all possible dependencies between entities. This makes the set of required entities self-contained.
</p>


<h4>
  <a name="166004"> </a>7.3.3   Limitations
</h4>


<a name="166005"> </a>The restrictions imposed C-based static compilation strategy are:<br>

<dl>
  <dt> <a name="166006"> </a>	 Dynamic Loading and Reflection are not supported.
  <dt> <a name="166007"> </a>	 The generated executable runs as a user process, so applications that rely on a JVM as a buffer between them and the platform for security cannot be guaranteed to run correctly.
</dl>

<p>
  <a name="166008"> </a>The further limitations of the current implementation are:
</p>

<dl>
  <dt> <a name="166009"> </a>	 No support for threads.
  <dt> <a name="166010"> </a>	 GUI-based functions are currently not implemented.
  <dt> <a name="166011"> </a>	 Certain java classes are not currently supported, because the native methods for them need to be coded. The list of these is maintained in the OverriddenMethodGenerator class.
</dl>

<h4>
  <a name="166012"> </a>7.3.4   Options
</h4>


<a name="166013"> </a>There are a number of command-line options available:<br>

<dl>
  <dt> <a name="166014"> </a>	 verbose: <i>true/false</i> Turns verbose mode on or off. 
  <dt> <a name="166015"> </a>	 compileMode: <i>singleClass</i> compiles only the given class, <i>full</i> generates all required files. 
  <dt> <a name="166016"> </a>	 pruneLevel: <i>0</i> no code pruning done, <i>1</i> code pruning done by CallGraphPruner. 
  <dt> <a name="166017"> </a>	 vta: <i>true/false</i> Whether or not to perform Variable Type Analysis.
  <dt> <a name="166018"> </a>	 lib: the path to the directory where library of generated files should be stored. 
  <dt> <a name="166019"> </a>	 gcDir: stores the path to the directory containing the garbage collector. Not using this option turns the collector off. 
  <dt> <a name="166020"> </a>	 target: The target platform. A blank refers to a generic POSIX-like system including Cygwin installations.<i> C6000</i> The TMS320C6xxx series of processors. 
  <dt> <a name="166021"> </a>	 runtimeDir: The path to the runtime directory. 
  <dt> <a name="166022"> </a>	 ptII: The path to the ptII directory. 
  <dt> <a name="166023"> </a>	 compulsoryMethods: A semicolon-separated list of methods for which code must always be generated. If more than one such entity is to be specified, the entire list may be enclosed within double quotes. The complete method subsignature of the form <i>returnType class.method(arg1, arg2, ...)</i> must be specified. 
  <dt> <a name="166024"> </a>	 cFlags: The GCC flags to be used in the makefile. 
  <dt> <a name="166025"> </a>	 reportEntities: <i>true/false</i> whether to output a summary of the number of classes, methods and fields (entities) generated.
</dl>

<h4>
  <a name="166026"> </a>7.3.5   Directory structure
</h4>


<a name="166027"> </a>The main subdirectories in copernicus.c are:<br>

<dl>
  <dt> <a name="166028"> </a>	 runtime: Contains a small amount of C code that provides basic functionality. This is linked in while generating the executables.
  <dt> <a name="166029"> </a>	 runtime/native_bodies: C code for native methods.
  <dt> <a name="166030"> </a>	 runtime/over_bodies: C code for methods with custom code.
  <dt> <a name="166031"> </a>	 test: Various test programs.
  <dt> <a name="166032"> </a>	 testOutput: Auto-generated C code.
</dl>

<h4>
  <a name="166033"> </a>7.3.6   Code Flow
</h4>


<a name="166034"> </a>The following UML diagram shows the various classes that populate copernicus.c. This is a relatively complex package, so many implementation details have been abstracted out. Complete descriptions of all classes and their members are available in the API, and we attempt to provide an insight into the higher-level structure of the package here.<br>

<dl>
  <dt> <a name="166035"> </a>	 Protected and private methods are not shown, unless they are central to the functionality of the class.
  <dt> <a name="166036"> </a>	 Unimportant external superclasses are not shown here.
  <dt> <a name="166037"> </a>	 Public methods that are not central to the operation of the class are omitted.
  <dt> <a name="166038"> </a>	 CSwitch has a caseXXX method for each kind of Jimple statement XXX. These are shown as a single entry in the figure.
  <dt> <a name="166039"> </a>	 The methods in ExceptionTracker are omitted. This class tracks the current exceptions and works closely with MethodCodeGenerator. However, the C implementation of Java exceptions is complex and is not discussed here.
</dl>

<p>
  <a name="166040"> </a>
</p>


<p>
  <a name="166041"> </a>The dashed arrows in the UML diagram represent the coarse-grained code flow in copernicus.c. The entry class is JavaToC when used in stand-alone mode, and Main when copernicus.c is used as a ptolemy code-generation back-end.
</p>


<p>
  <a name="166042"> </a>JavaToC reads in a Java class file and implicitly converts it to the Soot Jimple format. Then it calls RequiredFileGenerator, MakeFileGenerator and MainFileGenerator.
</p>


<p>
  <a name="166043"> </a>RequiredFileGenerator uses CallGraphPruner to compute the set of required classes, methods and fields. Then it calls ClassFileGenerator, HeaderFileGenerator and StubFileGenerator on each required class.
</p>


<p>
  <a name="166044"> </a>ClassFileGenerator creates the .c file containing all the function definitions. Each of these function definitions is created by MethodCodeGenerator. MethodCodeGenerator calls CSwitch on each Jimple statement to find its C equivalent.
</p>


<p>
  <a name="166045"> </a>HeaderFileGenerator creates the .h file corresponding to the class. This consists of a class-specific C structure for the class (created by ClassStructureGenerator), an instance-specific C structure for the class (created by InstanceStructureGenerator) and various function declarations. MethodListGenerator is the class that "understands" inheritance to create the lists of constructors, inherited methods, new methods, private methods, etc.
</p>


<p>
  <a name="166046"> </a>StubFileGenerator creates a small "stub" of prototype declarations useful for breaking circular dependencies between classes.
</p>


<p>
  <a name="166047"> </a>MakeFileGenerator creates a makefile proving rules for compiling the generated C code into an executable.
</p>


<p>
  <a name="166048"> </a>MainFileGenerator creates a file that contains the C "main" method, which performs initialization functions, wraps the command-line arguments into the C equivalent of a Java string array and passes them to the "java" main method.
</p>


<p>
  <a name="166049"> </a>In addition, CNames converts Java names into unique legal C names, InterfaceLookupGenerator takes care of resolving interface method invocations, FileHandler provides file I/O utilities, Options stores configuration information, Context handles useful global information, NativeMethodGenerator handles native methods and OverriddenMethodGenerator allows user-defined code to override the compiler.
</p>


<p>
  <a name="166142"> </a><img src="img/copernicusa.gif" height="816" width="599" align="left" border="0" hspace="0" vspace="0">

</p>


<h4>
  <a name="166050"> </a>7.3.7   HOW TOs
</h4>


<h5>
  <a name="166051"> </a><i>Generating an executable from a Java ClassFile</i>
</h5>


<a name="166052"> </a><br>


<p>
  <a name="166053"> </a>Put the classfile in c/test
</p>


<p>
  <a name="166054"> </a>cd test
</p>


<p>
  <a name="166055"> </a>java -classpath $classpath ptolemy.copernicus.c.JavaToC $classpath 	 &lt;className&gt;
</p>


<p>
  <a name="166056"> </a>(note that the classpath has to be specified twice)
</p>


<p>
  <a name="166057"> </a>make -s -f &lt;classname&gt;.make
</p>


<h5>
  <a name="166058"> </a><i>Generating Code from a MoML model</i>
</h5>


<p>
  <a name="166059"> </a>
</p>


<p>
  <a name="166060"> </a>Move the xml model to c/test/simple
</p>


<p>
  <a name="166061"> </a>java ptolemy.copernicus.kernel.Copernicus -codeGenerator c &lt;model&gt;.xml
</p>


<h5>
  <a name="166062"> </a><i>Writing Code for a Native Method</i>
</h5>


<a name="166063"> </a><br>


<p>
  <a name="166064"> </a>Java requires certain <i>native</i> methods, which are methods implemented in platform-dependent code, typically written in another programming language such as C. The C code generator allows the user to specify C code for the body of any native method. At compile-time, this is integrated with the generated C code, allowing any C native methods to be fully supported. To do this:
</p>

<ol type="1">
  <li value="1"><a name="166065"> </a>Find the C name of that method (say <i>f00xx_abc</i>).
  <li value="2"><a name="166066"> </a>Create a file by this name (<i>f00xx_abc.c</i>) in runtime/native_bodies, containing the code for that method.
  <li value="3"><a name="166067"> </a>Add this method to the list of native methods in NativeMethodGenerator.
</ol>

<h5>
  <a name="166068"> </a><i>Overriding Code for an Existing Method</i>
</h5>


<a name="166069"> </a><br>


<p>
  <a name="166070"> </a>It is also possible to override the C code generator and write custom C code for a given method instead. To do this:
</p>

<ol type="1">
  <li value="1"><a name="166071"> </a>Find the C name of that method (say <i>f00xx_abc</i>).
  <li value="2"><a name="166072"> </a>Create a file by this name (<i>f00xx_abc.c</i>) in runtime/over_bodies, containing the code for that method.
  <li value="3"><a name="166073"> </a>Add this method to the list of overridden methods in OverriddenMethodGenerator.
</ol>

<p>
  <a name="166074"> </a>Note that the term <i>overridden</i> in this context does not refer to methods that are overridden through inheritance in Java classes.
</p>


<h5>
  <a name="166075"> </a><i>Suppressing Code Generation for a Method, Class or Package</i>
</h5>


<a name="166076"> </a><br>


<p>
  <a name="166077"> </a>To "turn off" code generation for a method, override it without creating code for it in runtime/over_bodies. For an entire class or package, list it in OverriddenMethodGenerator.isOverriddenClass(). This will generate methods with blank bodies and trivial return statements which will return 0 or NULL. 
</p>


<p>
  <a name="167212"> </a>CAVEAT: Make sure that the returned values are not used. Referencing a NULL pointer will cause the executable to throw a segmentation fault.
</p>


<h3>
  <a name="167213"> </a>7.4   Applet Code Generator
</h3>


<p>
  <a name="166584"> </a>The Applet code generator takes a model and creates HTML files for use as a web based applet.
</p>


<p>
  <a name="166587"> </a>The applet generator reads template files that end in .in from $PTII/ptolemy/copernicus/applet substitutes keywords and writes out the files in the destination directory. Users may modify the template files to match their local setup
</p>


<p>
  <a name="166593"> </a>Making an applet available via the web is somewhat complex because the Java Plugin has two sections, one for Netscape, the other for Internet Explorer, so changes to the htm files must be replicated in both sections. The codebase and the location of the jar files also add to the problems.
</p>


<p>
  <a name="166599"> </a>If a model is named MyModel, and the user selects foo.bar as the package, then saving the model as an applet will create a directory called $PTII/foo/bar/MyModel and create the following files for that model:
</p>


<p>
  <a name="166604"> </a>   
</p>


<p>
  <a name="166605"> </a>   makefile
</p>


<p>
  <a name="166606"> </a>          make demo will run appletviewer on the HTML files
</p>


<p>
  <a name="166607"> </a>          
</p>


<p>
  <a name="166608"> </a>   MyModel.xml
</p>


<p>
  <a name="166609"> </a>          A local copy of the model
</p>


<p>
  <a name="166610"> </a>          
</p>


<p>
  <a name="166611"> </a>   MyModel.htm
</p>


<p>
  <a name="166612"> </a>          An HTML file containing the code necessary to MyModel.xml
</p>


<p>
  <a name="166613"> </a>          
</p>


<p>
  <a name="166614"> </a>   MyModelVergil.htm
</p>

<dl>
  <dt> <a name="166615"> </a>          An HTML file containing the code necessary to display MyModel.xml graphically, using ptolemy.vergil.VergilApplet and in text format
</dl>

<h4>
  <a name="166618"> </a>7.4.1   Applet Code Generation demonstrations
</h4>


<a name="167739"> </a>Below are several demonstrations of the applet code generator. The code generator graphical user interface is difficult to use, so we recommend using the copernicus command instead of using the code generator GUI.<br>


<p>
  <a name="167895"> </a>The OrthogonalCom model generates prints output to standard out, so when this model is run as an applet, the output will appear in the Java Plugin console. Instead, we generate an applet for the Butterfly model, which will generate display a nice plot. Note that the Butterfly model uses the Expression actor so that while we cannot use deep code generation on the Butterfly actor, we can generate an applet for this model.
</p>


<h5>
  <a name="167907"> </a><i>Copernicus command - create applet within the Ptolemy tree</i>
</h5>


<a name="167908"> </a><br>


<a name="167909"> </a>To create the html file and open it with the browser:<br>

<pre>
cd $PTII/ptolemy/domains/sdf/demo/Butterfly<a name="167910"> </a>
$PTII/bin/copernicus -codeGenerator applet Butterfly.xml<a name="167911"> </a>
</pre>

<p>
  <a name="167914"> </a>The HTML can be found in $PTII/ptolemy/copernicus/applet/cg/Butterfly.
</p>


<h5>
  <a name="167743"> </a><i>Applet code generator GUI - create applet within the Ptolemy Tree</i>
</h5>


<a name="167761"> </a><br>


<a name="168316"> </a>If you would like to generate an applet in a directory within the Ptolemy tree using the experimental code generation GUI, follow these steps:<br>

<ol type="1">
  <li value="1"><a name="168314"> </a>Open up the SDF Butterfly Model at $PTII/ptolemy/domains/sdf/demo/Butterfly/Butterfly.xml.
  <li value="2"><a name="167794"> </a>Select View -&gt; Code Generator
  <li value="3"><a name="166628"> </a>Change the CodeGenerator combo box from java to applet
  <li value="4"><a name="166629"> </a>Hit the Generate Button
  <li value="5"><a name="166630"> </a>The code generator will invoke an separate java process that generates code in $PTII/ptolemy/copernicus/applet/cg/Butterfly and then opens the generated file with the browser.
</ol>

<h5>
  <a name="167927"> </a><i>Copernicus command - create applet outside the Ptolemy tree</i>
</h5>


<a name="167928"> </a><br>


<p>
  <a name="167943"> </a>Usually, one wants to put an applet on a website. Ptolemy applets require jar files for the runtime environment, so the applet code generator will copy the necessary jar files if the value of the ptIIUserDirectory parameter is outside the $PTII directory.
</p>

<ol type="1">
  <li value="1"><a name="167929"> </a>If you built Ptolemy II from source, generate Ptolemy II jar files by running
</ol>
<pre>
cd $PTII<a name="167930"> </a>
make install<a name="167931"> </a>
</pre>
<ol type="1">
  <li value="2"><a name="167932"> </a>Create the target directory:
</ol>
<pre>
mkdir c:/tmp/ptIIapplet/Butterfly<a name="168234"> </a>
</pre>
<ol type="1">
  <li value="3"><a name="168230"> </a>Invoke copernicus:
</ol>
<pre>
cd $PTII/ptolemy/domains/sdf/demo/Butterfly<a name="167933"> </a>
$PTII/bin/copernicus -codeGenerator applet -ptIIUserDirectory \<a name="167934"> </a>
       c:/tmp/ptIIapplet -targetPath Butterfly Butterfly.xml<a name="168226"> </a>
</pre>

<p>
  <a name="167936"> </a>Note that the copernicus command should be typed in on one line.
</p>


<h5>
  <a name="167755"> </a><i>Applet code generator GUI - create applet outside the Ptolemy tree</i>
</h5>


<a name="167780"> </a><br>


<a name="167777"> </a>If you would like to generate an applet in a directory outside of the Ptolemy tree using the experimental code generation GUI, follow these steps:<br>

<ol type="1">
  <li value="1"><a name="166635"> </a>If you built Ptolemy II from source, generate Ptolemy II jar files by running
</ol>
<pre>
cd $PTII<a name="167830"> </a>
make install<a name="167831"> </a>
</pre>
<ol type="1">
  <li value="2"><a name="168252"> </a>Create the target directory:
</ol>
<pre>
mkdir c:/tmp/ptIIapplet/Butterfly<a name="168253"> </a>
</pre>
<ol type="1">
  <li value="3"><a name="168250"> </a>Open up the SDF Butterfly Model at $PTII/ptolemy/domains/sdf/demo/Butterfly/Butterfly.xml
  <li value="4"><a name="167883"> </a>Select View -&gt; Code Generator
  <li value="5"><a name="166637"> </a>Change the CodeGenerator combo box from java to applet
  <li value="6"><a name="166638"> </a>Change the ptIIUserDirectory to the directory where you would like the applet to be created, for example
</ol>
<pre>
c:/tmp/ptapplet<a name="167819"> </a>
</pre>

<p>
  <a name="166642"> </a>       Note that the directory must already exist. If it does not exist, then the default directory will automatically be used.
</p>

<ol type="1">
  <li value="7"><a name="166644"> </a>Change the targetPath to the string
</ol>
<pre>
$modelName<a name="167808"> </a>
</pre>
<ol type="1">
  <li value="8"><a name="166646"> </a>Change the modelName parameter to
</ol>
<pre>
Butterfly<a name="168262"> </a>
</pre>
<ol type="1">
  <li value="9"><a name="168258"> </a>Hit the Parameters button, which will update the parameters and display their values.
  <li value="10"><a name="167531"> </a>Hit the Generate Button
  <li value="11"><a name="166649"> </a>The code generator will invoke an separate java process that generates an applet and then invokes the browser on the generated HTML code.
</ol>

<h4>
  <a name="168287"> </a>7.4.2     Applet Limitations
</h4>


<p>
  <a name="166656"> </a>Under Web Start, you may need to add classes to the necessaryClasses parameter so that the necessaryClassPath parameter will get updated with the appropriate jar files and passed to the subprocess that invokes the applet code generator. The reason this is necessary is because Web Start is invoked using a special class loader that accesses separate jar files in the Web Start cache. The applet code generator does not have direct access to the Web Start class loader, so we tell it what classes we need so that they can be added to the class path.
</p>

<dl>
  <dt> <a name="166666"> </a>	 It would be nice if the applet code generator would bundle up the necessary class files in a single jar file so that it was easier to install an applet.
  <dt> <a name="166669"> </a>	 The applet code generator could use tree shaking to create a much smaller jar file that contains only the classes that are used. One issue is that the user would need to exercise the applet by invoking all the features of the GUI, such as the plot format window.
  <dt> <a name="166676"> </a>	 The applet code generator should grab the top level text annotations from the MoML file and use them as comments.
</dl>

<p>
  <a name="166678"> </a>
</p>
</blockquote>



<table align="right" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td align="right"><font size="1">
    





    </td>
  </tr>
</table>

</body>
</html>
