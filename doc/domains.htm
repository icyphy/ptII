<!-- $Id$ -->
<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>Ptolemy II Domains</title>
<link href="default.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Ptolemy II Domains</h1>
<ul>
<li> <a href="#csp">CSP (Communicating Sequential Processes)</a>
<li> <a href="#ct">CT (Continuous Time)</a>
<li> <a href="#de">DE (Discrete Events)</a>
<li> <a href="#dde">DDE (Distributed Discrete Events)</a>
<li> <a href="#dt">DT (Discrete Time)</a>
<li> <a href="#fsm">FSM (Finite State Machi
<li> <a href="#pn">PN (Process Networks)</a>
<li> <a href="#sdf">SDF (Synchronous Dataflow)</a>
<li> <a href="#sr">SR (Synchronous/Reactive)</a>
</ul>
<h2><a name="csp">CSP</a></h2>

<p>
In the CSP domain (communicating sequential processes), created by Neil
Smyth, actors represent concurrently executing processes,
implemented as Java threads. These processes communicate by atomic,
instantaneous actions called rendezvous (or sometimes, synchronous
message passing). If two processes are to communicate, and one reaches
the point first at which it is ready to communicate, then it stalls
until the other process is ready to communicate. “Atomic” means that
the two processes are simultaneously involved in the exchange, and that
the exchange is initiated and completed in a single uninterruptable
step. Examples of rendezvous models include Hoare’s communicating
sequential processes (CSP) and Milner’s calculus of communicating
systems (CCS). This model of computation has been realized in a
number of concurrent programming languages, including Lotos and Occam.

<p>
Rendezvous models are particularly well-matched to applications where
resource sharing is a key element, such as client-server database
models and multitasking or multiplexing of hardware resources. A key
feature of rendezvous-based models is their ability to cleanly model
nondeterminate interactions. The CSP domain implements both conditional
send and conditional receive. It also includes an experimental timed
extension.

<h2><a name="ct">CT</a></h2>
<p>

In the CT domain (continuous time), created Jie Liu, actors
represent components that interact via continuous-time signals. Actors
typically specify algebraic or differential relations between inputs
and outputs. The job of the director in the domain is to find a
fixed-point, i.e., a set of continuous-time functions that satisfy all
the relations.

<p>
The CT domain includes an extensible set of differential equation
solvers. The domain, therefore, is useful for modeling physical systems
with linear or nonlinear algebraic/differential equation descriptions,
such as analog circuits and many mechanical systems. Its model of
computation is similar to that used in Simulink, Saber, and VHDL-AMS,
and is closely related to that in Spice circuit simulators.

<p>
Embedded systems frequently contain components that are best modeled
using differential equations, such as MEMS and other mechanical
components, analog circuits, and microwave circuits. These components,
however, interact with an electronic system that may serve as a
controller or a recipient of sensor data. This electronic system may be
digital. Joint modeling of a continuous subsystem with digital
electronics is known as mixed signal modeling. The CT domain is
designed to interoperate with other Ptolemy domains, such as DE, to
achieve mixed signal modeling. To support such modeling, the CT domain
models of discrete events as Dirac delta functions. It also includes
the ability to precisely detect threshold crossings to produce discrete
events. Physical systems often have simple models that are only valid
over a certain regime of operation. Outside that regime, another model
may be appropriate. A modal model is one that switches between these
simple models when the system transitions between regimes. The CT
domain interoperates with the FSM domain to create modal models.

<h2><a name="de">DE</a></h2>
<p>
In the discrete-event (DE) domain, created by Lukito Muliadi, the
actors communicate via sequences of events placed in time, along a real
time line. An event consists of a value and time stamp. Actors can
either be processes that react to events (implemented as Java threads)
or functions that fire when new events are supplied. This model of
computation is popular for specifying digital hardware and for
simulating telecommunications systems, and has been realized in a large
number of simulation environments, simulation languages, and hardware
description languages, including VHDL and Verilog.

<p>
DE models are excellent descriptions of concurrent hardware, although
increasingly the globally consistent notion of time is problematic. In
particular, it over-specifies (or over-models) systems where
maintaining such a globally consistent notion is difficult, including
large VLSI chips with high clock rates. Every event is placed precisely
on a globally consistent time line.

<p>
The DE domain implements a fairly sophisticated discrete-event
simulator. DE simulators in general need to maintain a global queue of
pending events sorted by time stamp (this is called a priority queue).
This can be fairly expensive, since inserting new events into the list
requires searching for the right position at which to insert it. The DE
domain uses a calendar queue data structure for the global event
queue. A calendar queue may be thought of as a hashtable that uses
quantized time as a hashing function. As such, both enqueue and dequeue
operations can be done in time that is independent of the number of
events in the queue.
<p>

In addition, the DE domain gives deterministic semantics to
simultaneous events, unlike most competing discrete-event simulators.
This means that for any two events with the same time stamp, the order
in which they are processed can be inferred from the structure of the
model. This is done by analyzing the graph structure of the model for
data precedences so that in the event of simultaneous time stamps,
events can be sorted according to a secondary criterion given by their
precedence relationships. VHDL, for example, uses delta time to
accomplish the same objective.

<h2><a name="dde">DDE</a></h2>
<p>

The distributed discrete-event (DDE) domain, created by John Davis, can
be viewed either as a variant of DE or as a variant of PN (described
below). Still highly experimental, it addresses a key problem with
discrete-event modeling, namely that the global event queue imposes a
central point of control on a model, greatly limiting the ability to
distribute a model over a network. Distributing models might be
necessary either to preserve intellectual property, to conserve network
bandwidth, or to exploit parallel computing resources.
<p>

The DDE domain maintains a local notion of time on each connection
between actors, instead of a single globally consistent notion of time.
Each actor is a process, implemented as a Java thread, that can advance
its local time to the minimum of the local times on each of its input
connections. The domain systematizes the transmission of null events,
which in effect provide guarantees that no event will be supplied with
a time stamp less than some specified value.

<h2><a name="dt">DT</a></h2>
<p>

The discrete-time (DT) domain, which has not been written yet, will
extend the SDF domain (described below) with a notion of time between
tokens. Communication between actors takes the form of a sequence of
tokens where the time between tokens is uniform. Multirate models,
where distinct connections have distinct time intervals between tokens,
will be supported.

<h2><a name="fsm">FSM</a></h2>
<p>

The finite-state machine (FSM) domain, written by Xiaojun Liu (but not
yet released), is radically different from the other Ptolemy II
domains. The entities in this domain represent not actors but rather
state, and the connections represent transitions between states.
Execution is a strictly ordered sequence of state transitions. The FSM
domain leverages the built-in expression language in Ptolemy II to
evaluate guards, which determine when state transitions can be taken.
<p>

FSM models are excellent for control logic in embedded systems,
particularly safety-critical systems. FSM models are amenable to
in-depth formal analysis, and thus can be used to avoid surprising
behavior.
<p>

FSM models have a number of key weaknesses. First, at a very
fundamental level, they are not as expressive as the other models of
computation described here. They are not sufficiently rich to describe
all partial recursive functions. However, this weakness is acceptable
in light of the formal analysis that becomes possible. Many questions
about designs are decidable for FSMs and undecidable for other models
of computation. A second key weakness is that the number of states can
get very large even in the face of only modest complexity. This makes
the models unwieldy.
<p>

The latter problem can often be solved by using FSMs in combination
with concurrent models of computation. This was first noted by David
Harel, who introduced that Statecharts formalism. Statecharts combine a
loose version of synchronous-reactive modeling (described below) with
FSMs. FSMs have also been combined with differential equations,
yielding the so-called hybrid systems model of computation.
<p>

The FSM domain in Ptolemy II can be hierarchically combined with other
domains. We call the resulting formalism “*charts” (pronounced
“starcharts”) where the star represents a wildcard. Since most other
domains represent concurrent computations, *charts model concurrent
finite state machines with a variety of concurrency semantics. When
combined with CT, they yield hybrid systems and modal models. When
combined with SR (described below), they yield something close to
Statecharts. When combined with process networks, they resemble SDL.

<h2><a name="pn">PN</a></h2>
<p>

In the process networks (PN) domain, created by Mudit Goel,
processes communicate by sending messages through channels that can
buffer the messages. The sender of the message need not wait for the
receiver to be ready to receive the message. This style of
communication is often called asynchronous message passing. There are
several variants of this technique, but the PN domain specifically
implements one that ensures determinate computation, namely Kahn
process networks.
<p>

In the PN model of computation, the arcs represent sequences of data
values (tokens), and the entities represent functions that map input
sequences into output sequences. Certain technical restrictions on
these functions are necessary to ensure determinacy, meaning that the
sequences are fully specified. In particular, the function implemented
by an entity must be prefix monotonic. The PN domain realizes a
subclass of such functions, first described by Kahn and MacQueen,
where blocking reads ensure monotonicity.
<p>

PN models are loosely coupled, and hence relatively easy to parallelize
or distribute. They can be implemented efficiently in both software and
hardware, and hence leave implementation options open. A key weakness
of PN models is that they are awkward for specifying control logic,
although much of this awkwardness may be ameliorated by combining them
with FSM.
<p>

The PN domain in Ptolemy II has a highly experimental timed extension.
This adds to the blocking reads a method for stalling processes until
time advances. We anticipate that this timed extension will make
interoperation with timed domains much more practical.

<h2><a name="sdf">SDF</a></h2>
<p>

The synchronous dataflow (SDF) domain, created by Steve Neuendorffer,
handles regular computations that operate on streams. Dataflow models,
popular in signal processing, are a special case of process networks.
Dataflow models
construct processes of a process network as sequences of atomic actor
firings. Synchronous dataflow (SDF) is a particularly restricted
special case with the extremely useful property that deadlock and
boundedness are decidable. Moreover, the schedule of firings, parallel
or sequential, is computable statically, making SDF an extremely useful
specification formalism for embedded real-time software and for
hardware.
<p>

Certain generalizations sometimes yield to similar analysis. Boolean
dataflow (BDF) models sometimes yield to deadlock and boundedness
analysis, although fundamentally these questions are undecidable.
Dynamic dataflow (DDF) uses only run-time analysis, and thus makes no
attempt to statically answer questions about deadlock and boundedness.
Neither a BDF nor DDF domain has yet been written in Ptolemy II.
Process networks (PN) serves in the interrim to handle computations
that do not match the restrictions of SDF.

<h2><a name="sr">SR</a></h2>
<p>

In the synchronous/reactive (SR) model of computation , the arcs
represent data values that are aligned with global clock ticks. Thus,
they are discrete signals, but unlike discrete time, a signal need not
have a value at every clock tick. The entities represent relations
between input and output values at each tick, and are usually partial
functions with certain technical restrictions to ensure determinacy.
Examples of languages that use the SR model of computation include
Esterel, Signal, Lustre, and Argos.
<p>
SR models are excellent for applications with concurrent and complex
control logic. Because of the tight synchronization, safety-critical
real-time applications are a good match. However, also because of the
tight synchronization, some applications are overspecified in the SR
model, limiting the implementation alternatives. Moreover, in most
realizations, modularity is compromised by the need to seek a global
fixed point at each clock tick. An SR domain has not yet been
implemented in Ptolemy II, although the methods used by Stephen Edwards
in Ptolemy Classic can be adapted to this purpose.

</body>
</html>
