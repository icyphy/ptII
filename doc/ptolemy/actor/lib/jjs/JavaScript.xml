<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="JavaScript" class="ptolemy.actor.lib.jjs.JavaScript">
  <description>
An actor whose functionality is given in JavaScript using the accessor&#10;   interface defined at&#10;   &lt;a href=&quot;https://accessors.org&quot;&gt;https://accessors.org&lt;/a&gt;.&#10;   Refer to that page for complete documentation of the&#10;   functions and modules that are provided to the script.&#10;   &lt;p&gt;&#10;   The script defines one or more functions that configure this actor&#10;   with ports and parameters, initialize the actor,&#10;   perform runtime functions such as reacting to inputs and producing outputs,&#10;   and perform finalization (wrapup) functions. The script may be provided&#10;   as the textual value of the &lt;i&gt;script&lt;/i&gt; parameter, or as an input&#10;   on the &lt;i&gt;script&lt;/i&gt; port. You can add to the script or modify&#10;   function definitions on each firing.&#10;   &lt;/p&gt;&lt;p&gt;&#10;   To use this actor, specify a script. Define an exports.setup() function&#10;   that declares inputs, outputs, and parameters.&#10;   &lt;/p&gt;&#10;   &lt;p&gt;&#10;   Your script can define zero or more of the following functions:&lt;/p&gt;&#10;   &lt;ul&gt;&#10;   &lt;li&gt; &lt;b&gt;exports.setup&lt;/b&gt;. This function is invoked when the script parameter&#10;   is first set and whenever the script parameter is updated. This function can&#10;   be used to configure this actor with input and output ports&#10;   and parameters.  For example,&#10;   &lt;pre&gt;&#10;     exports.setup = function() {&#10;         this.input('foo', {'type':'string'});&#10;     }&#10;   &lt;/pre&gt;&#10;   will create an input port named &quot;foo&quot; (if one does not already exist), and set&#10;   its type to &quot;string&quot;, possibly overriding any previously set data type.&#10;   The methods that are particularly useful to use in setup are input, output,&#10;   parameter, instantiate, and connect.&#10;   &lt;/li&gt;&#10;   &lt;li&gt; &lt;b&gt;exports.initialize&lt;/b&gt;. This function is invoked each time this actor&#10;   is initialized. This function should not read inputs or produce outputs.&#10;   &lt;/li&gt;&#10;   &lt;li&gt; &lt;b&gt;exports.fire&lt;/b&gt;. This function is invoked each time this actor fires.&#10;   It can read inputs using get() and write outputs using send().&#10;   This actor will consume at most one input token from each input port on&#10;   each firing, if one is available. Any number of calls to get() during the&#10;   firing will return the same consumed value, or will return null if there&#10;   is no available input on that firing.  If you want it to instead return&#10;   a previously read input, then mark the port persistent by giving it a&#10;   &lt;i&gt;value&lt;/i&gt; option when you call input() in setup().&#10;   This provides a default value and makes any newly provided values&#10;   persistent.&#10;   &lt;/li&gt;&#10;   &lt;li&gt; &lt;b&gt;exports.wrapup&lt;/b&gt;. This function is invoked at the end of execution of&#10;   of the model. It can read parameters, but normally should not&#10;   read inputs nor write outputs.&#10;   &lt;/li&gt;&#10;   &lt;/ul&gt;&#10;   These functions are fields of the exports object, as usual JavaScript CommonJS modules.&#10;   For example, to define the fire function, specify code like this:&#10;   &lt;pre&gt;&#10;      exports.fire = function () {... function body ...};&#10;   &lt;/pre&gt;&#10;   Alternatively, you can do&#10;   &lt;pre&gt;&#10;      var fire = function() {... function body ...};&#10;      exports.fire = fire;&#10;   &lt;/pre&gt;&#10;   When these functions are invoked, 'this' will be bound to the accessor instance.&#10;   &lt;p&gt;&#10;   Your script may also register &lt;b&gt;input handler&lt;/b&gt; functions by invoking&#10;   &lt;pre&gt;&#10;      var handle = this.addInputHandler(portName, function);&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;Normally you would do this in initialize().&#10;   The returned handle can be used to call this.removeInputHandler().&#10;   Handlers will be automatically&#10;   unregistered upon wrapup(), so unless you want to cancel a handler earlier,&#10;   you do not need to explicitly unregister a handler.&#10;   &lt;/p&gt;&lt;p&gt;&#10;   The function specified as the input handler&#10;   will be invoked whenever the port receives a new input.&#10;   Note that the fire() function, if defined, will also be invoked (after the&#10;   specified function) and will see&#10;   the same input. If the specified function is null, then only the fire() function&#10;   will be invoked.&#10;   If the portName is null, then the handler will be invoked whenever&#10;   a new input arrives on any input, after which the fire function will&#10;   be invoked, if it exists.&#10;   &lt;/p&gt;&#10;   &lt;p&gt;&#10;   Often you can leave the types of input and output ports unspecified.&#10;   Sometimes, however, you will need to explicitly set the types&#10;   of the output ports. You can do this by specifying a 'type'&#10;   option to the input() function in setup().&#10;   This implementation extends the accessor interface definition by allowing&#10;   any Ptolemy II type to be specified.&#10;   Keep in mind, however, that if you specify Ptolemy II types that are&#10;   not also accessor types, then your script will likely not work in some&#10;   other accessor host.&#10;   &lt;/p&gt;&#10;   &lt;p&gt;&#10;   You may also need to set the type of input ports. Usually, forward&#10;   type inference will work, and the type of the input port will be based&#10;   on the source of data. However,&#10;   if the input comes from an output port whose output is undefined,&#10;   such as JSONToToken, then you may want to&#10;   enable backward type inference, and specify here the type of input&#10;   that your script requires. Again, you do this with a 'type' option&#10;   to the input() function in setup().&#10;   &lt;/p&gt;&#10;   &lt;p&gt;&#10;   The accessor instance (the value of 'this' inside setup(), initialize(),&#10;   fire(), and wrapup()) has the following functions,  at least:&lt;/p&gt;&#10;   &lt;ul&gt;&#10;   &lt;li&gt; addInputHandler(function, input): Specify a function to invoke when the input&#10;        with name input (a string) receives a new input value. Note that after that&#10;        function is invoked, the accessor's fire() function will also be invoked,&#10;        if it is defined. If the specified function is null, then only the fire()&#10;        function will be invoked. If the input argument is null or omitted, then&#10;        the specified function will be invoked when any new input arrives to the&#10;        accessor. This function returns a handle that can be used to call removeInputHandler().&lt;/li&gt;&#10;   &lt;li&gt; get(portName): get an input from a port on channel 0.&lt;/li&gt;&#10;   &lt;li&gt; getParameter(parameterName): get a value from a parameter.&lt;/li&gt;&#10;   &lt;li&gt; removeInputHandler(handle): Remove the callback function with the specified handle&#10;        (returned by addInputHandler()). &lt;/li&gt;&#10;   &lt;li&gt; send(portName, value): send a value to an output port on channel 0&lt;/li&gt;&#10;   &lt;li&gt; setParameter(parameterName, value): set the value of a parameter of this JavaScript actor. &lt;/li&gt;&#10;   &lt;/ul&gt;&#10;   In addition, there are some top-level functions provided (which do not require a this prefix):&#10;   &lt;ul&gt;&#10;   &lt;li&gt; alert(string): pop up a dialog with the specified message.&lt;/li&gt;&#10;   &lt;li&gt; clearInterval(int): clear an interval with the specified handle.&lt;/li&gt;&#10;   &lt;li&gt; clearTimeout(int): clear a timeout with the specified handle.&lt;/li&gt;&#10;   &lt;li&gt; error(string): send a message to error port, or throw an exception if the error port is not connected.&lt;/li&gt;&#10;   &lt;li&gt; httpRequest(url, method, properties, body, timeout): HTTP request (GET, POST, PUT, etc.)&lt;/li&gt;&#10;   &lt;li&gt; localHostAddress(): If not in restricted mode, return the local host IP address as a string. &lt;/li&gt;&#10;   &lt;li&gt; print(string): print the specified string to the console (standard out).&lt;/li&gt;&#10;   &lt;li&gt; readURL(string): read the specified URL and return its contents as a string (HTTP GET).&lt;/li&gt;&#10;   &lt;li&gt; require(string): load and return a CommonJS module by name. See&#10;        &lt;a href=&quot;https://accessors.org&quot;&gt;https://accessors.org&lt;/a&gt; for&#10;        supported modules. See&#10;        &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules&quot;&gt;http://wiki.commonjs.org/wiki/Modules&lt;/a&gt;&#10;        for what a CommonJS module is.&lt;/li&gt;&#10;   &lt;li&gt; setInterval(function, long): set the function to execute after specified time and then periodically and return handle.&lt;/li&gt;&#10;   &lt;li&gt; setTimeout(function, long): set the function to execute after specified time and return handle.&lt;/li&gt;&#10;   &lt;/ul&gt;&#10;   &lt;p&gt;&#10;   Note that get() may be called within a JavaScript callback function. In that case,&#10;   if the callback function is invoked during the firing of this actor, then the get()&#10;   will return immediately. Otherwise, the get() method will request a firing of this&#10;   actor at the current time and block the JavaScript thread until this actor is in&#10;   that firing.  This way, this actor ensures that get() reads a proper input.&#10;   Note that although blocking JavaScript functions is not normally done, this actor&#10;   has its own JavaScript engine, so no other JavaScript anywhere in the model will be&#10;   affected. Those JavaScript threads are not blocked.&lt;/p&gt;&#10;   &lt;p&gt;&#10;   The following example script calculates the factorial of the input.&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   exports.setup = function() {&#10;       this.input('input', {'type':'int'});&#10;       this.output('output', {'type':'int'});&#10;   }&#10;   exports.fire = function() {&#10;       var value = this.get('input');&#10;       if (value &amp;lt; 0) {&#10;           error(&quot;Input must be greater than or equal to 0.&quot;);&#10;       } else {&#10;           var total = 1;&#10;           while (value &amp;gt; 1) {&#10;               total *= value;&#10;               value--;&#10;           }&#10;           this.send('output', total);&#10;       }&#10;   }&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;&#10;   Your script may also store values from one firing to the next, or from&#10;   initialization to firing.  For example,&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   exports.setup = function() {&#10;       this.output('output', {'type':'int'});&#10;   }&#10;   var init;&#10;   exports.initialize() = function() {&#10;       init = 0;&#10;   }&#10;   exports.fire = function() {&#10;       init = init + 1;&#10;       this.send('output', init);&#10;   }&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;will send a count of firings to the output named &quot;output&quot;.&lt;/p&gt;&#10;   &lt;p&gt;&#10;   In addition, the symbols &quot;actor&quot; and &quot;accessor&quot; are defined to be the instance of&#10;   this actor. In JavaScript, you can invoke methods on it.&#10;   (Note that in an accessor, which is implemented by a subclass of this&#10;   JavaScript actor, invocation of these functions is blocked for security reasons.)&#10;   For example, the JavaScript&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   actor.toplevel().getName();&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;will return the name of the top-level composite actor containing&#10;   this actor.&lt;/p&gt;&#10;   &lt;p&gt;&#10;   This actor can be used in any Ptolemy II model and can interact with native&#10;   Ptolemy II actors through its ports.&#10;   However, not all Ptolemy II data types translate naturally to&#10;   JavaScript types. Simple types will &quot;just work.&quot;&#10;   This actor converts Ptolemy types int,&#10;   double, string, and boolean to and from equivalent JavaScript&#10;   types when sending and getting to and from ports.&#10;   In addition, arrays at input ports are converted to native&#10;   JavaScript arrays. When sending a JavaScript array to an output&#10;   port, it will be converted into a Ptolemy II array, but keep in&#10;   mind that Ptolemy II arrays have a single element type, namely&#10;   a type that every element can be converted to. So, for example,&#10;   sending the JavaScript array [1, 2, &quot;foo&quot;] to an output port&#10;   will result in the Ptolemy II array {&quot;1&quot;, &quot;2&quot;, &quot;foo&quot;}, an array of strings.&#10;   If you wish to send a JavaScript array (or any other JavaScript&#10;   object) without modifying it, wrap it in an ObjectToken, as&#10;   in this example:&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   var ObjectToken = Java.type('ptolemy.data.ObjectToken');&#10;   exports.fire = function() {&#10;      var token = new ObjectToken([1, 2, 'foo']);&#10;      this.send('output', token);&#10;   }&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;The type of the output port will need to be set to object or general.&#10;   If you send this to another JavaScript actor, that actor can&#10;   retrieve the original JavaScript object as follows:&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   var ObjectToken = Java.type('ptolemy.data.ObjectToken');&#10;   exports.fire = function() {&#10;      var token = this.get('input');&#10;      var array = token.getValue();&#10;      ... operate on array, which is the original [1, 2, 'foo'] ...&#10;   }&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;&#10;   Ptolemy II records are also converted into&#10;   JavaScript objects, and JavaScript objects with enumerable&#10;   properties into records.&#10;   When converting a JavaScript object to a record, each enumerable&#10;   property (own or inherited) is included as a field in the resulting&#10;   record, with the value of the field is converted in the same manner.&#10;   To send a JavaScript object without any conversion, wrap it in an&#10;   ObjectToken as with the array example above.&#10;   &lt;/p&gt;&lt;p&gt;&#10;   These automatic conversions do not cover all cases of interest.&#10;   For example, if you provide inputs to this JavaScript actor that&#10;   cannot be converted, the script will see the&#10;   corresponding Token object.  For example, if you send&#10;   a number of type long to an input of a JavaScript actor,&#10;   the script (inside a fire() function):&lt;/p&gt;&#10;   &lt;pre&gt;&#10;      var value = this.get('input');&#10;      print(value.getClass().toString());&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;will print on standard out the string&lt;/p&gt;&#10;   &lt;pre&gt;&#10;      &quot;class ptolemy.data.LongToken&quot;&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;JavaScript does not have a long data type (as of this writing), so instead the&#10;   get() call returns a JavaScript Object wrapping the Ptolemy II&#10;   LongToken object. You can then invoke methods on that token,&#10;   such as getClass(), as done above.&lt;/p&gt;&#10;   &lt;p&gt;&#10;   When sending tokens using send(), you can explicitly prevent any conversions&#10;   from occurring by creating a Ptolemy II token explicitly and sending that.&#10;   For example, the JavaScript nested array [[1, 2], [3, 4]] will be automatically&#10;   converted into a Ptolemy II array of arrays {{1,2}, {3,4}}. If instead you want&#10;   to send a Ptolemy II integer matrix [1,2;3,4], you can do this:&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   var IntMatrixToken = Java.type('ptolemy.data.IntMatrixToken');&#10;   exports.fire = function() {&#10;      var token = new IntMatrixToken([[1, 2], [3, 4]]);&#10;      this.send('output', token);&#10;   }&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;&#10;   Scripts can instantiate Java classes and invoke methods on them.&#10;   For example, the following script will build a simple Ptolemy II model&#10;   and execute it each time this JavaScript actor fires.&#10;   &lt;pre&gt;&#10;   var Ramp = Java.type('ptolemy.actor.lib.Ramp');&#10;   var FileWriter = Java.type('ptolemy.actor.lib.FileWriter');&#10;   var SDFDirector = Java.type('ptolemy.domains.sdf.kernel.SDFDirector');&#10;   var TypedCompositeActor = Java.type('ptolemy.actor.TypedCompositeActor');&#10;   var Manager = Java.type('ptolemy.actor.Manager');&#10;&#10;   var toplevel = new TypedCompositeActor();&#10;   var ramp = new Ramp(toplevel, &quot;ramp&quot;);&#10;   var writer = new FileWriter(toplevel, &quot;writer&quot;);&#10;&#10;   toplevel.connect(ramp.output, writer.input);&#10;&#10;   var director = new SDFDirector(toplevel, &quot;SDFDirector&quot;);&#10;   director.getAttribute('iterations').setExpression(&quot;10&quot;);&#10;   var manager = new Manager();&#10;   toplevel.setManager(manager);&#10;&#10;   exports.fire = function() {&#10;      manager.execute();&#10;   }&#10;   &lt;/pre&gt;&#10;   &lt;p&gt;You can even send this model out on an output port.&#10;   For example,&lt;/p&gt;&#10;   &lt;pre&gt;&#10;   exports.fire = function() {&#10;      this.send('output', toplevel);&#10;   }&#10;   &lt;/pre&gt;&#10;   where &quot;output&quot; is the name of the output port. Note that the manager&#10;   does not get included with the model, so the recipient will need to&#10;   associate a new manager to be able to execute the model.&#10;   Note further that you may want to declare the type of the output&#10;   to be 'actor', a Ptolemy II type.&#10;   &lt;p&gt;&#10;   Subclasses of this actor may put it in &quot;restricted&quot; mode, which&#10;   limits the functionality as follows:&lt;/p&gt;&#10;   &lt;ul&gt;&#10;   &lt;li&gt; The &quot;actor&quot; variable (referring to this instance of the actor) provides limited capabilities.&lt;/li&gt;&#10;   &lt;li&gt; The localHostAddress() function throws an error.&lt;/li&gt;&#10;   &lt;li&gt; The readURL and httpRequest function only support the HTTP protocol (in particular,&#10;   they do not support the &quot;file&quot; protocol, and hence cannot access local files).&lt;/li&gt;&#10;   &lt;/ul&gt;&#10;   &lt;p&gt;&#10;   For debugging, it can be useful to right click on this actor and select Listen to Actor.&#10;   Refer to &lt;a href=&quot;https://accessors.org&quot;&gt;https://accessors.org&lt;/a&gt;&#10;   for a complete definition of the available functionality. For example,&#10;   it is explained there how to create composite accessors, which instantiate and connect&#10;   multiple subaccessors within this one.&#10;   &lt;/p&gt;  </description>
  <author>Edward A. Lee</author>
  <version>$Id$</version>
  <since>Ptolemy II 10.0</since>
  <Pt.ProposedRating>Yellow (eal)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (bilung)</Pt.AcceptedRating>
    <!--ptolemy.actor.TypedIOPort-->
    <port name="error">Output port on which to produce a message when an error occurs&#10;  when executing this actor. Note that if nothing is&#10;  connected to this port, then an error will cause this&#10;  JavaScript actor to throw an exception. Otherwise, a&#10;  description of the error will be produced on this port and the&#10;  actor will continue executing. Note that any errors that occur&#10;  during loading the script or invoking the initialize() or&#10;  wrapup() functions always result in an exception, since it&#10;  makes no sense to produce an output during those phases of&#10;  execution.</port>
    <!--ptolemy.actor.parameters.PortParameter-->
    <property name="script">The script defining the behavior of this actor.</property>
</doc>
